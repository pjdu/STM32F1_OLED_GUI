
OLED_MENU.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001e4  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00003794  080001f0  080001f0  000101f0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000850  08003984  08003984  00013984  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  080041d4  080041d4  000141d4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  080041d8  080041d8  000141d8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         000000d4  20000000  080041dc  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          00003f54  200000d4  080042b0  000200d4  2**2
                  ALLOC
  7 ._user_heap_stack 00000600  20004028  080042b0  00024028  2**0
                  ALLOC
  8 .ARM.attributes 00000029  00000000  00000000  000200d4  2**0
                  CONTENTS, READONLY
  9 .debug_info   00024e27  00000000  00000000  000200fd  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00004ef6  00000000  00000000  00044f24  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000cffc  00000000  00000000  00049e1a  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_aranges 00000ef0  00000000  00000000  00056e18  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00001468  00000000  00000000  00057d08  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   000099b7  00000000  00000000  00059170  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    00005759  00000000  00000000  00062b27  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .comment      0000007c  00000000  00000000  00068280  2**0
                  CONTENTS, READONLY
 17 .debug_frame  00002bd8  00000000  00000000  000682fc  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080001f0 <__do_global_dtors_aux>:
 80001f0:	b510      	push	{r4, lr}
 80001f2:	4c05      	ldr	r4, [pc, #20]	; (8000208 <__do_global_dtors_aux+0x18>)
 80001f4:	7823      	ldrb	r3, [r4, #0]
 80001f6:	b933      	cbnz	r3, 8000206 <__do_global_dtors_aux+0x16>
 80001f8:	4b04      	ldr	r3, [pc, #16]	; (800020c <__do_global_dtors_aux+0x1c>)
 80001fa:	b113      	cbz	r3, 8000202 <__do_global_dtors_aux+0x12>
 80001fc:	4804      	ldr	r0, [pc, #16]	; (8000210 <__do_global_dtors_aux+0x20>)
 80001fe:	f3af 8000 	nop.w
 8000202:	2301      	movs	r3, #1
 8000204:	7023      	strb	r3, [r4, #0]
 8000206:	bd10      	pop	{r4, pc}
 8000208:	200000d4 	.word	0x200000d4
 800020c:	00000000 	.word	0x00000000
 8000210:	0800396c 	.word	0x0800396c

08000214 <frame_dummy>:
 8000214:	b508      	push	{r3, lr}
 8000216:	4b03      	ldr	r3, [pc, #12]	; (8000224 <frame_dummy+0x10>)
 8000218:	b11b      	cbz	r3, 8000222 <frame_dummy+0xe>
 800021a:	4903      	ldr	r1, [pc, #12]	; (8000228 <frame_dummy+0x14>)
 800021c:	4803      	ldr	r0, [pc, #12]	; (800022c <frame_dummy+0x18>)
 800021e:	f3af 8000 	nop.w
 8000222:	bd08      	pop	{r3, pc}
 8000224:	00000000 	.word	0x00000000
 8000228:	200000d8 	.word	0x200000d8
 800022c:	0800396c 	.word	0x0800396c

08000230 <strlen>:
 8000230:	4603      	mov	r3, r0
 8000232:	f813 2b01 	ldrb.w	r2, [r3], #1
 8000236:	2a00      	cmp	r2, #0
 8000238:	d1fb      	bne.n	8000232 <strlen+0x2>
 800023a:	1a18      	subs	r0, r3, r0
 800023c:	3801      	subs	r0, #1
 800023e:	4770      	bx	lr

08000240 <START_task>:

}

/* USER CODE BEGIN 4 */

void START_task(void *pvParameters){
 8000240:	b507      	push	{r0, r1, r2, lr}
	taskENTER_CRITICAL();
 8000242:	f001 fbd7 	bl	80019f4 <vPortEnterCritical>

	xTaskCreate((TaskFunction_t  )(Menu_Task),         	  	//Task Function
 8000246:	4b0e      	ldr	r3, [pc, #56]	; (8000280 <START_task+0x40>)
 8000248:	2280      	movs	r2, #128	; 0x80
 800024a:	9301      	str	r3, [sp, #4]
 800024c:	2302      	movs	r3, #2
 800024e:	490d      	ldr	r1, [pc, #52]	; (8000284 <START_task+0x44>)
 8000250:	9300      	str	r3, [sp, #0]
 8000252:	480d      	ldr	r0, [pc, #52]	; (8000288 <START_task+0x48>)
 8000254:	2300      	movs	r3, #0
 8000256:	f002 f91b 	bl	8002490 <xTaskCreate>
				(uint16_t        ) MENU_TASK_STACK_SIZE, 	//Task Stack Size
				(void *          ) NULL,				    //Task Fuction Parameter
				(UBaseType_t     ) MENU_TASK_PRIORITY, 		//Task Priority
				(TaskHandle_t    ) &MenuTaskHandler);	    //Task Handler

	xTaskCreate((TaskFunction_t  )(GPIO_task),         	  	//Task Function
 800025a:	4b0c      	ldr	r3, [pc, #48]	; (800028c <START_task+0x4c>)
 800025c:	2246      	movs	r2, #70	; 0x46
 800025e:	9301      	str	r3, [sp, #4]
 8000260:	2303      	movs	r3, #3
 8000262:	490b      	ldr	r1, [pc, #44]	; (8000290 <START_task+0x50>)
 8000264:	9300      	str	r3, [sp, #0]
 8000266:	480b      	ldr	r0, [pc, #44]	; (8000294 <START_task+0x54>)
 8000268:	2300      	movs	r3, #0
 800026a:	f002 f911 	bl	8002490 <xTaskCreate>
				(uint16_t        ) GPIO_TASK_STACK_SIZE, 	//Task Stack Size
				(void *          ) NULL,				    //Task Fuction Parameter
				(UBaseType_t     ) GPIO_TASK_PRIORITY, 		//Task Priority
				(TaskHandle_t    ) &GPIOTaskHandler);	    //Task Handler

	vTaskDelete(StartTaskHandler);
 800026e:	4b0a      	ldr	r3, [pc, #40]	; (8000298 <START_task+0x58>)
 8000270:	6818      	ldr	r0, [r3, #0]
 8000272:	f002 f9ed 	bl	8002650 <vTaskDelete>
	taskEXIT_CRITICAL();
}
 8000276:	b003      	add	sp, #12
 8000278:	f85d eb04 	ldr.w	lr, [sp], #4
	taskEXIT_CRITICAL();
 800027c:	f001 bbdc 	b.w	8001a38 <vPortExitCritical>
 8000280:	20003e68 	.word	0x20003e68
 8000284:	08003994 	.word	0x08003994
 8000288:	08003225 	.word	0x08003225
 800028c:	20003ec4 	.word	0x20003ec4
 8000290:	0800399e 	.word	0x0800399e
 8000294:	0800029d 	.word	0x0800029d
 8000298:	20003f08 	.word	0x20003f08

0800029c <GPIO_task>:
void GPIO_task(void *pvParameters){
 800029c:	b508      	push	{r3, lr}

	while(1){
		HAL_GPIO_TogglePin(LED0_GPIO_Port, LED0_Pin);
 800029e:	4d0a      	ldr	r5, [pc, #40]	; (80002c8 <GPIO_task+0x2c>)
		vTaskDelay(1000/portTICK_PERIOD_MS);
		HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);
 80002a0:	4c0a      	ldr	r4, [pc, #40]	; (80002cc <GPIO_task+0x30>)
		HAL_GPIO_TogglePin(LED0_GPIO_Port, LED0_Pin);
 80002a2:	f44f 7180 	mov.w	r1, #256	; 0x100
 80002a6:	4628      	mov	r0, r5
 80002a8:	f000 fe7d 	bl	8000fa6 <HAL_GPIO_TogglePin>
		vTaskDelay(1000/portTICK_PERIOD_MS);
 80002ac:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80002b0:	f002 fb92 	bl	80029d8 <vTaskDelay>
		HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);
 80002b4:	4620      	mov	r0, r4
 80002b6:	2104      	movs	r1, #4
 80002b8:	f000 fe75 	bl	8000fa6 <HAL_GPIO_TogglePin>
		vTaskDelay(2000/portTICK_PERIOD_MS);
 80002bc:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 80002c0:	f002 fb8a 	bl	80029d8 <vTaskDelay>
 80002c4:	e7ed      	b.n	80002a2 <GPIO_task+0x6>
 80002c6:	bf00      	nop
 80002c8:	40010800 	.word	0x40010800
 80002cc:	40011400 	.word	0x40011400

080002d0 <SystemClock_Config>:
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 80002d0:	f44f 3380 	mov.w	r3, #65536	; 0x10000
{
 80002d4:	b510      	push	{r4, lr}
 80002d6:	b090      	sub	sp, #64	; 0x40
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 80002d8:	2201      	movs	r2, #1
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 80002da:	9307      	str	r3, [sp, #28]
  RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
 80002dc:	2100      	movs	r1, #0
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 80002de:	2402      	movs	r4, #2
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 80002e0:	930e      	str	r3, [sp, #56]	; 0x38
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
 80002e2:	f44f 13e0 	mov.w	r3, #1835008	; 0x1c0000
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80002e6:	a806      	add	r0, sp, #24
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 80002e8:	9206      	str	r2, [sp, #24]
  RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
 80002ea:	9108      	str	r1, [sp, #32]
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 80002ec:	920a      	str	r2, [sp, #40]	; 0x28
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 80002ee:	940d      	str	r4, [sp, #52]	; 0x34
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
 80002f0:	930f      	str	r3, [sp, #60]	; 0x3c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80002f2:	f000 fe5d 	bl	8000fb0 <HAL_RCC_OscConfig>
 80002f6:	b100      	cbz	r0, 80002fa <SystemClock_Config+0x2a>
 80002f8:	e7fe      	b.n	80002f8 <SystemClock_Config+0x28>
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 80002fa:	230f      	movs	r3, #15
 80002fc:	9301      	str	r3, [sp, #4]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
 80002fe:	f44f 6380 	mov.w	r3, #1024	; 0x400
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8000302:	9003      	str	r0, [sp, #12]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8000304:	9005      	str	r0, [sp, #20]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
 8000306:	4621      	mov	r1, r4
 8000308:	a801      	add	r0, sp, #4
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 800030a:	9402      	str	r4, [sp, #8]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
 800030c:	9304      	str	r3, [sp, #16]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
 800030e:	f001 f817 	bl	8001340 <HAL_RCC_ClockConfig>
 8000312:	4604      	mov	r4, r0
 8000314:	b100      	cbz	r0, 8000318 <SystemClock_Config+0x48>
 8000316:	e7fe      	b.n	8000316 <SystemClock_Config+0x46>
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 8000318:	f001 f8b6 	bl	8001488 <HAL_RCC_GetHCLKFreq>
 800031c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8000320:	fbb0 f0f3 	udiv	r0, r0, r3
 8000324:	f000 fd26 	bl	8000d74 <HAL_SYSTICK_Config>
  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
 8000328:	2004      	movs	r0, #4
 800032a:	f000 fd39 	bl	8000da0 <HAL_SYSTICK_CLKSourceConfig>
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 800032e:	4622      	mov	r2, r4
 8000330:	4621      	mov	r1, r4
 8000332:	f04f 30ff 	mov.w	r0, #4294967295
 8000336:	f000 fce9 	bl	8000d0c <HAL_NVIC_SetPriority>
}
 800033a:	b010      	add	sp, #64	; 0x40
 800033c:	bd10      	pop	{r4, pc}
	...

08000340 <main>:
{
 8000340:	b580      	push	{r7, lr}
 8000342:	b092      	sub	sp, #72	; 0x48
  HAL_Init();
 8000344:	f000 fc9a 	bl	8000c7c <HAL_Init>
  SystemClock_Config();
 8000348:	f7ff ffc2 	bl	80002d0 <SystemClock_Config>
  __HAL_RCC_GPIOD_CLK_ENABLE();
 800034c:	4b63      	ldr	r3, [pc, #396]	; (80004dc <main+0x19c>)
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 800034e:	2500      	movs	r5, #0
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8000350:	699a      	ldr	r2, [r3, #24]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 8000352:	2401      	movs	r4, #1
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8000354:	f042 0220 	orr.w	r2, r2, #32
 8000358:	619a      	str	r2, [r3, #24]
 800035a:	699a      	ldr	r2, [r3, #24]
  GPIO_InitStruct.Pin = ROTARY_SW_Pin;
 800035c:	f04f 0808 	mov.w	r8, #8
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8000360:	f002 0220 	and.w	r2, r2, #32
 8000364:	9203      	str	r2, [sp, #12]
 8000366:	9a03      	ldr	r2, [sp, #12]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8000368:	699a      	ldr	r2, [r3, #24]
  HAL_GPIO_WritePin(GPIOB, SPI_CS_Pin|OLED_RST_Pin, GPIO_PIN_SET);
 800036a:	f44f 41a0 	mov.w	r1, #20480	; 0x5000
  __HAL_RCC_GPIOC_CLK_ENABLE();
 800036e:	f042 0210 	orr.w	r2, r2, #16
 8000372:	619a      	str	r2, [r3, #24]
 8000374:	699a      	ldr	r2, [r3, #24]
  HAL_GPIO_WritePin(GPIOB, SPI_CS_Pin|OLED_RST_Pin, GPIO_PIN_SET);
 8000376:	485a      	ldr	r0, [pc, #360]	; (80004e0 <main+0x1a0>)
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8000378:	f002 0210 	and.w	r2, r2, #16
 800037c:	9204      	str	r2, [sp, #16]
 800037e:	9a04      	ldr	r2, [sp, #16]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8000380:	699a      	ldr	r2, [r3, #24]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8000382:	2603      	movs	r6, #3
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8000384:	f042 0204 	orr.w	r2, r2, #4
 8000388:	619a      	str	r2, [r3, #24]
 800038a:	699a      	ldr	r2, [r3, #24]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800038c:	2702      	movs	r7, #2
  __HAL_RCC_GPIOA_CLK_ENABLE();
 800038e:	f002 0204 	and.w	r2, r2, #4
 8000392:	9205      	str	r2, [sp, #20]
 8000394:	9a05      	ldr	r2, [sp, #20]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8000396:	699a      	ldr	r2, [r3, #24]
 8000398:	f042 0208 	orr.w	r2, r2, #8
 800039c:	619a      	str	r2, [r3, #24]
 800039e:	699b      	ldr	r3, [r3, #24]
  HAL_GPIO_WritePin(GPIOB, SPI_CS_Pin|OLED_RST_Pin, GPIO_PIN_SET);
 80003a0:	2201      	movs	r2, #1
  __HAL_RCC_GPIOB_CLK_ENABLE();
 80003a2:	f003 0308 	and.w	r3, r3, #8
 80003a6:	9306      	str	r3, [sp, #24]
 80003a8:	9b06      	ldr	r3, [sp, #24]
  HAL_GPIO_WritePin(GPIOB, SPI_CS_Pin|OLED_RST_Pin, GPIO_PIN_SET);
 80003aa:	f000 fdf7 	bl	8000f9c <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(OLED_DC_GPIO_Port, OLED_DC_Pin, GPIO_PIN_SET);
 80003ae:	2201      	movs	r2, #1
 80003b0:	2140      	movs	r1, #64	; 0x40
 80003b2:	484c      	ldr	r0, [pc, #304]	; (80004e4 <main+0x1a4>)
 80003b4:	f000 fdf2 	bl	8000f9c <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(LED0_GPIO_Port, LED0_Pin, GPIO_PIN_RESET);
 80003b8:	2200      	movs	r2, #0
 80003ba:	f44f 7180 	mov.w	r1, #256	; 0x100
 80003be:	484a      	ldr	r0, [pc, #296]	; (80004e8 <main+0x1a8>)
 80003c0:	f000 fdec 	bl	8000f9c <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_RESET);
 80003c4:	2200      	movs	r2, #0
 80003c6:	2104      	movs	r1, #4
 80003c8:	4848      	ldr	r0, [pc, #288]	; (80004ec <main+0x1ac>)
 80003ca:	f000 fde7 	bl	8000f9c <HAL_GPIO_WritePin>
  HAL_GPIO_Init(ROTARY_SW_GPIO_Port, &GPIO_InitStruct);
 80003ce:	a909      	add	r1, sp, #36	; 0x24
 80003d0:	4844      	ldr	r0, [pc, #272]	; (80004e4 <main+0x1a4>)
  GPIO_InitStruct.Pin = ROTARY_SW_Pin;
 80003d2:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 80003d6:	950a      	str	r5, [sp, #40]	; 0x28
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 80003d8:	940b      	str	r4, [sp, #44]	; 0x2c
  HAL_GPIO_Init(ROTARY_SW_GPIO_Port, &GPIO_InitStruct);
 80003da:	f000 fcf3 	bl	8000dc4 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = SPI_CS_Pin;
 80003de:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  HAL_GPIO_Init(SPI_CS_GPIO_Port, &GPIO_InitStruct);
 80003e2:	a909      	add	r1, sp, #36	; 0x24
 80003e4:	483e      	ldr	r0, [pc, #248]	; (80004e0 <main+0x1a0>)
  GPIO_InitStruct.Pin = SPI_CS_Pin;
 80003e6:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80003e8:	940a      	str	r4, [sp, #40]	; 0x28
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80003ea:	950b      	str	r5, [sp, #44]	; 0x2c
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 80003ec:	960c      	str	r6, [sp, #48]	; 0x30
  HAL_GPIO_Init(SPI_CS_GPIO_Port, &GPIO_InitStruct);
 80003ee:	f000 fce9 	bl	8000dc4 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = OLED_RST_Pin;
 80003f2:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  HAL_GPIO_Init(OLED_RST_GPIO_Port, &GPIO_InitStruct);
 80003f6:	a909      	add	r1, sp, #36	; 0x24
 80003f8:	4839      	ldr	r0, [pc, #228]	; (80004e0 <main+0x1a0>)
  GPIO_InitStruct.Pin = OLED_RST_Pin;
 80003fa:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80003fc:	940a      	str	r4, [sp, #40]	; 0x28
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 80003fe:	940b      	str	r4, [sp, #44]	; 0x2c
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8000400:	960c      	str	r6, [sp, #48]	; 0x30
  HAL_GPIO_Init(OLED_RST_GPIO_Port, &GPIO_InitStruct);
 8000402:	f000 fcdf 	bl	8000dc4 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = OLED_DC_Pin;
 8000406:	2340      	movs	r3, #64	; 0x40
  HAL_GPIO_Init(OLED_DC_GPIO_Port, &GPIO_InitStruct);
 8000408:	a909      	add	r1, sp, #36	; 0x24
 800040a:	4836      	ldr	r0, [pc, #216]	; (80004e4 <main+0x1a4>)
  GPIO_InitStruct.Pin = OLED_DC_Pin;
 800040c:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800040e:	940a      	str	r4, [sp, #40]	; 0x28
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000410:	950b      	str	r5, [sp, #44]	; 0x2c
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_MEDIUM;
 8000412:	940c      	str	r4, [sp, #48]	; 0x30
  HAL_GPIO_Init(OLED_DC_GPIO_Port, &GPIO_InitStruct);
 8000414:	f000 fcd6 	bl	8000dc4 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = LED0_Pin;
 8000418:	f44f 7380 	mov.w	r3, #256	; 0x100
  HAL_GPIO_Init(LED0_GPIO_Port, &GPIO_InitStruct);
 800041c:	a909      	add	r1, sp, #36	; 0x24
 800041e:	4832      	ldr	r0, [pc, #200]	; (80004e8 <main+0x1a8>)
  GPIO_InitStruct.Pin = LED0_Pin;
 8000420:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8000422:	970c      	str	r7, [sp, #48]	; 0x30
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8000424:	940a      	str	r4, [sp, #40]	; 0x28
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000426:	950b      	str	r5, [sp, #44]	; 0x2c
  HAL_GPIO_Init(LED0_GPIO_Port, &GPIO_InitStruct);
 8000428:	f000 fccc 	bl	8000dc4 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = LED1_Pin;
 800042c:	2304      	movs	r3, #4
  HAL_GPIO_Init(LED1_GPIO_Port, &GPIO_InitStruct);
 800042e:	a909      	add	r1, sp, #36	; 0x24
 8000430:	482e      	ldr	r0, [pc, #184]	; (80004ec <main+0x1ac>)
  GPIO_InitStruct.Pin = LED1_Pin;
 8000432:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8000434:	970c      	str	r7, [sp, #48]	; 0x30
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8000436:	940a      	str	r4, [sp, #40]	; 0x28
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000438:	950b      	str	r5, [sp, #44]	; 0x2c
  HAL_GPIO_Init(LED1_GPIO_Port, &GPIO_InitStruct);
 800043a:	f000 fcc3 	bl	8000dc4 <HAL_GPIO_Init>
  hspi2.Init.Direction = SPI_DIRECTION_1LINE;
 800043e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8000442:	f44f 7282 	mov.w	r2, #260	; 0x104
  hspi2.Instance = SPI2;
 8000446:	482a      	ldr	r0, [pc, #168]	; (80004f0 <main+0x1b0>)
  hspi2.Init.Direction = SPI_DIRECTION_1LINE;
 8000448:	492a      	ldr	r1, [pc, #168]	; (80004f4 <main+0x1b4>)
  hspi2.Init.CLKPolarity = SPI_POLARITY_HIGH;
 800044a:	6107      	str	r7, [r0, #16]
  hspi2.Init.Direction = SPI_DIRECTION_1LINE;
 800044c:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  hspi2.Init.CRCPolynomial = 10;
 8000450:	270a      	movs	r7, #10
  hspi2.Init.NSS = SPI_NSS_SOFT;
 8000452:	f44f 7300 	mov.w	r3, #512	; 0x200
  hspi2.Init.DataSize = SPI_DATASIZE_8BIT;
 8000456:	60c5      	str	r5, [r0, #12]
  hspi2.Init.CLKPhase = SPI_PHASE_2EDGE;
 8000458:	6144      	str	r4, [r0, #20]
  hspi2.Init.NSS = SPI_NSS_SOFT;
 800045a:	6183      	str	r3, [r0, #24]
  hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;
 800045c:	f8c0 801c 	str.w	r8, [r0, #28]
  hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
 8000460:	6205      	str	r5, [r0, #32]
  hspi2.Init.TIMode = SPI_TIMODE_DISABLE;
 8000462:	6245      	str	r5, [r0, #36]	; 0x24
  hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8000464:	6285      	str	r5, [r0, #40]	; 0x28
  hspi2.Init.CRCPolynomial = 10;
 8000466:	62c7      	str	r7, [r0, #44]	; 0x2c
  if (HAL_SPI_Init(&hspi2) != HAL_OK)
 8000468:	f001 f914 	bl	8001694 <HAL_SPI_Init>
 800046c:	b100      	cbz	r0, 8000470 <main+0x130>
 800046e:	e7fe      	b.n	800046e <main+0x12e>
  htim2.Instance = TIM2;
 8000470:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8000474:	4d20      	ldr	r5, [pc, #128]	; (80004f8 <main+0x1b8>)
  sConfig.IC1Polarity = TIM_ICPOLARITY_RISING;
 8000476:	900a      	str	r0, [sp, #40]	; 0x28
  htim2.Init.Prescaler = 3;
 8000478:	e885 0048 	stmia.w	r5, {r3, r6}
  htim2.Init.Period = 65535;
 800047c:	f64f 73ff 	movw	r3, #65535	; 0xffff
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
 8000480:	60a8      	str	r0, [r5, #8]
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8000482:	6128      	str	r0, [r5, #16]
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8000484:	61a8      	str	r0, [r5, #24]
  sConfig.IC1Prescaler = TIM_ICPSC_DIV1;
 8000486:	900c      	str	r0, [sp, #48]	; 0x30
  sConfig.IC2Polarity = TIM_ICPOLARITY_RISING;
 8000488:	900e      	str	r0, [sp, #56]	; 0x38
  sConfig.IC2Prescaler = TIM_ICPSC_DIV1;
 800048a:	9010      	str	r0, [sp, #64]	; 0x40
  if (HAL_TIM_Encoder_Init(&htim2, &sConfig) != HAL_OK)
 800048c:	a909      	add	r1, sp, #36	; 0x24
 800048e:	4628      	mov	r0, r5
  htim2.Init.Period = 65535;
 8000490:	60eb      	str	r3, [r5, #12]
  sConfig.EncoderMode = TIM_ENCODERMODE_TI12;
 8000492:	9609      	str	r6, [sp, #36]	; 0x24
  sConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;
 8000494:	940b      	str	r4, [sp, #44]	; 0x2c
  sConfig.IC1Filter = 10;
 8000496:	970d      	str	r7, [sp, #52]	; 0x34
  sConfig.IC2Selection = TIM_ICSELECTION_DIRECTTI;
 8000498:	940f      	str	r4, [sp, #60]	; 0x3c
  sConfig.IC2Filter = 10;
 800049a:	9711      	str	r7, [sp, #68]	; 0x44
  if (HAL_TIM_Encoder_Init(&htim2, &sConfig) != HAL_OK)
 800049c:	f001 f9a4 	bl	80017e8 <HAL_TIM_Encoder_Init>
 80004a0:	b100      	cbz	r0, 80004a4 <main+0x164>
 80004a2:	e7fe      	b.n	80004a2 <main+0x162>
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 80004a4:	9007      	str	r0, [sp, #28]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 80004a6:	9008      	str	r0, [sp, #32]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
 80004a8:	a907      	add	r1, sp, #28
 80004aa:	4628      	mov	r0, r5
 80004ac:	f001 f9e5 	bl	800187a <HAL_TIMEx_MasterConfigSynchronization>
 80004b0:	4605      	mov	r5, r0
 80004b2:	b100      	cbz	r0, 80004b6 <main+0x176>
 80004b4:	e7fe      	b.n	80004b4 <main+0x174>
	RotaryEcncorder_Init();
 80004b6:	f000 fb5d 	bl	8000b74 <RotaryEcncorder_Init>
	OLED_Init();
 80004ba:	f000 fa55 	bl	8000968 <OLED_Init>
	mainMenuInit();
 80004be:	f002 fdd3 	bl	8003068 <mainMenuInit>
	xTaskCreate((TaskFunction_t  )(START_task),         	//Task Function
 80004c2:	4b0e      	ldr	r3, [pc, #56]	; (80004fc <main+0x1bc>)
 80004c4:	2280      	movs	r2, #128	; 0x80
 80004c6:	9301      	str	r3, [sp, #4]
 80004c8:	490d      	ldr	r1, [pc, #52]	; (8000500 <main+0x1c0>)
 80004ca:	462b      	mov	r3, r5
 80004cc:	9400      	str	r4, [sp, #0]
 80004ce:	480d      	ldr	r0, [pc, #52]	; (8000504 <main+0x1c4>)
 80004d0:	f001 ffde 	bl	8002490 <xTaskCreate>
	vTaskStartScheduler();
 80004d4:	f002 f928 	bl	8002728 <vTaskStartScheduler>
 80004d8:	e7fe      	b.n	80004d8 <main+0x198>
 80004da:	bf00      	nop
 80004dc:	40021000 	.word	0x40021000
 80004e0:	40010c00 	.word	0x40010c00
 80004e4:	40011000 	.word	0x40011000
 80004e8:	40010800 	.word	0x40010800
 80004ec:	40011400 	.word	0x40011400
 80004f0:	20003e6c 	.word	0x20003e6c
 80004f4:	40003800 	.word	0x40003800
 80004f8:	20003ec8 	.word	0x20003ec8
 80004fc:	20003f08 	.word	0x20003f08
 8000500:	080039a8 	.word	0x080039a8
 8000504:	08000241 	.word	0x08000241

08000508 <HAL_MspInit>:
{
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_AFIO_CLK_ENABLE();
 8000508:	4b25      	ldr	r3, [pc, #148]	; (80005a0 <HAL_MspInit+0x98>)
{
 800050a:	b507      	push	{r0, r1, r2, lr}
  __HAL_RCC_AFIO_CLK_ENABLE();
 800050c:	699a      	ldr	r2, [r3, #24]
  __HAL_RCC_PWR_CLK_ENABLE();

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800050e:	2003      	movs	r0, #3
  __HAL_RCC_AFIO_CLK_ENABLE();
 8000510:	f042 0201 	orr.w	r2, r2, #1
 8000514:	619a      	str	r2, [r3, #24]
 8000516:	699a      	ldr	r2, [r3, #24]
 8000518:	f002 0201 	and.w	r2, r2, #1
 800051c:	9200      	str	r2, [sp, #0]
 800051e:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 8000520:	69da      	ldr	r2, [r3, #28]
 8000522:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8000526:	61da      	str	r2, [r3, #28]
 8000528:	69db      	ldr	r3, [r3, #28]
 800052a:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800052e:	9301      	str	r3, [sp, #4]
 8000530:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8000532:	f000 fbd9 	bl	8000ce8 <HAL_NVIC_SetPriorityGrouping>

  /* System interrupt init*/
  /* MemoryManagement_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(MemoryManagement_IRQn, 0, 0);
 8000536:	2200      	movs	r2, #0
 8000538:	f06f 000b 	mvn.w	r0, #11
 800053c:	4611      	mov	r1, r2
 800053e:	f000 fbe5 	bl	8000d0c <HAL_NVIC_SetPriority>
  /* BusFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(BusFault_IRQn, 0, 0);
 8000542:	2200      	movs	r2, #0
 8000544:	f06f 000a 	mvn.w	r0, #10
 8000548:	4611      	mov	r1, r2
 800054a:	f000 fbdf 	bl	8000d0c <HAL_NVIC_SetPriority>
  /* UsageFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(UsageFault_IRQn, 0, 0);
 800054e:	2200      	movs	r2, #0
 8000550:	f06f 0009 	mvn.w	r0, #9
 8000554:	4611      	mov	r1, r2
 8000556:	f000 fbd9 	bl	8000d0c <HAL_NVIC_SetPriority>
  /* SVCall_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SVCall_IRQn, 0, 0);
 800055a:	2200      	movs	r2, #0
 800055c:	f06f 0004 	mvn.w	r0, #4
 8000560:	4611      	mov	r1, r2
 8000562:	f000 fbd3 	bl	8000d0c <HAL_NVIC_SetPriority>
  /* DebugMonitor_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0);
 8000566:	2200      	movs	r2, #0
 8000568:	f06f 0003 	mvn.w	r0, #3
 800056c:	4611      	mov	r1, r2
 800056e:	f000 fbcd 	bl	8000d0c <HAL_NVIC_SetPriority>
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 0, 0);
 8000572:	2200      	movs	r2, #0
 8000574:	f06f 0001 	mvn.w	r0, #1
 8000578:	4611      	mov	r1, r2
 800057a:	f000 fbc7 	bl	8000d0c <HAL_NVIC_SetPriority>
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 800057e:	2200      	movs	r2, #0
 8000580:	f04f 30ff 	mov.w	r0, #4294967295
 8000584:	4611      	mov	r1, r2
 8000586:	f000 fbc1 	bl	8000d0c <HAL_NVIC_SetPriority>

    /**NOJTAG: JTAG-DP Disabled and SW-DP Enabled 
    */
  __HAL_AFIO_REMAP_SWJ_NOJTAG();
 800058a:	4a06      	ldr	r2, [pc, #24]	; (80005a4 <HAL_MspInit+0x9c>)
 800058c:	6853      	ldr	r3, [r2, #4]
 800058e:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
 8000592:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8000596:	6053      	str	r3, [r2, #4]

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8000598:	b003      	add	sp, #12
 800059a:	f85d fb04 	ldr.w	pc, [sp], #4
 800059e:	bf00      	nop
 80005a0:	40021000 	.word	0x40021000
 80005a4:	40010000 	.word	0x40010000

080005a8 <HAL_SPI_MspInit>:

void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
{
 80005a8:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if(hspi->Instance==SPI2)
 80005aa:	6802      	ldr	r2, [r0, #0]
 80005ac:	4b0d      	ldr	r3, [pc, #52]	; (80005e4 <HAL_SPI_MspInit+0x3c>)
 80005ae:	429a      	cmp	r2, r3
 80005b0:	d115      	bne.n	80005de <HAL_SPI_MspInit+0x36>
  {
  /* USER CODE BEGIN SPI2_MspInit 0 */

  /* USER CODE END SPI2_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_SPI2_CLK_ENABLE();
 80005b2:	f503 33ec 	add.w	r3, r3, #120832	; 0x1d800
 80005b6:	69da      	ldr	r2, [r3, #28]
    PB15     ------> SPI2_MOSI 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_13|GPIO_PIN_15;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80005b8:	a902      	add	r1, sp, #8
    __HAL_RCC_SPI2_CLK_ENABLE();
 80005ba:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 80005be:	61da      	str	r2, [r3, #28]
 80005c0:	69db      	ldr	r3, [r3, #28]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80005c2:	4809      	ldr	r0, [pc, #36]	; (80005e8 <HAL_SPI_MspInit+0x40>)
    __HAL_RCC_SPI2_CLK_ENABLE();
 80005c4:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 80005c8:	9301      	str	r3, [sp, #4]
 80005ca:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Pin = GPIO_PIN_13|GPIO_PIN_15;
 80005cc:	f44f 4320 	mov.w	r3, #40960	; 0xa000
 80005d0:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80005d2:	2302      	movs	r3, #2
 80005d4:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 80005d6:	2303      	movs	r3, #3
 80005d8:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80005da:	f000 fbf3 	bl	8000dc4 <HAL_GPIO_Init>
  /* USER CODE BEGIN SPI2_MspInit 1 */

  /* USER CODE END SPI2_MspInit 1 */
  }

}
 80005de:	b007      	add	sp, #28
 80005e0:	f85d fb04 	ldr.w	pc, [sp], #4
 80005e4:	40003800 	.word	0x40003800
 80005e8:	40010c00 	.word	0x40010c00

080005ec <HAL_TIM_Encoder_MspInit>:
  }

}

void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef* htim_encoder)
{
 80005ec:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if(htim_encoder->Instance==TIM2)
 80005ee:	6803      	ldr	r3, [r0, #0]
 80005f0:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 80005f4:	d114      	bne.n	8000620 <HAL_TIM_Encoder_MspInit+0x34>
  {
  /* USER CODE BEGIN TIM2_MspInit 0 */

  /* USER CODE END TIM2_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM2_CLK_ENABLE();
 80005f6:	f503 3304 	add.w	r3, r3, #135168	; 0x21000
 80005fa:	69da      	ldr	r2, [r3, #28]
    PA1     ------> TIM2_CH2 
    */
    GPIO_InitStruct.Pin = ROTARY_A_Pin|ROTARY_B_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80005fc:	a902      	add	r1, sp, #8
    __HAL_RCC_TIM2_CLK_ENABLE();
 80005fe:	f042 0201 	orr.w	r2, r2, #1
 8000602:	61da      	str	r2, [r3, #28]
 8000604:	69db      	ldr	r3, [r3, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000606:	4808      	ldr	r0, [pc, #32]	; (8000628 <HAL_TIM_Encoder_MspInit+0x3c>)
    __HAL_RCC_TIM2_CLK_ENABLE();
 8000608:	f003 0301 	and.w	r3, r3, #1
 800060c:	9301      	str	r3, [sp, #4]
 800060e:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Pin = ROTARY_A_Pin|ROTARY_B_Pin;
 8000610:	2303      	movs	r3, #3
 8000612:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8000614:	2300      	movs	r3, #0
 8000616:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8000618:	2301      	movs	r3, #1
 800061a:	9304      	str	r3, [sp, #16]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800061c:	f000 fbd2 	bl	8000dc4 <HAL_GPIO_Init>
  /* USER CODE BEGIN TIM2_MspInit 1 */

  /* USER CODE END TIM2_MspInit 1 */
  }

}
 8000620:	b007      	add	sp, #28
 8000622:	f85d fb04 	ldr.w	pc, [sp], #4
 8000626:	bf00      	nop
 8000628:	40010800 	.word	0x40010800

0800062c <NMI_Handler>:
 800062c:	4770      	bx	lr

0800062e <HardFault_Handler>:
}

/**
 * @brief This function handles Hard fault interrupt.
 */
void HardFault_Handler(void) {
 800062e:	e7fe      	b.n	800062e <HardFault_Handler>

08000630 <MemManage_Handler>:
}

/**
 * @brief This function handles Memory management fault.
 */
void MemManage_Handler(void) {
 8000630:	e7fe      	b.n	8000630 <MemManage_Handler>

08000632 <BusFault_Handler>:
}

/**
 * @brief This function handles Prefetch fault, memory access fault.
 */
void BusFault_Handler(void) {
 8000632:	e7fe      	b.n	8000632 <BusFault_Handler>

08000634 <UsageFault_Handler>:
}

/**
 * @brief This function handles Undefined instruction or illegal state.
 */
void UsageFault_Handler(void) {
 8000634:	e7fe      	b.n	8000634 <UsageFault_Handler>

08000636 <DebugMon_Handler>:
}

/**
 * @brief This function handles Debug monitor.
 */
void DebugMon_Handler(void) {
 8000636:	4770      	bx	lr

08000638 <SysTick_Handler>:
}

/**
 * @brief This function handles System tick timer.
 */
void SysTick_Handler(void) {
 8000638:	b508      	push	{r3, lr}
	/* USER CODE BEGIN SysTick_IRQn 0 */
	if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED) {
 800063a:	f002 faf5 	bl	8002c28 <xTaskGetSchedulerState>
 800063e:	2801      	cmp	r0, #1
 8000640:	d001      	beq.n	8000646 <SysTick_Handler+0xe>
		xPortSysTickHandler();
 8000642:	f001 fa2f 	bl	8001aa4 <xPortSysTickHandler>
	}
	/* USER CODE END SysTick_IRQn 0 */
	HAL_IncTick();
 8000646:	f000 fb2b 	bl	8000ca0 <HAL_IncTick>
	HAL_SYSTICK_IRQHandler();
	/* USER CODE BEGIN SysTick_IRQn 1 */

	/* USER CODE END SysTick_IRQn 1 */
}
 800064a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	HAL_SYSTICK_IRQHandler();
 800064e:	f000 bbb4 	b.w	8000dba <HAL_SYSTICK_IRQHandler>
	...

08000654 <SystemInit>:
  */
void SystemInit (void)
{
  /* Reset the RCC clock configuration to the default reset state(for debug purpose) */
  /* Set HSION bit */
  RCC->CR |= 0x00000001U;
 8000654:	4b0f      	ldr	r3, [pc, #60]	; (8000694 <SystemInit+0x40>)
 8000656:	681a      	ldr	r2, [r3, #0]
 8000658:	f042 0201 	orr.w	r2, r2, #1
 800065c:	601a      	str	r2, [r3, #0]

  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
#if !defined(STM32F105xC) && !defined(STM32F107xC)
  RCC->CFGR &= 0xF8FF0000U;
 800065e:	6859      	ldr	r1, [r3, #4]
 8000660:	4a0d      	ldr	r2, [pc, #52]	; (8000698 <SystemInit+0x44>)
 8000662:	400a      	ands	r2, r1
 8000664:	605a      	str	r2, [r3, #4]
#else
  RCC->CFGR &= 0xF0FF0000U;
#endif /* STM32F105xC */   
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= 0xFEF6FFFFU;
 8000666:	681a      	ldr	r2, [r3, #0]
 8000668:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 800066c:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8000670:	601a      	str	r2, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;
 8000672:	681a      	ldr	r2, [r3, #0]
 8000674:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8000678:	601a      	str	r2, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
  RCC->CFGR &= 0xFF80FFFFU;
 800067a:	685a      	ldr	r2, [r3, #4]
 800067c:	f422 02fe 	bic.w	r2, r2, #8323072	; 0x7f0000
 8000680:	605a      	str	r2, [r3, #4]

  /* Reset CFGR2 register */
  RCC->CFGR2 = 0x00000000U;      
#else
  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x009F0000U;
 8000682:	f44f 021f 	mov.w	r2, #10420224	; 0x9f0000
 8000686:	609a      	str	r2, [r3, #8]
#endif 

#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
 8000688:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 800068c:	4b03      	ldr	r3, [pc, #12]	; (800069c <SystemInit+0x48>)
 800068e:	609a      	str	r2, [r3, #8]
 8000690:	4770      	bx	lr
 8000692:	bf00      	nop
 8000694:	40021000 	.word	0x40021000
 8000698:	f8ff0000 	.word	0xf8ff0000
 800069c:	e000ed00 	.word	0xe000ed00

080006a0 <write>:
#define Max_Column	0x3F			// 256/4-1
#define Max_Row		0x3F			// 64-1
#define	Brightness	0x0F

uint16_t gram[64][64] = { 0 }; // row : 64 col: 64 *4 = 256   u16 = [p1,p2,p3,p4]
static void write(uint8_t bytes, uint8_t is_data) {
 80006a0:	b513      	push	{r0, r1, r4, lr}
 80006a2:	460c      	mov	r4, r1
	uint8_t tmp = bytes;
 80006a4:	f88d 0007 	strb.w	r0, [sp, #7]
	HAL_GPIO_WritePin(SPI_CS_GPIO_Port, SPI_CS_Pin, RESET);
 80006a8:	2200      	movs	r2, #0
 80006aa:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 80006ae:	480d      	ldr	r0, [pc, #52]	; (80006e4 <write+0x44>)
 80006b0:	f000 fc74 	bl	8000f9c <HAL_GPIO_WritePin>
	if (is_data) {
 80006b4:	b1a4      	cbz	r4, 80006e0 <write+0x40>
		HAL_GPIO_WritePin(OLED_DC_GPIO_Port, OLED_DC_Pin, SET);
 80006b6:	2201      	movs	r2, #1
	}
	/* We are sending commands */
	else {
		HAL_GPIO_WritePin(OLED_DC_GPIO_Port, OLED_DC_Pin, RESET);
 80006b8:	2140      	movs	r1, #64	; 0x40
 80006ba:	480b      	ldr	r0, [pc, #44]	; (80006e8 <write+0x48>)
 80006bc:	f000 fc6e 	bl	8000f9c <HAL_GPIO_WritePin>
	}
	HAL_SPI_Transmit(&hspi2, &tmp, 1, 1000);
 80006c0:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80006c4:	f10d 0107 	add.w	r1, sp, #7
 80006c8:	2201      	movs	r2, #1
 80006ca:	4808      	ldr	r0, [pc, #32]	; (80006ec <write+0x4c>)
 80006cc:	f000 ff39 	bl	8001542 <HAL_SPI_Transmit>
	HAL_GPIO_WritePin(SPI_CS_GPIO_Port, SPI_CS_Pin, SET);
 80006d0:	2201      	movs	r2, #1
 80006d2:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 80006d6:	4803      	ldr	r0, [pc, #12]	; (80006e4 <write+0x44>)
 80006d8:	f000 fc60 	bl	8000f9c <HAL_GPIO_WritePin>
}
 80006dc:	b002      	add	sp, #8
 80006de:	bd10      	pop	{r4, pc}
		HAL_GPIO_WritePin(OLED_DC_GPIO_Port, OLED_DC_Pin, RESET);
 80006e0:	4622      	mov	r2, r4
 80006e2:	e7e9      	b.n	80006b8 <write+0x18>
 80006e4:	40010c00 	.word	0x40010c00
 80006e8:	40011000 	.word	0x40011000
 80006ec:	20003e6c 	.word	0x20003e6c

080006f0 <OLED_DrawPoint>:
//   y: OLED螢幕y座標
//	 mode: 0x00(滅) 0x01(亮)
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
void OLED_DrawPoint(uint8_t x, uint8_t y, uint8_t mode) {

	if (x > 255 || y > 63)
 80006f0:	293f      	cmp	r1, #63	; 0x3f
void OLED_DrawPoint(uint8_t x, uint8_t y, uint8_t mode) {
 80006f2:	b510      	push	{r4, lr}
	if (x > 255 || y > 63)
 80006f4:	d811      	bhi.n	800071a <OLED_DrawPoint+0x2a>
		return;
	uint16_t point = 0x000f;
	uint8_t group = x >> 2;
 80006f6:	0884      	lsrs	r4, r0, #2
	uint8_t group_bit = 3 - (x % 4);
 80006f8:	43c0      	mvns	r0, r0
	point = point << (group_bit * 4);
 80006fa:	f000 0303 	and.w	r3, r0, #3
 80006fe:	0098      	lsls	r0, r3, #2
 8000700:	230f      	movs	r3, #15
 8000702:	0189      	lsls	r1, r1, #6
 8000704:	4083      	lsls	r3, r0
 8000706:	b29b      	uxth	r3, r3
 8000708:	4806      	ldr	r0, [pc, #24]	; (8000724 <OLED_DrawPoint+0x34>)

	if (!mode) {
		point = ~point;
		gram[y][group] &= point;
 800070a:	4421      	add	r1, r4
	if (!mode) {
 800070c:	b932      	cbnz	r2, 800071c <OLED_DrawPoint+0x2c>
		gram[y][group] &= point;
 800070e:	f830 2011 	ldrh.w	r2, [r0, r1, lsl #1]
 8000712:	ea22 0303 	bic.w	r3, r2, r3
	} else {
		gram[y][group] |= point;
 8000716:	f820 3011 	strh.w	r3, [r0, r1, lsl #1]
 800071a:	bd10      	pop	{r4, pc}
 800071c:	f830 2011 	ldrh.w	r2, [r0, r1, lsl #1]
 8000720:	4313      	orrs	r3, r2
 8000722:	e7f8      	b.n	8000716 <OLED_DrawPoint+0x26>
 8000724:	200000f0 	.word	0x200000f0

08000728 <OLED_FillBlock>:
void OLED_FillBlock(unsigned char a, unsigned char b,unsigned char c, unsigned char d,unsigned char Data){
 8000728:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800072c:	4607      	mov	r7, r0
 800072e:	4688      	mov	r8, r1
 8000730:	461e      	mov	r6, r3
	for(int y=c;y<d;y++)
 8000732:	4614      	mov	r4, r2
void OLED_FillBlock(unsigned char a, unsigned char b,unsigned char c, unsigned char d,unsigned char Data){
 8000734:	f89d 9020 	ldrb.w	r9, [sp, #32]
	for(int y=c;y<d;y++)
 8000738:	42b4      	cmp	r4, r6
 800073a:	db01      	blt.n	8000740 <OLED_FillBlock+0x18>
}
 800073c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		for(int x=a;x<b;x++)
 8000740:	463d      	mov	r5, r7
			OLED_DrawPoint(x,y,Data);
 8000742:	fa5f fa84 	uxtb.w	sl, r4
		for(int x=a;x<b;x++)
 8000746:	4545      	cmp	r5, r8
 8000748:	db01      	blt.n	800074e <OLED_FillBlock+0x26>
	for(int y=c;y<d;y++)
 800074a:	3401      	adds	r4, #1
 800074c:	e7f4      	b.n	8000738 <OLED_FillBlock+0x10>
			OLED_DrawPoint(x,y,Data);
 800074e:	b2e8      	uxtb	r0, r5
 8000750:	464a      	mov	r2, r9
 8000752:	4651      	mov	r1, sl
 8000754:	f7ff ffcc 	bl	80006f0 <OLED_DrawPoint>
		for(int x=a;x<b;x++)
 8000758:	3501      	adds	r5, #1
 800075a:	e7f4      	b.n	8000746 <OLED_FillBlock+0x1e>

0800075c <OLED_FillRam>:
void OLED_FillRam(unsigned char Data) {
 800075c:	b507      	push	{r0, r1, r2, lr}
	OLED_FillBlock(0x00, Max_Column, 0x00, Max_Row,Data);
 800075e:	233f      	movs	r3, #63	; 0x3f
 8000760:	2200      	movs	r2, #0
 8000762:	9000      	str	r0, [sp, #0]
 8000764:	4619      	mov	r1, r3
 8000766:	4610      	mov	r0, r2
 8000768:	f7ff ffde 	bl	8000728 <OLED_FillBlock>
}
 800076c:	b003      	add	sp, #12
 800076e:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08000774 <OLED_RefreshGram>:
	point = (gram[y][group] & (point << (group_bit * 4))) >> (group_bit * 4);
	point = point & 0x00ff;
	return point;

}
void OLED_RefreshGram() {
 8000774:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	Write_Command(0x15);			// Set Column Address
 8000776:	2100      	movs	r1, #0
 8000778:	2015      	movs	r0, #21
 800077a:	f7ff ff91 	bl	80006a0 <write>
	Write_Data(a);				//   Default => 0x00
 800077e:	2101      	movs	r1, #1
 8000780:	201c      	movs	r0, #28
 8000782:	f7ff ff8d 	bl	80006a0 <write>
	Write_Data(b);				//   Default => 0x77
 8000786:	2101      	movs	r1, #1
 8000788:	205b      	movs	r0, #91	; 0x5b
 800078a:	f7ff ff89 	bl	80006a0 <write>
	Write_Command(0x75);			// Set Row Address
 800078e:	2100      	movs	r1, #0
 8000790:	2075      	movs	r0, #117	; 0x75
 8000792:	f7ff ff85 	bl	80006a0 <write>
	Write_Data(a);				//   Default => 0x00
 8000796:	2101      	movs	r1, #1
 8000798:	2000      	movs	r0, #0
 800079a:	f7ff ff81 	bl	80006a0 <write>
	Write_Data(b);				//   Default => 0x7F
 800079e:	2101      	movs	r1, #1
 80007a0:	203f      	movs	r0, #63	; 0x3f
 80007a2:	f7ff ff7d 	bl	80006a0 <write>
	Write_Command(0x5C);			// Enable MCU to Write into RAM
 80007a6:	2100      	movs	r1, #0
 80007a8:	205c      	movs	r0, #92	; 0x5c
 80007aa:	f7ff ff79 	bl	80006a0 <write>
 80007ae:	2500      	movs	r5, #0
 80007b0:	4f0a      	ldr	r7, [pc, #40]	; (80007dc <OLED_RefreshGram+0x68>)
void OLED_RefreshGram() {
 80007b2:	2400      	movs	r4, #0
 80007b4:	197e      	adds	r6, r7, r5
	Set_Column_Address(Shift + a, Shift + b);
	Set_Row_Address(c, d);
	Set_Write_RAM();
	for (int y = 0; y < (d - c+1); y++) {
		for (int x = 0; x < (b - a+1); x++) {
			Write_Data((gram[y][x] & 0xff00) >> 8); //draw 3,4 point
 80007b6:	f836 0014 	ldrh.w	r0, [r6, r4, lsl #1]
 80007ba:	2101      	movs	r1, #1
 80007bc:	0a00      	lsrs	r0, r0, #8
 80007be:	f7ff ff6f 	bl	80006a0 <write>
			Write_Data(gram[y][x] & 0x00ff); 		//draw 1,2 point
 80007c2:	f816 0014 	ldrb.w	r0, [r6, r4, lsl #1]
 80007c6:	2101      	movs	r1, #1
		for (int x = 0; x < (b - a+1); x++) {
 80007c8:	3401      	adds	r4, #1
			Write_Data(gram[y][x] & 0x00ff); 		//draw 1,2 point
 80007ca:	f7ff ff69 	bl	80006a0 <write>
		for (int x = 0; x < (b - a+1); x++) {
 80007ce:	2c40      	cmp	r4, #64	; 0x40
 80007d0:	d1f1      	bne.n	80007b6 <OLED_RefreshGram+0x42>
 80007d2:	3580      	adds	r5, #128	; 0x80
	for (int y = 0; y < (d - c+1); y++) {
 80007d4:	f5b5 5f00 	cmp.w	r5, #8192	; 0x2000
 80007d8:	d1eb      	bne.n	80007b2 <OLED_RefreshGram+0x3e>
 80007da:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80007dc:	200000f0 	.word	0x200000f0

080007e0 <OLED_Clear>:
{
 80007e0:	b508      	push	{r3, lr}
	OLED_FillRam(0x00);
 80007e2:	2000      	movs	r0, #0
 80007e4:	f7ff ffba 	bl	800075c <OLED_FillRam>
}
 80007e8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	OLED_RefreshGram();
 80007ec:	f7ff bfc2 	b.w	8000774 <OLED_RefreshGram>

080007f0 <OLED_ShowChar>:
//   chr: 字元
//   f_w:字元寬度像素
//   f_h:字元高度像素
//	 mode: 0x00(滅) 0x01(亮)
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
void OLED_ShowChar(uint8_t x, uint8_t y, uint8_t chr, uint8_t f_w, uint8_t f_h,uint8_t mode){
 80007f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80007f4:	b085      	sub	sp, #20
 80007f6:	f89d 6038 	ldrb.w	r6, [sp, #56]	; 0x38
 80007fa:	9300      	str	r3, [sp, #0]
	uint8_t temp,t,t1;
	uint8_t y0=y;
	uint8_t csize=(f_h/8+((f_h%8)?1:0))*f_w;//得到自由分辨字符所占的字节数
 80007fc:	f016 0307 	ands.w	r3, r6, #7
 8000800:	bf18      	it	ne
 8000802:	2301      	movne	r3, #1
void OLED_ShowChar(uint8_t x, uint8_t y, uint8_t chr, uint8_t f_w, uint8_t f_h,uint8_t mode){
 8000804:	4688      	mov	r8, r1
	uint8_t csize=(f_h/8+((f_h%8)?1:0))*f_w;//得到自由分辨字符所占的字节数
 8000806:	9900      	ldr	r1, [sp, #0]
 8000808:	eb03 03d6 	add.w	r3, r3, r6, lsr #3
 800080c:	434b      	muls	r3, r1
 800080e:	210c      	movs	r1, #12
 8000810:	b2db      	uxtb	r3, r3
 8000812:	9301      	str	r3, [sp, #4]
	chr=chr-' ';//得到偏移后的值
 8000814:	3a20      	subs	r2, #32
 8000816:	4b22      	ldr	r3, [pc, #136]	; (80008a0 <OLED_ShowChar+0xb0>)
 8000818:	b2d2      	uxtb	r2, r2
 800081a:	fb01 3302 	mla	r3, r1, r2, r3
 800081e:	2106      	movs	r1, #6
void OLED_ShowChar(uint8_t x, uint8_t y, uint8_t chr, uint8_t f_w, uint8_t f_h,uint8_t mode){
 8000820:	4605      	mov	r5, r0
	for(t=0;t<csize;t++)
 8000822:	4644      	mov	r4, r8
 8000824:	f04f 0a00 	mov.w	sl, #0
 8000828:	9303      	str	r3, [sp, #12]
 800082a:	4b1e      	ldr	r3, [pc, #120]	; (80008a4 <OLED_ShowChar+0xb4>)
void OLED_ShowChar(uint8_t x, uint8_t y, uint8_t chr, uint8_t f_w, uint8_t f_h,uint8_t mode){
 800082c:	f89d b03c 	ldrb.w	fp, [sp, #60]	; 0x3c
 8000830:	fb01 3302 	mla	r3, r1, r2, r3
 8000834:	9302      	str	r3, [sp, #8]
	for(t=0;t<csize;t++)
 8000836:	9b01      	ldr	r3, [sp, #4]
 8000838:	fa5f f28a 	uxtb.w	r2, sl
 800083c:	4293      	cmp	r3, r2
 800083e:	d802      	bhi.n	8000846 <OLED_ShowChar+0x56>
				x++;
				break;
			}
		}
	}
}
 8000840:	b005      	add	sp, #20
 8000842:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if(f_w==6&&f_h==8)temp=asc2_0608[chr][t];		//调用0608ascii字体
 8000846:	9b00      	ldr	r3, [sp, #0]
 8000848:	2b06      	cmp	r3, #6
 800084a:	d1f9      	bne.n	8000840 <OLED_ShowChar+0x50>
 800084c:	2e08      	cmp	r6, #8
 800084e:	d120      	bne.n	8000892 <OLED_ShowChar+0xa2>
 8000850:	9b02      	ldr	r3, [sp, #8]
 8000852:	f104 0908 	add.w	r9, r4, #8
		else if(f_w==6&&f_h==12)temp=asc2_0612[chr][t];	//调用0612ascii字体
 8000856:	f813 700a 	ldrb.w	r7, [r3, sl]
 800085a:	fa5f f989 	uxtb.w	r9, r9
			if(temp&0x80)OLED_DrawPoint(x,y,mode);
 800085e:	063b      	lsls	r3, r7, #24
			else OLED_DrawPoint(x,y,!mode);
 8000860:	bf58      	it	pl
 8000862:	fabb f28b 	clzpl	r2, fp
 8000866:	4621      	mov	r1, r4
			y++;
 8000868:	f104 0401 	add.w	r4, r4, #1
			if(temp&0x80)OLED_DrawPoint(x,y,mode);
 800086c:	bf4c      	ite	mi
 800086e:	465a      	movmi	r2, fp
			else OLED_DrawPoint(x,y,!mode);
 8000870:	0952      	lsrpl	r2, r2, #5
 8000872:	4628      	mov	r0, r5
			y++;
 8000874:	b2e4      	uxtb	r4, r4
			else OLED_DrawPoint(x,y,!mode);
 8000876:	f7ff ff3b 	bl	80006f0 <OLED_DrawPoint>
			if((y-y0)==f_h)
 800087a:	eba4 0208 	sub.w	r2, r4, r8
			temp<<=1;
 800087e:	007f      	lsls	r7, r7, #1
			if((y-y0)==f_h)
 8000880:	42b2      	cmp	r2, r6
			temp<<=1;
 8000882:	b2ff      	uxtb	r7, r7
			if((y-y0)==f_h)
 8000884:	d109      	bne.n	800089a <OLED_ShowChar+0xaa>
				y=y0;
 8000886:	4644      	mov	r4, r8
				x++;
 8000888:	3501      	adds	r5, #1
 800088a:	b2ed      	uxtb	r5, r5
 800088c:	f10a 0a01 	add.w	sl, sl, #1
 8000890:	e7d1      	b.n	8000836 <OLED_ShowChar+0x46>
		else if(f_w==6&&f_h==12)temp=asc2_0612[chr][t];	//调用0612ascii字体
 8000892:	2e0c      	cmp	r6, #12
 8000894:	d1d4      	bne.n	8000840 <OLED_ShowChar+0x50>
 8000896:	9b03      	ldr	r3, [sp, #12]
 8000898:	e7db      	b.n	8000852 <OLED_ShowChar+0x62>
		for(t1=0;t1<8;t1++)
 800089a:	45a1      	cmp	r9, r4
 800089c:	d1df      	bne.n	800085e <OLED_ShowChar+0x6e>
 800089e:	e7f5      	b.n	800088c <OLED_ShowChar+0x9c>
 80008a0:	08003d50 	.word	0x08003d50
 80008a4:	08003b16 	.word	0x08003b16

080008a8 <OLED_ShowPicture>:
//   p_w:圖片寬度像素
//   p_h:圖片高度像素
//	 mode: 0x00(滅) 0x01(亮)
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
void OLED_ShowPicture(uint8_t x,uint8_t y,const uint8_t *p,uint8_t p_w,uint8_t p_h)
{
 80008a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80008ac:	468a      	mov	sl, r1
 80008ae:	4698      	mov	r8, r3
 80008b0:	b087      	sub	sp, #28
 80008b2:	f89d 1040 	ldrb.w	r1, [sp, #64]	; 0x40
	uint8_t temp,i,col,row;
	uint8_t y0=y;
	uint8_t width=p_w;
	if(x+p_w>OLED_PIXEL_WIDTH)width=OLED_PIXEL_WIDTH-p_w;//实际显示宽度
 80008b6:	18c3      	adds	r3, r0, r3
 80008b8:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 80008bc:	bfc8      	it	gt
 80008be:	f1c8 0800 	rsbgt	r8, r8, #0
	uint8_t high=p_h;
	if(y+p_h>OLED_PIXEL_HEIGHT)high=OLED_PIXEL_HEIGHT-p_h;//实际显示高度
 80008c2:	eb01 030a 	add.w	r3, r1, sl
	if(x+p_w>OLED_PIXEL_WIDTH)width=OLED_PIXEL_WIDTH-p_w;//实际显示宽度
 80008c6:	bfc8      	it	gt
 80008c8:	fa5f f888 	uxtbgt.w	r8, r8
	if(y+p_h>OLED_PIXEL_HEIGHT)high=OLED_PIXEL_HEIGHT-p_h;//实际显示高度
 80008cc:	2b40      	cmp	r3, #64	; 0x40
	uint8_t high=p_h;
 80008ce:	bfd2      	itee	le
 80008d0:	460d      	movle	r5, r1
	if(y+p_h>OLED_PIXEL_HEIGHT)high=OLED_PIXEL_HEIGHT-p_h;//实际显示高度
 80008d2:	f1c1 0540 	rsbgt	r5, r1, #64	; 0x40
 80008d6:	b2ed      	uxtbgt	r5, r5
	uint8_t exp_col_bytes=(p_h/8+((p_h%8)?1:0));//显示一列的字节数
	uint8_t act_col_bytes=(high/8+((high%8)?1:0));//实际显示一列的字节数
 80008d8:	f015 0307 	ands.w	r3, r5, #7
 80008dc:	bf18      	it	ne
 80008de:	2301      	movne	r3, #1
 80008e0:	eb03 03d5 	add.w	r3, r3, r5, lsr #3
 80008e4:	9301      	str	r3, [sp, #4]
	uint8_t exp_col_bytes=(p_h/8+((p_h%8)?1:0));//显示一列的字节数
 80008e6:	f011 0307 	ands.w	r3, r1, #7
 80008ea:	bf18      	it	ne
 80008ec:	2301      	movne	r3, #1
 80008ee:	eb03 03d1 	add.w	r3, r3, r1, lsr #3
 80008f2:	9303      	str	r3, [sp, #12]
{
 80008f4:	4606      	mov	r6, r0
 80008f6:	4617      	mov	r7, r2

	for(row=0;row<width;row++)//列++
 80008f8:	4654      	mov	r4, sl
 80008fa:	2300      	movs	r3, #0
 80008fc:	b2da      	uxtb	r2, r3
 80008fe:	4590      	cmp	r8, r2
 8000900:	d92e      	bls.n	8000960 <OLED_ShowPicture+0xb8>
 8000902:	9a01      	ldr	r2, [sp, #4]
 8000904:	46bb      	mov	fp, r7
 8000906:	443a      	add	r2, r7
 8000908:	9204      	str	r2, [sp, #16]
 800090a:	e01e      	b.n	800094a <OLED_ShowPicture+0xa2>
 800090c:	f104 0208 	add.w	r2, r4, #8
 8000910:	b2d2      	uxtb	r2, r2
	{
		for(col=0;col<act_col_bytes;col++)//显示一列
		{
			temp = p[col+row*exp_col_bytes];
 8000912:	f81b 9b01 	ldrb.w	r9, [fp], #1
 8000916:	9202      	str	r2, [sp, #8]
			for(i=0;i<8;i++)
			{
				if(temp&0x80)OLED_DrawPoint(x,y,1);
 8000918:	f019 0f80 	tst.w	r9, #128	; 0x80
				else OLED_DrawPoint(x,y,0);
 800091c:	4621      	mov	r1, r4
				temp<<=1;
				y++;
 800091e:	f104 0401 	add.w	r4, r4, #1
				if(temp&0x80)OLED_DrawPoint(x,y,1);
 8000922:	bf14      	ite	ne
 8000924:	2201      	movne	r2, #1
				else OLED_DrawPoint(x,y,0);
 8000926:	2200      	moveq	r2, #0
 8000928:	4630      	mov	r0, r6
				y++;
 800092a:	b2e4      	uxtb	r4, r4
 800092c:	9305      	str	r3, [sp, #20]
				else OLED_DrawPoint(x,y,0);
 800092e:	f7ff fedf 	bl	80006f0 <OLED_DrawPoint>
				if((y-y0)==high)
 8000932:	eba4 020a 	sub.w	r2, r4, sl
				temp<<=1;
 8000936:	ea4f 0949 	mov.w	r9, r9, lsl #1
				if((y-y0)==high)
 800093a:	42aa      	cmp	r2, r5
				else OLED_DrawPoint(x,y,0);
 800093c:	9b05      	ldr	r3, [sp, #20]
				temp<<=1;
 800093e:	fa5f f989 	uxtb.w	r9, r9
				if((y-y0)==high)
 8000942:	d109      	bne.n	8000958 <OLED_ShowPicture+0xb0>
				{
					y=y0;
 8000944:	4654      	mov	r4, sl
					x++;
 8000946:	3601      	adds	r6, #1
 8000948:	b2f6      	uxtb	r6, r6
		for(col=0;col<act_col_bytes;col++)//显示一列
 800094a:	9a04      	ldr	r2, [sp, #16]
 800094c:	4593      	cmp	fp, r2
 800094e:	d1dd      	bne.n	800090c <OLED_ShowPicture+0x64>
 8000950:	9a03      	ldr	r2, [sp, #12]
 8000952:	3301      	adds	r3, #1
 8000954:	4417      	add	r7, r2
 8000956:	e7d1      	b.n	80008fc <OLED_ShowPicture+0x54>
			for(i=0;i<8;i++)
 8000958:	9a02      	ldr	r2, [sp, #8]
 800095a:	4294      	cmp	r4, r2
 800095c:	d1dc      	bne.n	8000918 <OLED_ShowPicture+0x70>
 800095e:	e7f4      	b.n	800094a <OLED_ShowPicture+0xa2>
					break;
				}
			}
		}
	}
}
 8000960:	b007      	add	sp, #28
 8000962:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

08000968 <OLED_Init>:
//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//  OLED Initialization
//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
void OLED_Init() {
 8000968:	b573      	push	{r0, r1, r4, r5, r6, lr}
	uint8_t dummy = 0x0;
 800096a:	2400      	movs	r4, #0


	//LCD_RST_SetLow();
	HAL_GPIO_WritePin(OLED_RST_GPIO_Port,OLED_RST_Pin,RESET);
 800096c:	4e7f      	ldr	r6, [pc, #508]	; (8000b6c <OLED_Init+0x204>)
 800096e:	4622      	mov	r2, r4
	uint8_t dummy = 0x0;
 8000970:	ad02      	add	r5, sp, #8
	HAL_GPIO_WritePin(OLED_RST_GPIO_Port,OLED_RST_Pin,RESET);
 8000972:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8000976:	4630      	mov	r0, r6
	uint8_t dummy = 0x0;
 8000978:	f805 4d01 	strb.w	r4, [r5, #-1]!
	HAL_GPIO_WritePin(OLED_RST_GPIO_Port,OLED_RST_Pin,RESET);
 800097c:	f000 fb0e 	bl	8000f9c <HAL_GPIO_WritePin>
	HAL_Delay(500);
 8000980:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8000984:	f000 f99e 	bl	8000cc4 <HAL_Delay>
	HAL_GPIO_WritePin(OLED_RST_GPIO_Port,OLED_RST_Pin,SET);
 8000988:	4630      	mov	r0, r6
 800098a:	2201      	movs	r2, #1
 800098c:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8000990:	f000 fb04 	bl	8000f9c <HAL_GPIO_WritePin>
	HAL_SPI_Transmit(&hspi2, &dummy, 1, 1000);
 8000994:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8000998:	2201      	movs	r2, #1
 800099a:	4629      	mov	r1, r5
 800099c:	4874      	ldr	r0, [pc, #464]	; (8000b70 <OLED_Init+0x208>)
 800099e:	f000 fdd0 	bl	8001542 <HAL_SPI_Transmit>
	Write_Command(0xFD);			// Set Command Lock
 80009a2:	4621      	mov	r1, r4
 80009a4:	20fd      	movs	r0, #253	; 0xfd
 80009a6:	f7ff fe7b 	bl	80006a0 <write>
	Write_Data(0x12 | d);			//   Default => 0x12
 80009aa:	2101      	movs	r1, #1
 80009ac:	2012      	movs	r0, #18
 80009ae:	f7ff fe77 	bl	80006a0 <write>
	Write_Command(0xAE | d);			// Set Display On/Off
 80009b2:	4621      	mov	r1, r4
 80009b4:	20ae      	movs	r0, #174	; 0xae
 80009b6:	f7ff fe73 	bl	80006a0 <write>
	Write_Command(0xB3);	// Set Display Clock Divider / Oscillator Frequency
 80009ba:	4621      	mov	r1, r4
 80009bc:	20b3      	movs	r0, #179	; 0xb3
 80009be:	f7ff fe6f 	bl	80006a0 <write>
	Write_Data(d);				//   Default => 0xD0
 80009c2:	2101      	movs	r1, #1
 80009c4:	2091      	movs	r0, #145	; 0x91
 80009c6:	f7ff fe6b 	bl	80006a0 <write>
	Write_Command(0xCA);			// Set Multiplex Ratio
 80009ca:	4621      	mov	r1, r4
 80009cc:	20ca      	movs	r0, #202	; 0xca
 80009ce:	f7ff fe67 	bl	80006a0 <write>
	Write_Data(d);				//   Default => 0x7F (1/128 Duty)
 80009d2:	2101      	movs	r1, #1
 80009d4:	203f      	movs	r0, #63	; 0x3f
 80009d6:	f7ff fe63 	bl	80006a0 <write>
	Write_Command(0xA2);			// Set Vertical Scroll by Row
 80009da:	4621      	mov	r1, r4
 80009dc:	20a2      	movs	r0, #162	; 0xa2
 80009de:	f7ff fe5f 	bl	80006a0 <write>
	Write_Data(d);				//   Default => 0x00
 80009e2:	4620      	mov	r0, r4
 80009e4:	2101      	movs	r1, #1
 80009e6:	f7ff fe5b 	bl	80006a0 <write>
	Write_Command(0xA1);			// Set Vertical Scroll by RAM
 80009ea:	4621      	mov	r1, r4
 80009ec:	20a1      	movs	r0, #161	; 0xa1
 80009ee:	f7ff fe57 	bl	80006a0 <write>
	Write_Data(d);				//   Default => 0x00
 80009f2:	4620      	mov	r0, r4
 80009f4:	2101      	movs	r1, #1
 80009f6:	f7ff fe53 	bl	80006a0 <write>
	Write_Command(0xA0);			// Set Re-Map / Dual COM Line Mode
 80009fa:	4621      	mov	r1, r4
 80009fc:	20a0      	movs	r0, #160	; 0xa0
 80009fe:	f7ff fe4f 	bl	80006a0 <write>
	Write_Data(d);				//   Default => 0x40
 8000a02:	2101      	movs	r1, #1
 8000a04:	2014      	movs	r0, #20
 8000a06:	f7ff fe4b 	bl	80006a0 <write>
	Write_Data(0x11);			//   Default => 0x01 (Disable Dual COM Mode)
 8000a0a:	2101      	movs	r1, #1
 8000a0c:	2011      	movs	r0, #17
 8000a0e:	f7ff fe47 	bl	80006a0 <write>
	Write_Command(0xB5);			// General Purpose IO
 8000a12:	4621      	mov	r1, r4
 8000a14:	20b5      	movs	r0, #181	; 0xb5
 8000a16:	f7ff fe43 	bl	80006a0 <write>
	Write_Data(d);			//   Default => 0x0A (GPIO Pins output Low Level.)
 8000a1a:	4620      	mov	r0, r4
 8000a1c:	2101      	movs	r1, #1
 8000a1e:	f7ff fe3f 	bl	80006a0 <write>
	Write_Command(0xAB);			// Function Selection
 8000a22:	4621      	mov	r1, r4
 8000a24:	20ab      	movs	r0, #171	; 0xab
 8000a26:	f7ff fe3b 	bl	80006a0 <write>
	Write_Data(d);				//   Default => 0x01
 8000a2a:	2101      	movs	r1, #1
 8000a2c:	4608      	mov	r0, r1
 8000a2e:	f7ff fe37 	bl	80006a0 <write>
	Write_Command(0xB4);			// Display Enhancement
 8000a32:	4621      	mov	r1, r4
 8000a34:	20b4      	movs	r0, #180	; 0xb4
 8000a36:	f7ff fe33 	bl	80006a0 <write>
	Write_Data(0xA0 | a);			//   Default => 0xA2
 8000a3a:	2101      	movs	r1, #1
 8000a3c:	20a0      	movs	r0, #160	; 0xa0
 8000a3e:	f7ff fe2f 	bl	80006a0 <write>
	Write_Data(0x05 | b);			//   Default => 0xB5
 8000a42:	2101      	movs	r1, #1
 8000a44:	20fd      	movs	r0, #253	; 0xfd
 8000a46:	f7ff fe2b 	bl	80006a0 <write>
	Write_Command(0xC1);			// Set Contrast Current
 8000a4a:	4621      	mov	r1, r4
 8000a4c:	20c1      	movs	r0, #193	; 0xc1
 8000a4e:	f7ff fe27 	bl	80006a0 <write>
	Write_Data(d);				//   Default => 0x7F
 8000a52:	2101      	movs	r1, #1
 8000a54:	209f      	movs	r0, #159	; 0x9f
 8000a56:	f7ff fe23 	bl	80006a0 <write>
	Write_Command(0xC7);			// Master Contrast Current Control
 8000a5a:	4621      	mov	r1, r4
 8000a5c:	20c7      	movs	r0, #199	; 0xc7
 8000a5e:	f7ff fe1f 	bl	80006a0 <write>
	Write_Data(d);				//   Default => 0x0f (Maximum)
 8000a62:	2101      	movs	r1, #1
 8000a64:	200f      	movs	r0, #15
 8000a66:	f7ff fe1b 	bl	80006a0 <write>
	Write_Command(0xB8);			// Set Gray Scale Table
 8000a6a:	4621      	mov	r1, r4
 8000a6c:	20b8      	movs	r0, #184	; 0xb8
 8000a6e:	f7ff fe17 	bl	80006a0 <write>
	Write_Data(0x0C);			//   Gray Scale Level 1
 8000a72:	2101      	movs	r1, #1
 8000a74:	200c      	movs	r0, #12
 8000a76:	f7ff fe13 	bl	80006a0 <write>
	Write_Data(0x18);			//   Gray Scale Level 2
 8000a7a:	2101      	movs	r1, #1
 8000a7c:	2018      	movs	r0, #24
 8000a7e:	f7ff fe0f 	bl	80006a0 <write>
	Write_Data(0x24);			//   Gray Scale Level 3
 8000a82:	2101      	movs	r1, #1
 8000a84:	2024      	movs	r0, #36	; 0x24
 8000a86:	f7ff fe0b 	bl	80006a0 <write>
	Write_Data(0x30);			//   Gray Scale Level 4
 8000a8a:	2101      	movs	r1, #1
 8000a8c:	2030      	movs	r0, #48	; 0x30
 8000a8e:	f7ff fe07 	bl	80006a0 <write>
	Write_Data(0x3C);			//   Gray Scale Level 5
 8000a92:	2101      	movs	r1, #1
 8000a94:	203c      	movs	r0, #60	; 0x3c
 8000a96:	f7ff fe03 	bl	80006a0 <write>
	Write_Data(0x48);			//   Gray Scale Level 6
 8000a9a:	2101      	movs	r1, #1
 8000a9c:	2048      	movs	r0, #72	; 0x48
 8000a9e:	f7ff fdff 	bl	80006a0 <write>
	Write_Data(0x54);			//   Gray Scale Level 7
 8000aa2:	2101      	movs	r1, #1
 8000aa4:	2054      	movs	r0, #84	; 0x54
 8000aa6:	f7ff fdfb 	bl	80006a0 <write>
	Write_Data(0x60);			//   Gray Scale Level 8
 8000aaa:	2101      	movs	r1, #1
 8000aac:	2060      	movs	r0, #96	; 0x60
 8000aae:	f7ff fdf7 	bl	80006a0 <write>
	Write_Data(0x6C);			//   Gray Scale Level 9
 8000ab2:	2101      	movs	r1, #1
 8000ab4:	206c      	movs	r0, #108	; 0x6c
 8000ab6:	f7ff fdf3 	bl	80006a0 <write>
	Write_Data(0x78);			//   Gray Scale Level 10
 8000aba:	2101      	movs	r1, #1
 8000abc:	2078      	movs	r0, #120	; 0x78
 8000abe:	f7ff fdef 	bl	80006a0 <write>
	Write_Data(0x84);			//   Gray Scale Level 11
 8000ac2:	2101      	movs	r1, #1
 8000ac4:	2084      	movs	r0, #132	; 0x84
 8000ac6:	f7ff fdeb 	bl	80006a0 <write>
	Write_Data(0x90);			//   Gray Scale Level 12
 8000aca:	2101      	movs	r1, #1
 8000acc:	2090      	movs	r0, #144	; 0x90
 8000ace:	f7ff fde7 	bl	80006a0 <write>
	Write_Data(0x9C);			//   Gray Scale Level 13
 8000ad2:	2101      	movs	r1, #1
 8000ad4:	209c      	movs	r0, #156	; 0x9c
 8000ad6:	f7ff fde3 	bl	80006a0 <write>
	Write_Data(0xA8);			//   Gray Scale Level 14
 8000ada:	2101      	movs	r1, #1
 8000adc:	20a8      	movs	r0, #168	; 0xa8
 8000ade:	f7ff fddf 	bl	80006a0 <write>
	Write_Data(0xB4);			//   Gray Scale Level 15
 8000ae2:	2101      	movs	r1, #1
 8000ae4:	20b4      	movs	r0, #180	; 0xb4
 8000ae6:	f7ff fddb 	bl	80006a0 <write>
	Write_Command(0x00);			// Enable Gray Scale Table
 8000aea:	4621      	mov	r1, r4
 8000aec:	4620      	mov	r0, r4
 8000aee:	f7ff fdd7 	bl	80006a0 <write>
	Write_Command(0xB1);// Phase 1 (Reset) & Phase 2 (Pre-Charge) Period Adjustment
 8000af2:	4621      	mov	r1, r4
 8000af4:	20b1      	movs	r0, #177	; 0xb1
 8000af6:	f7ff fdd3 	bl	80006a0 <write>
	Write_Data(d);//   Default => 0x74 (7 Display Clocks [Phase 2] / 9 Display Clocks [Phase 1])
 8000afa:	2101      	movs	r1, #1
 8000afc:	20e2      	movs	r0, #226	; 0xe2
 8000afe:	f7ff fdcf 	bl	80006a0 <write>
	Write_Command(0xD1);			// Display Enhancement
 8000b02:	4621      	mov	r1, r4
 8000b04:	20d1      	movs	r0, #209	; 0xd1
 8000b06:	f7ff fdcb 	bl	80006a0 <write>
	Write_Data(0x82 | d);			//   Default => 0xA2
 8000b0a:	2101      	movs	r1, #1
 8000b0c:	20a2      	movs	r0, #162	; 0xa2
 8000b0e:	f7ff fdc7 	bl	80006a0 <write>
	Write_Data(0x20);
 8000b12:	2101      	movs	r1, #1
 8000b14:	2020      	movs	r0, #32
 8000b16:	f7ff fdc3 	bl	80006a0 <write>
	Write_Command(0xBB);			// Set Pre-Charge Voltage Level
 8000b1a:	4621      	mov	r1, r4
 8000b1c:	20bb      	movs	r0, #187	; 0xbb
 8000b1e:	f7ff fdbf 	bl	80006a0 <write>
	Write_Data(d);				//   Default => 0x17 (0.50*VCC)
 8000b22:	2101      	movs	r1, #1
 8000b24:	201f      	movs	r0, #31
 8000b26:	f7ff fdbb 	bl	80006a0 <write>
	Write_Command(0xB6);			// Set Second Pre-Charge Period
 8000b2a:	4621      	mov	r1, r4
 8000b2c:	20b6      	movs	r0, #182	; 0xb6
 8000b2e:	f7ff fdb7 	bl	80006a0 <write>
	Write_Data(d);				//   Default => 0x08 (8 Display Clocks)
 8000b32:	2101      	movs	r1, #1
 8000b34:	2008      	movs	r0, #8
 8000b36:	f7ff fdb3 	bl	80006a0 <write>
	Write_Command(0xBE);			// Set COM Deselect Voltage Level
 8000b3a:	4621      	mov	r1, r4
 8000b3c:	20be      	movs	r0, #190	; 0xbe
 8000b3e:	f7ff fdaf 	bl	80006a0 <write>
	Write_Data(d);				//   Default => 0x04 (0.80*VCC)
 8000b42:	2101      	movs	r1, #1
 8000b44:	2007      	movs	r0, #7
 8000b46:	f7ff fdab 	bl	80006a0 <write>
	Write_Command(0xA4 | d);			// Set Display Mode
 8000b4a:	4621      	mov	r1, r4
 8000b4c:	20a6      	movs	r0, #166	; 0xa6
 8000b4e:	f7ff fda7 	bl	80006a0 <write>
	Write_Command(0xA8 | a);
 8000b52:	4621      	mov	r1, r4
 8000b54:	20a9      	movs	r0, #169	; 0xa9
 8000b56:	f7ff fda3 	bl	80006a0 <write>
	Set_Precharge_Period(0x08);		// Set Second Pre-Charge Period as 8 Clocks
	Set_VCOMH(0x07);	// Set Common Pins Deselect Voltage Level as 0.86*VCC
	Set_Display_Mode(0x02);			// Normal Display Mode (0x00/0x01/0x02/0x03)
	Set_Partial_Display(0x01, 0x00, 0x00);	// Disable Partial Display

	OLED_Clear();				// Clear Screen
 8000b5a:	f7ff fe41 	bl	80007e0 <OLED_Clear>
	Write_Command(0xAE | d);			// Set Display On/Off
 8000b5e:	4621      	mov	r1, r4
 8000b60:	20af      	movs	r0, #175	; 0xaf
 8000b62:	f7ff fd9d 	bl	80006a0 <write>

	Set_Display_On_Off(0x01);		// Display On (0x00/0x01)

}
 8000b66:	b002      	add	sp, #8
 8000b68:	bd70      	pop	{r4, r5, r6, pc}
 8000b6a:	bf00      	nop
 8000b6c:	40010c00 	.word	0x40010c00
 8000b70:	20003e6c 	.word	0x20003e6c

08000b74 <RotaryEcncorder_Init>:
	}
	return button_state;

}

void RotaryEcncorder_Init() {
 8000b74:	b510      	push	{r4, lr}
	HAL_TIM_Encoder_Start(&htim2, TIM_CHANNEL_ALL);
 8000b76:	4c05      	ldr	r4, [pc, #20]	; (8000b8c <RotaryEcncorder_Init+0x18>)
 8000b78:	2118      	movs	r1, #24
 8000b7a:	4620      	mov	r0, r4
 8000b7c:	f000 fdc5 	bl	800170a <HAL_TIM_Encoder_Start>
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
//   設定旋轉編碼器數值
//   count:設定值範圍-32767~32767
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
int32_t RotaryEcncorder_SetCount(int32_t count) {
	__HAL_TIM_SET_COUNTER(&htim2,32767+count);
 8000b80:	f647 72ff 	movw	r2, #32767	; 0x7fff
 8000b84:	6823      	ldr	r3, [r4, #0]
 8000b86:	625a      	str	r2, [r3, #36]	; 0x24
 8000b88:	bd10      	pop	{r4, pc}
 8000b8a:	bf00      	nop
 8000b8c:	20003ec8 	.word	0x20003ec8

08000b90 <RotaryEcncorder_SetCount>:
 8000b90:	4b03      	ldr	r3, [pc, #12]	; (8000ba0 <RotaryEcncorder_SetCount+0x10>)
 8000b92:	f500 40ff 	add.w	r0, r0, #32640	; 0x7f80
 8000b96:	681b      	ldr	r3, [r3, #0]
 8000b98:	307f      	adds	r0, #127	; 0x7f
 8000b9a:	6258      	str	r0, [r3, #36]	; 0x24
}
 8000b9c:	4770      	bx	lr
 8000b9e:	bf00      	nop
 8000ba0:	20003ec8 	.word	0x20003ec8

08000ba4 <RotaryEcncorder_SetRange>:
	}

	if(min < -32767)min = -32767;
	if(max > 32767)max = 32767;

	range_min = min;
 8000ba4:	4a08      	ldr	r2, [pc, #32]	; (8000bc8 <RotaryEcncorder_SetRange+0x24>)
 8000ba6:	4b09      	ldr	r3, [pc, #36]	; (8000bcc <RotaryEcncorder_SetRange+0x28>)
 8000ba8:	4281      	cmp	r1, r0
 8000baa:	bfb8      	it	lt
 8000bac:	4601      	movlt	r1, r0
 8000bae:	4290      	cmp	r0, r2
 8000bb0:	bfac      	ite	ge
 8000bb2:	6018      	strge	r0, [r3, #0]
 8000bb4:	601a      	strlt	r2, [r3, #0]
	range_max = max;
 8000bb6:	f647 72ff 	movw	r2, #32767	; 0x7fff
 8000bba:	4b05      	ldr	r3, [pc, #20]	; (8000bd0 <RotaryEcncorder_SetRange+0x2c>)
 8000bbc:	4291      	cmp	r1, r2
 8000bbe:	bfd4      	ite	le
 8000bc0:	6019      	strle	r1, [r3, #0]
 8000bc2:	601a      	strgt	r2, [r3, #0]
}
 8000bc4:	4770      	bx	lr
 8000bc6:	bf00      	nop
 8000bc8:	ffff8001 	.word	0xffff8001
 8000bcc:	200020f4 	.word	0x200020f4
 8000bd0:	20000004 	.word	0x20000004

08000bd4 <RotaryEcncorder_GetCount>:

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
//   取得旋轉編碼器計數值
//   返回值範圍0~32767
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
int32_t RotaryEcncorder_GetCount() {
 8000bd4:	b508      	push	{r3, lr}
	int32_t count;

	count = __HAL_TIM_GET_COUNTER(&htim2);  //value: cw:0->65535  or  ccw:0<-65535<-0
 8000bd6:	4b0a      	ldr	r3, [pc, #40]	; (8000c00 <RotaryEcncorder_GetCount+0x2c>)
 8000bd8:	681b      	ldr	r3, [r3, #0]
 8000bda:	6a58      	ldr	r0, [r3, #36]	; 0x24
	count -= 32767; //-32767 ~ 32767
	if(count > range_max)
 8000bdc:	4b09      	ldr	r3, [pc, #36]	; (8000c04 <RotaryEcncorder_GetCount+0x30>)
	count -= 32767; //-32767 ~ 32767
 8000bde:	f5a0 40ff 	sub.w	r0, r0, #32640	; 0x7f80
	if(count > range_max)
 8000be2:	681a      	ldr	r2, [r3, #0]
	count -= 32767; //-32767 ~ 32767
 8000be4:	387f      	subs	r0, #127	; 0x7f
	if(count > range_max)
 8000be6:	4290      	cmp	r0, r2
 8000be8:	dd04      	ble.n	8000bf4 <RotaryEcncorder_GetCount+0x20>
		RotaryEcncorder_SetCount(count);
	}
	else if(count < range_min)
	{
		count = range_min;
		RotaryEcncorder_SetCount(count);
 8000bea:	4610      	mov	r0, r2
 8000bec:	f7ff ffd0 	bl	8000b90 <RotaryEcncorder_SetCount>
 8000bf0:	4610      	mov	r0, r2
	}
	return count;
 8000bf2:	e003      	b.n	8000bfc <RotaryEcncorder_GetCount+0x28>
	else if(count < range_min)
 8000bf4:	4b04      	ldr	r3, [pc, #16]	; (8000c08 <RotaryEcncorder_GetCount+0x34>)
 8000bf6:	681a      	ldr	r2, [r3, #0]
 8000bf8:	4290      	cmp	r0, r2
 8000bfa:	dbf6      	blt.n	8000bea <RotaryEcncorder_GetCount+0x16>
}
 8000bfc:	bd08      	pop	{r3, pc}
 8000bfe:	bf00      	nop
 8000c00:	20003ec8 	.word	0x20003ec8
 8000c04:	20000004 	.word	0x20000004
 8000c08:	200020f4 	.word	0x200020f4

08000c0c <RotaryEcncorder_GetState>:

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
//   取得旋轉編碼器狀態
//   返回值範圍-32767~32767
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
Rotary_state RotaryEcncorder_GetState() {
 8000c0c:	b508      	push	{r3, lr}
	Rotary_state rstate;
	current_count = RotaryEcncorder_GetCount();  //value range: -32767~32767
 8000c0e:	f7ff ffe1 	bl	8000bd4 <RotaryEcncorder_GetCount>
	if (current_count - last_count > 0) {
 8000c12:	4a07      	ldr	r2, [pc, #28]	; (8000c30 <RotaryEcncorder_GetState+0x24>)
	current_count = RotaryEcncorder_GetCount();  //value range: -32767~32767
 8000c14:	4601      	mov	r1, r0
	if (current_count - last_count > 0) {
 8000c16:	6813      	ldr	r3, [r2, #0]
 8000c18:	1ac3      	subs	r3, r0, r3
 8000c1a:	2b00      	cmp	r3, #0
 8000c1c:	dc03      	bgt.n	8000c26 <RotaryEcncorder_GetState+0x1a>
		rstate = state_clock_wise;
	} else if (current_count - last_count < 0) {
 8000c1e:	d104      	bne.n	8000c2a <RotaryEcncorder_GetState+0x1e>
		rstate = state_counter_clock_wise;
	} else {
		rstate = state_no_changed;
 8000c20:	4618      	mov	r0, r3
	}
	last_count = current_count;
 8000c22:	6011      	str	r1, [r2, #0]
	return rstate;
}
 8000c24:	bd08      	pop	{r3, pc}
		rstate = state_clock_wise;
 8000c26:	2001      	movs	r0, #1
 8000c28:	e7fb      	b.n	8000c22 <RotaryEcncorder_GetState+0x16>
		rstate = state_counter_clock_wise;
 8000c2a:	2002      	movs	r0, #2
 8000c2c:	e7f9      	b.n	8000c22 <RotaryEcncorder_GetState+0x16>
 8000c2e:	bf00      	nop
 8000c30:	200020f0 	.word	0x200020f0

08000c34 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8000c34:	b538      	push	{r3, r4, r5, lr}
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8000c36:	4b0e      	ldr	r3, [pc, #56]	; (8000c70 <HAL_InitTick+0x3c>)
{
 8000c38:	4605      	mov	r5, r0
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8000c3a:	7818      	ldrb	r0, [r3, #0]
 8000c3c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8000c40:	fbb3 f3f0 	udiv	r3, r3, r0
 8000c44:	4a0b      	ldr	r2, [pc, #44]	; (8000c74 <HAL_InitTick+0x40>)
 8000c46:	6810      	ldr	r0, [r2, #0]
 8000c48:	fbb0 f0f3 	udiv	r0, r0, r3
 8000c4c:	f000 f892 	bl	8000d74 <HAL_SYSTICK_Config>
 8000c50:	4604      	mov	r4, r0
 8000c52:	b958      	cbnz	r0, 8000c6c <HAL_InitTick+0x38>
  {
    return HAL_ERROR;
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8000c54:	2d0f      	cmp	r5, #15
 8000c56:	d809      	bhi.n	8000c6c <HAL_InitTick+0x38>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8000c58:	4602      	mov	r2, r0
 8000c5a:	4629      	mov	r1, r5
 8000c5c:	f04f 30ff 	mov.w	r0, #4294967295
 8000c60:	f000 f854 	bl	8000d0c <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 8000c64:	4b04      	ldr	r3, [pc, #16]	; (8000c78 <HAL_InitTick+0x44>)
 8000c66:	4620      	mov	r0, r4
 8000c68:	601d      	str	r5, [r3, #0]
 8000c6a:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 8000c6c:	2001      	movs	r0, #1
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
}
 8000c6e:	bd38      	pop	{r3, r4, r5, pc}
 8000c70:	20000008 	.word	0x20000008
 8000c74:	20000000 	.word	0x20000000
 8000c78:	2000000c 	.word	0x2000000c

08000c7c <HAL_Init>:
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8000c7c:	4a07      	ldr	r2, [pc, #28]	; (8000c9c <HAL_Init+0x20>)
{
 8000c7e:	b508      	push	{r3, lr}
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8000c80:	6813      	ldr	r3, [r2, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8000c82:	2003      	movs	r0, #3
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8000c84:	f043 0310 	orr.w	r3, r3, #16
 8000c88:	6013      	str	r3, [r2, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8000c8a:	f000 f82d 	bl	8000ce8 <HAL_NVIC_SetPriorityGrouping>
  HAL_InitTick(TICK_INT_PRIORITY);
 8000c8e:	2000      	movs	r0, #0
 8000c90:	f7ff ffd0 	bl	8000c34 <HAL_InitTick>
  HAL_MspInit();
 8000c94:	f7ff fc38 	bl	8000508 <HAL_MspInit>
}
 8000c98:	2000      	movs	r0, #0
 8000c9a:	bd08      	pop	{r3, pc}
 8000c9c:	40022000 	.word	0x40022000

08000ca0 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 8000ca0:	4a03      	ldr	r2, [pc, #12]	; (8000cb0 <HAL_IncTick+0x10>)
 8000ca2:	4b04      	ldr	r3, [pc, #16]	; (8000cb4 <HAL_IncTick+0x14>)
 8000ca4:	6811      	ldr	r1, [r2, #0]
 8000ca6:	781b      	ldrb	r3, [r3, #0]
 8000ca8:	440b      	add	r3, r1
 8000caa:	6013      	str	r3, [r2, #0]
 8000cac:	4770      	bx	lr
 8000cae:	bf00      	nop
 8000cb0:	20003f0c 	.word	0x20003f0c
 8000cb4:	20000008 	.word	0x20000008

08000cb8 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8000cb8:	4b01      	ldr	r3, [pc, #4]	; (8000cc0 <HAL_GetTick+0x8>)
 8000cba:	6818      	ldr	r0, [r3, #0]
}
 8000cbc:	4770      	bx	lr
 8000cbe:	bf00      	nop
 8000cc0:	20003f0c 	.word	0x20003f0c

08000cc4 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8000cc4:	b538      	push	{r3, r4, r5, lr}
 8000cc6:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8000cc8:	f7ff fff6 	bl	8000cb8 <HAL_GetTick>
 8000ccc:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 8000cce:	1c63      	adds	r3, r4, #1
  {
    wait += (uint32_t)(uwTickFreq);
 8000cd0:	bf1e      	ittt	ne
 8000cd2:	4b04      	ldrne	r3, [pc, #16]	; (8000ce4 <HAL_Delay+0x20>)
 8000cd4:	781b      	ldrbne	r3, [r3, #0]
 8000cd6:	18e4      	addne	r4, r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
 8000cd8:	f7ff ffee 	bl	8000cb8 <HAL_GetTick>
 8000cdc:	1b40      	subs	r0, r0, r5
 8000cde:	4284      	cmp	r4, r0
 8000ce0:	d8fa      	bhi.n	8000cd8 <HAL_Delay+0x14>
  {
  }
}
 8000ce2:	bd38      	pop	{r3, r4, r5, pc}
 8000ce4:	20000008 	.word	0x20000008

08000ce8 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000ce8:	4a07      	ldr	r2, [pc, #28]	; (8000d08 <HAL_NVIC_SetPriorityGrouping+0x20>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
 8000cea:	0200      	lsls	r0, r0, #8
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000cec:	68d3      	ldr	r3, [r2, #12]
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
 8000cee:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8000cf2:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8000cf6:	041b      	lsls	r3, r3, #16
 8000cf8:	0c1b      	lsrs	r3, r3, #16
 8000cfa:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8000cfe:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  reg_value  =  (reg_value                                   |
 8000d02:	4303      	orrs	r3, r0
  SCB->AIRCR =  reg_value;
 8000d04:	60d3      	str	r3, [r2, #12]
 8000d06:	4770      	bx	lr
 8000d08:	e000ed00 	.word	0xe000ed00

08000d0c <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8000d0c:	4b17      	ldr	r3, [pc, #92]	; (8000d6c <HAL_NVIC_SetPriority+0x60>)
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8000d0e:	b530      	push	{r4, r5, lr}
 8000d10:	68dc      	ldr	r4, [r3, #12]
 8000d12:	f3c4 2402 	ubfx	r4, r4, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000d16:	f1c4 0307 	rsb	r3, r4, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000d1a:	1d25      	adds	r5, r4, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000d1c:	2b04      	cmp	r3, #4
 8000d1e:	bf28      	it	cs
 8000d20:	2304      	movcs	r3, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000d22:	2d06      	cmp	r5, #6

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000d24:	f04f 0501 	mov.w	r5, #1
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000d28:	bf98      	it	ls
 8000d2a:	2400      	movls	r4, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000d2c:	fa05 f303 	lsl.w	r3, r5, r3
 8000d30:	f103 33ff 	add.w	r3, r3, #4294967295
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000d34:	bf88      	it	hi
 8000d36:	3c03      	subhi	r4, #3
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000d38:	4019      	ands	r1, r3
 8000d3a:	40a1      	lsls	r1, r4
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8000d3c:	fa05 f404 	lsl.w	r4, r5, r4
 8000d40:	3c01      	subs	r4, #1
 8000d42:	4022      	ands	r2, r4
  if ((int32_t)(IRQn) < 0)
 8000d44:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000d46:	ea42 0201 	orr.w	r2, r2, r1
 8000d4a:	ea4f 1202 	mov.w	r2, r2, lsl #4
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000d4e:	bfaf      	iteee	ge
 8000d50:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000d54:	4b06      	ldrlt	r3, [pc, #24]	; (8000d70 <HAL_NVIC_SetPriority+0x64>)
 8000d56:	f000 000f 	andlt.w	r0, r0, #15
 8000d5a:	b2d2      	uxtblt	r2, r2
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000d5c:	bfa5      	ittet	ge
 8000d5e:	b2d2      	uxtbge	r2, r2
 8000d60:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000d64:	541a      	strblt	r2, [r3, r0]
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000d66:	f880 2300 	strbge.w	r2, [r0, #768]	; 0x300
 8000d6a:	bd30      	pop	{r4, r5, pc}
 8000d6c:	e000ed00 	.word	0xe000ed00
 8000d70:	e000ed14 	.word	0xe000ed14

08000d74 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8000d74:	3801      	subs	r0, #1
 8000d76:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8000d7a:	d20a      	bcs.n	8000d92 <HAL_SYSTICK_Config+0x1e>
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000d7c:	21f0      	movs	r1, #240	; 0xf0
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8000d7e:	4b06      	ldr	r3, [pc, #24]	; (8000d98 <HAL_SYSTICK_Config+0x24>)
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000d80:	4a06      	ldr	r2, [pc, #24]	; (8000d9c <HAL_SYSTICK_Config+0x28>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8000d82:	6058      	str	r0, [r3, #4]
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000d84:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8000d88:	2000      	movs	r0, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000d8a:	2207      	movs	r2, #7
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8000d8c:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000d8e:	601a      	str	r2, [r3, #0]
 8000d90:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 8000d92:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 8000d94:	4770      	bx	lr
 8000d96:	bf00      	nop
 8000d98:	e000e010 	.word	0xe000e010
 8000d9c:	e000ed00 	.word	0xe000ed00

08000da0 <HAL_SYSTICK_CLKSourceConfig>:
  *             @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source.
  *             @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source.
  * @retval None
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
 8000da0:	4b04      	ldr	r3, [pc, #16]	; (8000db4 <HAL_SYSTICK_CLKSourceConfig+0x14>)
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
 8000da2:	2804      	cmp	r0, #4
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 8000da4:	681a      	ldr	r2, [r3, #0]
 8000da6:	bf0c      	ite	eq
 8000da8:	f042 0204 	orreq.w	r2, r2, #4
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
 8000dac:	f022 0204 	bicne.w	r2, r2, #4
 8000db0:	601a      	str	r2, [r3, #0]
 8000db2:	4770      	bx	lr
 8000db4:	e000e010 	.word	0xe000e010

08000db8 <HAL_SYSTICK_Callback>:
/**
  * @brief  SYSTICK callback.
  * @retval None
  */
__weak void HAL_SYSTICK_Callback(void)
{
 8000db8:	4770      	bx	lr

08000dba <HAL_SYSTICK_IRQHandler>:
{
 8000dba:	b508      	push	{r3, lr}
  HAL_SYSTICK_Callback();
 8000dbc:	f7ff fffc 	bl	8000db8 <HAL_SYSTICK_Callback>
 8000dc0:	bd08      	pop	{r3, pc}
	...

08000dc4 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8000dc4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t position;
  uint32_t ioposition = 0x00U;
  uint32_t iocurrent = 0x00U;
  uint32_t temp = 0x00U;
  uint32_t config = 0x00U;
 8000dc8:	2200      	movs	r2, #0
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  for (position = 0U; position < GPIO_NUMBER; position++)
 8000dca:	4616      	mov	r6, r2
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable AFIO Clock */
        __HAL_RCC_AFIO_CLK_ENABLE();
 8000dcc:	4f6c      	ldr	r7, [pc, #432]	; (8000f80 <HAL_GPIO_Init+0x1bc>)
 8000dce:	4b6d      	ldr	r3, [pc, #436]	; (8000f84 <HAL_GPIO_Init+0x1c0>)
        temp = AFIO->EXTICR[position >> 2U];
        CLEAR_BIT(temp, (0x0FU) << (4U * (position & 0x03U)));
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8000dd0:	f8df e1b8 	ldr.w	lr, [pc, #440]	; 8000f8c <HAL_GPIO_Init+0x1c8>
      switch (GPIO_Init->Mode)
 8000dd4:	f8df c1b8 	ldr.w	ip, [pc, #440]	; 8000f90 <HAL_GPIO_Init+0x1cc>
    ioposition = (0x01U << position);
 8000dd8:	f04f 0801 	mov.w	r8, #1
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8000ddc:	680c      	ldr	r4, [r1, #0]
    ioposition = (0x01U << position);
 8000dde:	fa08 f806 	lsl.w	r8, r8, r6
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8000de2:	ea08 0404 	and.w	r4, r8, r4
    if (iocurrent == ioposition)
 8000de6:	45a0      	cmp	r8, r4
 8000de8:	f040 8085 	bne.w	8000ef6 <HAL_GPIO_Init+0x132>
      switch (GPIO_Init->Mode)
 8000dec:	684d      	ldr	r5, [r1, #4]
 8000dee:	2d12      	cmp	r5, #18
 8000df0:	f000 80b7 	beq.w	8000f62 <HAL_GPIO_Init+0x19e>
 8000df4:	f200 808d 	bhi.w	8000f12 <HAL_GPIO_Init+0x14e>
 8000df8:	2d02      	cmp	r5, #2
 8000dfa:	f000 80af 	beq.w	8000f5c <HAL_GPIO_Init+0x198>
 8000dfe:	f200 8081 	bhi.w	8000f04 <HAL_GPIO_Init+0x140>
 8000e02:	2d00      	cmp	r5, #0
 8000e04:	f000 8091 	beq.w	8000f2a <HAL_GPIO_Init+0x166>
 8000e08:	2d01      	cmp	r5, #1
 8000e0a:	f000 80a5 	beq.w	8000f58 <HAL_GPIO_Init+0x194>
      MODIFY_REG((*configregister), ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) << registeroffset), (config << registeroffset));
 8000e0e:	f04f 090f 	mov.w	r9, #15
      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
 8000e12:	2cff      	cmp	r4, #255	; 0xff
 8000e14:	bf93      	iteet	ls
 8000e16:	4682      	movls	sl, r0
 8000e18:	f106 4580 	addhi.w	r5, r6, #1073741824	; 0x40000000
 8000e1c:	3d08      	subhi	r5, #8
 8000e1e:	f8d0 b000 	ldrls.w	fp, [r0]
 8000e22:	bf92      	itee	ls
 8000e24:	00b5      	lslls	r5, r6, #2
 8000e26:	f8d0 b004 	ldrhi.w	fp, [r0, #4]
 8000e2a:	00ad      	lslhi	r5, r5, #2
      MODIFY_REG((*configregister), ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) << registeroffset), (config << registeroffset));
 8000e2c:	fa09 f805 	lsl.w	r8, r9, r5
 8000e30:	ea2b 0808 	bic.w	r8, fp, r8
 8000e34:	fa02 f505 	lsl.w	r5, r2, r5
      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
 8000e38:	bf88      	it	hi
 8000e3a:	f100 0a04 	addhi.w	sl, r0, #4
      MODIFY_REG((*configregister), ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) << registeroffset), (config << registeroffset));
 8000e3e:	ea48 0505 	orr.w	r5, r8, r5
 8000e42:	f8ca 5000 	str.w	r5, [sl]
      if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8000e46:	f8d1 a004 	ldr.w	sl, [r1, #4]
 8000e4a:	f01a 5f80 	tst.w	sl, #268435456	; 0x10000000
 8000e4e:	d052      	beq.n	8000ef6 <HAL_GPIO_Init+0x132>
        __HAL_RCC_AFIO_CLK_ENABLE();
 8000e50:	69bd      	ldr	r5, [r7, #24]
 8000e52:	f026 0803 	bic.w	r8, r6, #3
 8000e56:	f045 0501 	orr.w	r5, r5, #1
 8000e5a:	61bd      	str	r5, [r7, #24]
 8000e5c:	69bd      	ldr	r5, [r7, #24]
 8000e5e:	f108 4880 	add.w	r8, r8, #1073741824	; 0x40000000
 8000e62:	f005 0501 	and.w	r5, r5, #1
 8000e66:	9501      	str	r5, [sp, #4]
 8000e68:	f508 3880 	add.w	r8, r8, #65536	; 0x10000
        CLEAR_BIT(temp, (0x0FU) << (4U * (position & 0x03U)));
 8000e6c:	f006 0b03 	and.w	fp, r6, #3
        __HAL_RCC_AFIO_CLK_ENABLE();
 8000e70:	9d01      	ldr	r5, [sp, #4]
        CLEAR_BIT(temp, (0x0FU) << (4U * (position & 0x03U)));
 8000e72:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
        temp = AFIO->EXTICR[position >> 2U];
 8000e76:	f8d8 5008 	ldr.w	r5, [r8, #8]
        CLEAR_BIT(temp, (0x0FU) << (4U * (position & 0x03U)));
 8000e7a:	fa09 f90b 	lsl.w	r9, r9, fp
 8000e7e:	ea25 0909 	bic.w	r9, r5, r9
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8000e82:	4d41      	ldr	r5, [pc, #260]	; (8000f88 <HAL_GPIO_Init+0x1c4>)
 8000e84:	42a8      	cmp	r0, r5
 8000e86:	d071      	beq.n	8000f6c <HAL_GPIO_Init+0x1a8>
 8000e88:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000e8c:	42a8      	cmp	r0, r5
 8000e8e:	d06f      	beq.n	8000f70 <HAL_GPIO_Init+0x1ac>
 8000e90:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000e94:	42a8      	cmp	r0, r5
 8000e96:	d06d      	beq.n	8000f74 <HAL_GPIO_Init+0x1b0>
 8000e98:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000e9c:	42a8      	cmp	r0, r5
 8000e9e:	d06b      	beq.n	8000f78 <HAL_GPIO_Init+0x1b4>
 8000ea0:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000ea4:	42a8      	cmp	r0, r5
 8000ea6:	d069      	beq.n	8000f7c <HAL_GPIO_Init+0x1b8>
 8000ea8:	4570      	cmp	r0, lr
 8000eaa:	bf0c      	ite	eq
 8000eac:	2505      	moveq	r5, #5
 8000eae:	2506      	movne	r5, #6
 8000eb0:	fa05 f50b 	lsl.w	r5, r5, fp
 8000eb4:	ea45 0509 	orr.w	r5, r5, r9
        AFIO->EXTICR[position >> 2U] = temp;
 8000eb8:	f8c8 5008 	str.w	r5, [r8, #8]


        /* Configure the interrupt mask */
        if ((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
        {
          SET_BIT(EXTI->IMR, iocurrent);
 8000ebc:	681d      	ldr	r5, [r3, #0]
        if ((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8000ebe:	f41a 3f80 	tst.w	sl, #65536	; 0x10000
          SET_BIT(EXTI->IMR, iocurrent);
 8000ec2:	bf14      	ite	ne
 8000ec4:	4325      	orrne	r5, r4
        }
        else
        {
          CLEAR_BIT(EXTI->IMR, iocurrent);
 8000ec6:	43a5      	biceq	r5, r4
 8000ec8:	601d      	str	r5, [r3, #0]
        }

        /* Configure the event mask */
        if ((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
        {
          SET_BIT(EXTI->EMR, iocurrent);
 8000eca:	685d      	ldr	r5, [r3, #4]
        if ((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8000ecc:	f41a 3f00 	tst.w	sl, #131072	; 0x20000
          SET_BIT(EXTI->EMR, iocurrent);
 8000ed0:	bf14      	ite	ne
 8000ed2:	4325      	orrne	r5, r4
        }
        else
        {
          CLEAR_BIT(EXTI->EMR, iocurrent);
 8000ed4:	43a5      	biceq	r5, r4
 8000ed6:	605d      	str	r5, [r3, #4]
        }

        /* Enable or disable the rising trigger */
        if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
        {
          SET_BIT(EXTI->RTSR, iocurrent);
 8000ed8:	689d      	ldr	r5, [r3, #8]
        if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8000eda:	f41a 1f80 	tst.w	sl, #1048576	; 0x100000
          SET_BIT(EXTI->RTSR, iocurrent);
 8000ede:	bf14      	ite	ne
 8000ee0:	4325      	orrne	r5, r4
        }
        else
        {
          CLEAR_BIT(EXTI->RTSR, iocurrent);
 8000ee2:	43a5      	biceq	r5, r4
 8000ee4:	609d      	str	r5, [r3, #8]
        }

        /* Enable or disable the falling trigger */
        if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
        {
          SET_BIT(EXTI->FTSR, iocurrent);
 8000ee6:	68dd      	ldr	r5, [r3, #12]
        if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8000ee8:	f41a 1f00 	tst.w	sl, #2097152	; 0x200000
          SET_BIT(EXTI->FTSR, iocurrent);
 8000eec:	bf14      	ite	ne
 8000eee:	432c      	orrne	r4, r5
        }
        else
        {
          CLEAR_BIT(EXTI->FTSR, iocurrent);
 8000ef0:	ea25 0404 	biceq.w	r4, r5, r4
 8000ef4:	60dc      	str	r4, [r3, #12]
  for (position = 0U; position < GPIO_NUMBER; position++)
 8000ef6:	3601      	adds	r6, #1
 8000ef8:	2e10      	cmp	r6, #16
 8000efa:	f47f af6d 	bne.w	8000dd8 <HAL_GPIO_Init+0x14>
        }
      }
    }
  }
}
 8000efe:	b003      	add	sp, #12
 8000f00:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      switch (GPIO_Init->Mode)
 8000f04:	2d03      	cmp	r5, #3
 8000f06:	d025      	beq.n	8000f54 <HAL_GPIO_Init+0x190>
 8000f08:	2d11      	cmp	r5, #17
 8000f0a:	d180      	bne.n	8000e0e <HAL_GPIO_Init+0x4a>
          config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_OD;
 8000f0c:	68ca      	ldr	r2, [r1, #12]
 8000f0e:	3204      	adds	r2, #4
          break;
 8000f10:	e77d      	b.n	8000e0e <HAL_GPIO_Init+0x4a>
      switch (GPIO_Init->Mode)
 8000f12:	4565      	cmp	r5, ip
 8000f14:	d009      	beq.n	8000f2a <HAL_GPIO_Init+0x166>
 8000f16:	d812      	bhi.n	8000f3e <HAL_GPIO_Init+0x17a>
 8000f18:	f8df 9078 	ldr.w	r9, [pc, #120]	; 8000f94 <HAL_GPIO_Init+0x1d0>
 8000f1c:	454d      	cmp	r5, r9
 8000f1e:	d004      	beq.n	8000f2a <HAL_GPIO_Init+0x166>
 8000f20:	f509 3980 	add.w	r9, r9, #65536	; 0x10000
 8000f24:	454d      	cmp	r5, r9
 8000f26:	f47f af72 	bne.w	8000e0e <HAL_GPIO_Init+0x4a>
          if (GPIO_Init->Pull == GPIO_NOPULL)
 8000f2a:	688a      	ldr	r2, [r1, #8]
 8000f2c:	b1e2      	cbz	r2, 8000f68 <HAL_GPIO_Init+0x1a4>
          else if (GPIO_Init->Pull == GPIO_PULLUP)
 8000f2e:	2a01      	cmp	r2, #1
            GPIOx->BSRR = ioposition;
 8000f30:	bf0c      	ite	eq
 8000f32:	f8c0 8010 	streq.w	r8, [r0, #16]
            GPIOx->BRR = ioposition;
 8000f36:	f8c0 8014 	strne.w	r8, [r0, #20]
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;
 8000f3a:	2208      	movs	r2, #8
 8000f3c:	e767      	b.n	8000e0e <HAL_GPIO_Init+0x4a>
      switch (GPIO_Init->Mode)
 8000f3e:	f8df 9058 	ldr.w	r9, [pc, #88]	; 8000f98 <HAL_GPIO_Init+0x1d4>
 8000f42:	454d      	cmp	r5, r9
 8000f44:	d0f1      	beq.n	8000f2a <HAL_GPIO_Init+0x166>
 8000f46:	f509 3980 	add.w	r9, r9, #65536	; 0x10000
 8000f4a:	454d      	cmp	r5, r9
 8000f4c:	d0ed      	beq.n	8000f2a <HAL_GPIO_Init+0x166>
 8000f4e:	f5a9 1980 	sub.w	r9, r9, #1048576	; 0x100000
 8000f52:	e7e7      	b.n	8000f24 <HAL_GPIO_Init+0x160>
          config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_ANALOG;
 8000f54:	2200      	movs	r2, #0
 8000f56:	e75a      	b.n	8000e0e <HAL_GPIO_Init+0x4a>
          config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_PP;
 8000f58:	68ca      	ldr	r2, [r1, #12]
          break;
 8000f5a:	e758      	b.n	8000e0e <HAL_GPIO_Init+0x4a>
          config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_PP;
 8000f5c:	68ca      	ldr	r2, [r1, #12]
 8000f5e:	3208      	adds	r2, #8
          break;
 8000f60:	e755      	b.n	8000e0e <HAL_GPIO_Init+0x4a>
          config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_OD;
 8000f62:	68ca      	ldr	r2, [r1, #12]
 8000f64:	320c      	adds	r2, #12
          break;
 8000f66:	e752      	b.n	8000e0e <HAL_GPIO_Init+0x4a>
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_FLOATING;
 8000f68:	2204      	movs	r2, #4
 8000f6a:	e750      	b.n	8000e0e <HAL_GPIO_Init+0x4a>
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8000f6c:	2500      	movs	r5, #0
 8000f6e:	e79f      	b.n	8000eb0 <HAL_GPIO_Init+0xec>
 8000f70:	2501      	movs	r5, #1
 8000f72:	e79d      	b.n	8000eb0 <HAL_GPIO_Init+0xec>
 8000f74:	2502      	movs	r5, #2
 8000f76:	e79b      	b.n	8000eb0 <HAL_GPIO_Init+0xec>
 8000f78:	2503      	movs	r5, #3
 8000f7a:	e799      	b.n	8000eb0 <HAL_GPIO_Init+0xec>
 8000f7c:	2504      	movs	r5, #4
 8000f7e:	e797      	b.n	8000eb0 <HAL_GPIO_Init+0xec>
 8000f80:	40021000 	.word	0x40021000
 8000f84:	40010400 	.word	0x40010400
 8000f88:	40010800 	.word	0x40010800
 8000f8c:	40011c00 	.word	0x40011c00
 8000f90:	10210000 	.word	0x10210000
 8000f94:	10110000 	.word	0x10110000
 8000f98:	10310000 	.word	0x10310000

08000f9c <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 8000f9c:	b10a      	cbz	r2, 8000fa2 <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
 8000f9e:	6101      	str	r1, [r0, #16]
 8000fa0:	4770      	bx	lr
 8000fa2:	0409      	lsls	r1, r1, #16
 8000fa4:	e7fb      	b.n	8000f9e <HAL_GPIO_WritePin+0x2>

08000fa6 <HAL_GPIO_TogglePin>:
void HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->ODR ^= GPIO_Pin;
 8000fa6:	68c3      	ldr	r3, [r0, #12]
 8000fa8:	4059      	eors	r1, r3
 8000faa:	60c1      	str	r1, [r0, #12]
 8000fac:	4770      	bx	lr
	...

08000fb0 <HAL_RCC_OscConfig>:
  /* Check the parameters */
  assert_param(RCC_OscInitStruct != NULL);
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8000fb0:	6803      	ldr	r3, [r0, #0]
{
 8000fb2:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8000fb6:	07db      	lsls	r3, r3, #31
{
 8000fb8:	4605      	mov	r5, r0
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8000fba:	d410      	bmi.n	8000fde <HAL_RCC_OscConfig+0x2e>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8000fbc:	682b      	ldr	r3, [r5, #0]
 8000fbe:	079f      	lsls	r7, r3, #30
 8000fc0:	d45e      	bmi.n	8001080 <HAL_RCC_OscConfig+0xd0>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8000fc2:	682b      	ldr	r3, [r5, #0]
 8000fc4:	0719      	lsls	r1, r3, #28
 8000fc6:	f100 8095 	bmi.w	80010f4 <HAL_RCC_OscConfig+0x144>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8000fca:	682b      	ldr	r3, [r5, #0]
 8000fcc:	075a      	lsls	r2, r3, #29
 8000fce:	f100 80bf 	bmi.w	8001150 <HAL_RCC_OscConfig+0x1a0>

#endif /* RCC_CR_PLL2ON */
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8000fd2:	69ea      	ldr	r2, [r5, #28]
 8000fd4:	2a00      	cmp	r2, #0
 8000fd6:	f040 812d 	bne.w	8001234 <HAL_RCC_OscConfig+0x284>
    {
      return HAL_ERROR;
    }
  }
  
  return HAL_OK;
 8000fda:	2000      	movs	r0, #0
 8000fdc:	e014      	b.n	8001008 <HAL_RCC_OscConfig+0x58>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
 8000fde:	4c90      	ldr	r4, [pc, #576]	; (8001220 <HAL_RCC_OscConfig+0x270>)
 8000fe0:	6863      	ldr	r3, [r4, #4]
 8000fe2:	f003 030c 	and.w	r3, r3, #12
 8000fe6:	2b04      	cmp	r3, #4
 8000fe8:	d007      	beq.n	8000ffa <HAL_RCC_OscConfig+0x4a>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 8000fea:	6863      	ldr	r3, [r4, #4]
 8000fec:	f003 030c 	and.w	r3, r3, #12
 8000ff0:	2b08      	cmp	r3, #8
 8000ff2:	d10c      	bne.n	800100e <HAL_RCC_OscConfig+0x5e>
 8000ff4:	6863      	ldr	r3, [r4, #4]
 8000ff6:	03de      	lsls	r6, r3, #15
 8000ff8:	d509      	bpl.n	800100e <HAL_RCC_OscConfig+0x5e>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8000ffa:	6823      	ldr	r3, [r4, #0]
 8000ffc:	039c      	lsls	r4, r3, #14
 8000ffe:	d5dd      	bpl.n	8000fbc <HAL_RCC_OscConfig+0xc>
 8001000:	686b      	ldr	r3, [r5, #4]
 8001002:	2b00      	cmp	r3, #0
 8001004:	d1da      	bne.n	8000fbc <HAL_RCC_OscConfig+0xc>
        return HAL_ERROR;
 8001006:	2001      	movs	r0, #1
}
 8001008:	b002      	add	sp, #8
 800100a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800100e:	686b      	ldr	r3, [r5, #4]
 8001010:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8001014:	d110      	bne.n	8001038 <HAL_RCC_OscConfig+0x88>
 8001016:	6823      	ldr	r3, [r4, #0]
 8001018:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800101c:	6023      	str	r3, [r4, #0]
        tickstart = HAL_GetTick();
 800101e:	f7ff fe4b 	bl	8000cb8 <HAL_GetTick>
 8001022:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001024:	6823      	ldr	r3, [r4, #0]
 8001026:	0398      	lsls	r0, r3, #14
 8001028:	d4c8      	bmi.n	8000fbc <HAL_RCC_OscConfig+0xc>
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800102a:	f7ff fe45 	bl	8000cb8 <HAL_GetTick>
 800102e:	1b80      	subs	r0, r0, r6
 8001030:	2864      	cmp	r0, #100	; 0x64
 8001032:	d9f7      	bls.n	8001024 <HAL_RCC_OscConfig+0x74>
            return HAL_TIMEOUT;
 8001034:	2003      	movs	r0, #3
 8001036:	e7e7      	b.n	8001008 <HAL_RCC_OscConfig+0x58>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8001038:	b99b      	cbnz	r3, 8001062 <HAL_RCC_OscConfig+0xb2>
 800103a:	6823      	ldr	r3, [r4, #0]
 800103c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8001040:	6023      	str	r3, [r4, #0]
 8001042:	6823      	ldr	r3, [r4, #0]
 8001044:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8001048:	6023      	str	r3, [r4, #0]
        tickstart = HAL_GetTick();
 800104a:	f7ff fe35 	bl	8000cb8 <HAL_GetTick>
 800104e:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8001050:	6823      	ldr	r3, [r4, #0]
 8001052:	0399      	lsls	r1, r3, #14
 8001054:	d5b2      	bpl.n	8000fbc <HAL_RCC_OscConfig+0xc>
           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8001056:	f7ff fe2f 	bl	8000cb8 <HAL_GetTick>
 800105a:	1b80      	subs	r0, r0, r6
 800105c:	2864      	cmp	r0, #100	; 0x64
 800105e:	d9f7      	bls.n	8001050 <HAL_RCC_OscConfig+0xa0>
 8001060:	e7e8      	b.n	8001034 <HAL_RCC_OscConfig+0x84>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8001062:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8001066:	6823      	ldr	r3, [r4, #0]
 8001068:	d103      	bne.n	8001072 <HAL_RCC_OscConfig+0xc2>
 800106a:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 800106e:	6023      	str	r3, [r4, #0]
 8001070:	e7d1      	b.n	8001016 <HAL_RCC_OscConfig+0x66>
 8001072:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8001076:	6023      	str	r3, [r4, #0]
 8001078:	6823      	ldr	r3, [r4, #0]
 800107a:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 800107e:	e7cd      	b.n	800101c <HAL_RCC_OscConfig+0x6c>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
 8001080:	4c67      	ldr	r4, [pc, #412]	; (8001220 <HAL_RCC_OscConfig+0x270>)
 8001082:	6863      	ldr	r3, [r4, #4]
 8001084:	f013 0f0c 	tst.w	r3, #12
 8001088:	d007      	beq.n	800109a <HAL_RCC_OscConfig+0xea>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI_DIV2)))
 800108a:	6863      	ldr	r3, [r4, #4]
 800108c:	f003 030c 	and.w	r3, r3, #12
 8001090:	2b08      	cmp	r3, #8
 8001092:	d110      	bne.n	80010b6 <HAL_RCC_OscConfig+0x106>
 8001094:	6863      	ldr	r3, [r4, #4]
 8001096:	03da      	lsls	r2, r3, #15
 8001098:	d40d      	bmi.n	80010b6 <HAL_RCC_OscConfig+0x106>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 800109a:	6823      	ldr	r3, [r4, #0]
 800109c:	079b      	lsls	r3, r3, #30
 800109e:	d502      	bpl.n	80010a6 <HAL_RCC_OscConfig+0xf6>
 80010a0:	692b      	ldr	r3, [r5, #16]
 80010a2:	2b01      	cmp	r3, #1
 80010a4:	d1af      	bne.n	8001006 <HAL_RCC_OscConfig+0x56>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80010a6:	6823      	ldr	r3, [r4, #0]
 80010a8:	696a      	ldr	r2, [r5, #20]
 80010aa:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 80010ae:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 80010b2:	6023      	str	r3, [r4, #0]
 80010b4:	e785      	b.n	8000fc2 <HAL_RCC_OscConfig+0x12>
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 80010b6:	692a      	ldr	r2, [r5, #16]
 80010b8:	4b5a      	ldr	r3, [pc, #360]	; (8001224 <HAL_RCC_OscConfig+0x274>)
 80010ba:	b16a      	cbz	r2, 80010d8 <HAL_RCC_OscConfig+0x128>
        __HAL_RCC_HSI_ENABLE();
 80010bc:	2201      	movs	r2, #1
 80010be:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 80010c0:	f7ff fdfa 	bl	8000cb8 <HAL_GetTick>
 80010c4:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80010c6:	6823      	ldr	r3, [r4, #0]
 80010c8:	079f      	lsls	r7, r3, #30
 80010ca:	d4ec      	bmi.n	80010a6 <HAL_RCC_OscConfig+0xf6>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 80010cc:	f7ff fdf4 	bl	8000cb8 <HAL_GetTick>
 80010d0:	1b80      	subs	r0, r0, r6
 80010d2:	2802      	cmp	r0, #2
 80010d4:	d9f7      	bls.n	80010c6 <HAL_RCC_OscConfig+0x116>
 80010d6:	e7ad      	b.n	8001034 <HAL_RCC_OscConfig+0x84>
        __HAL_RCC_HSI_DISABLE();
 80010d8:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 80010da:	f7ff fded 	bl	8000cb8 <HAL_GetTick>
 80010de:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 80010e0:	6823      	ldr	r3, [r4, #0]
 80010e2:	0798      	lsls	r0, r3, #30
 80010e4:	f57f af6d 	bpl.w	8000fc2 <HAL_RCC_OscConfig+0x12>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 80010e8:	f7ff fde6 	bl	8000cb8 <HAL_GetTick>
 80010ec:	1b80      	subs	r0, r0, r6
 80010ee:	2802      	cmp	r0, #2
 80010f0:	d9f6      	bls.n	80010e0 <HAL_RCC_OscConfig+0x130>
 80010f2:	e79f      	b.n	8001034 <HAL_RCC_OscConfig+0x84>
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 80010f4:	69aa      	ldr	r2, [r5, #24]
 80010f6:	4c4a      	ldr	r4, [pc, #296]	; (8001220 <HAL_RCC_OscConfig+0x270>)
 80010f8:	4b4b      	ldr	r3, [pc, #300]	; (8001228 <HAL_RCC_OscConfig+0x278>)
 80010fa:	b1da      	cbz	r2, 8001134 <HAL_RCC_OscConfig+0x184>
      __HAL_RCC_LSI_ENABLE();
 80010fc:	2201      	movs	r2, #1
 80010fe:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
 8001100:	f7ff fdda 	bl	8000cb8 <HAL_GetTick>
 8001104:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8001106:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8001108:	079b      	lsls	r3, r3, #30
 800110a:	d50d      	bpl.n	8001128 <HAL_RCC_OscConfig+0x178>
  * @param  mdelay: specifies the delay time length, in milliseconds.
  * @retval None
  */
static void RCC_Delay(uint32_t mdelay)
{
  __IO uint32_t Delay = mdelay * (SystemCoreClock / 8U / 1000U);
 800110c:	f44f 52fa 	mov.w	r2, #8000	; 0x1f40
 8001110:	4b46      	ldr	r3, [pc, #280]	; (800122c <HAL_RCC_OscConfig+0x27c>)
 8001112:	681b      	ldr	r3, [r3, #0]
 8001114:	fbb3 f3f2 	udiv	r3, r3, r2
 8001118:	9301      	str	r3, [sp, #4]
  \brief   No Operation
  \details No Operation does nothing. This instruction can be used for code alignment purposes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
{
  __ASM volatile ("nop");
 800111a:	bf00      	nop
  do 
  {
    __NOP();
  } 
  while (Delay --);
 800111c:	9b01      	ldr	r3, [sp, #4]
 800111e:	1e5a      	subs	r2, r3, #1
 8001120:	9201      	str	r2, [sp, #4]
 8001122:	2b00      	cmp	r3, #0
 8001124:	d1f9      	bne.n	800111a <HAL_RCC_OscConfig+0x16a>
 8001126:	e750      	b.n	8000fca <HAL_RCC_OscConfig+0x1a>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8001128:	f7ff fdc6 	bl	8000cb8 <HAL_GetTick>
 800112c:	1b80      	subs	r0, r0, r6
 800112e:	2802      	cmp	r0, #2
 8001130:	d9e9      	bls.n	8001106 <HAL_RCC_OscConfig+0x156>
 8001132:	e77f      	b.n	8001034 <HAL_RCC_OscConfig+0x84>
      __HAL_RCC_LSI_DISABLE();
 8001134:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
 8001136:	f7ff fdbf 	bl	8000cb8 <HAL_GetTick>
 800113a:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800113c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800113e:	079f      	lsls	r7, r3, #30
 8001140:	f57f af43 	bpl.w	8000fca <HAL_RCC_OscConfig+0x1a>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8001144:	f7ff fdb8 	bl	8000cb8 <HAL_GetTick>
 8001148:	1b80      	subs	r0, r0, r6
 800114a:	2802      	cmp	r0, #2
 800114c:	d9f6      	bls.n	800113c <HAL_RCC_OscConfig+0x18c>
 800114e:	e771      	b.n	8001034 <HAL_RCC_OscConfig+0x84>
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8001150:	4c33      	ldr	r4, [pc, #204]	; (8001220 <HAL_RCC_OscConfig+0x270>)
 8001152:	69e3      	ldr	r3, [r4, #28]
 8001154:	00d8      	lsls	r0, r3, #3
 8001156:	d424      	bmi.n	80011a2 <HAL_RCC_OscConfig+0x1f2>
      pwrclkchanged = SET;
 8001158:	2701      	movs	r7, #1
      __HAL_RCC_PWR_CLK_ENABLE();
 800115a:	69e3      	ldr	r3, [r4, #28]
 800115c:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8001160:	61e3      	str	r3, [r4, #28]
 8001162:	69e3      	ldr	r3, [r4, #28]
 8001164:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8001168:	9300      	str	r3, [sp, #0]
 800116a:	9b00      	ldr	r3, [sp, #0]
    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800116c:	4e30      	ldr	r6, [pc, #192]	; (8001230 <HAL_RCC_OscConfig+0x280>)
 800116e:	6833      	ldr	r3, [r6, #0]
 8001170:	05d9      	lsls	r1, r3, #23
 8001172:	d518      	bpl.n	80011a6 <HAL_RCC_OscConfig+0x1f6>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8001174:	68eb      	ldr	r3, [r5, #12]
 8001176:	2b01      	cmp	r3, #1
 8001178:	d126      	bne.n	80011c8 <HAL_RCC_OscConfig+0x218>
 800117a:	6a23      	ldr	r3, [r4, #32]
 800117c:	f043 0301 	orr.w	r3, r3, #1
 8001180:	6223      	str	r3, [r4, #32]
      tickstart = HAL_GetTick();
 8001182:	f7ff fd99 	bl	8000cb8 <HAL_GetTick>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8001186:	f241 3688 	movw	r6, #5000	; 0x1388
      tickstart = HAL_GetTick();
 800118a:	4680      	mov	r8, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800118c:	6a23      	ldr	r3, [r4, #32]
 800118e:	079b      	lsls	r3, r3, #30
 8001190:	d53f      	bpl.n	8001212 <HAL_RCC_OscConfig+0x262>
    if(pwrclkchanged == SET)
 8001192:	2f00      	cmp	r7, #0
 8001194:	f43f af1d 	beq.w	8000fd2 <HAL_RCC_OscConfig+0x22>
      __HAL_RCC_PWR_CLK_DISABLE();
 8001198:	69e3      	ldr	r3, [r4, #28]
 800119a:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 800119e:	61e3      	str	r3, [r4, #28]
 80011a0:	e717      	b.n	8000fd2 <HAL_RCC_OscConfig+0x22>
    FlagStatus       pwrclkchanged = RESET;
 80011a2:	2700      	movs	r7, #0
 80011a4:	e7e2      	b.n	800116c <HAL_RCC_OscConfig+0x1bc>
      SET_BIT(PWR->CR, PWR_CR_DBP);
 80011a6:	6833      	ldr	r3, [r6, #0]
 80011a8:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80011ac:	6033      	str	r3, [r6, #0]
      tickstart = HAL_GetTick();
 80011ae:	f7ff fd83 	bl	8000cb8 <HAL_GetTick>
 80011b2:	4680      	mov	r8, r0
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80011b4:	6833      	ldr	r3, [r6, #0]
 80011b6:	05da      	lsls	r2, r3, #23
 80011b8:	d4dc      	bmi.n	8001174 <HAL_RCC_OscConfig+0x1c4>
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80011ba:	f7ff fd7d 	bl	8000cb8 <HAL_GetTick>
 80011be:	eba0 0008 	sub.w	r0, r0, r8
 80011c2:	2864      	cmp	r0, #100	; 0x64
 80011c4:	d9f6      	bls.n	80011b4 <HAL_RCC_OscConfig+0x204>
 80011c6:	e735      	b.n	8001034 <HAL_RCC_OscConfig+0x84>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80011c8:	b9ab      	cbnz	r3, 80011f6 <HAL_RCC_OscConfig+0x246>
 80011ca:	6a23      	ldr	r3, [r4, #32]
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80011cc:	f241 3888 	movw	r8, #5000	; 0x1388
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80011d0:	f023 0301 	bic.w	r3, r3, #1
 80011d4:	6223      	str	r3, [r4, #32]
 80011d6:	6a23      	ldr	r3, [r4, #32]
 80011d8:	f023 0304 	bic.w	r3, r3, #4
 80011dc:	6223      	str	r3, [r4, #32]
      tickstart = HAL_GetTick();
 80011de:	f7ff fd6b 	bl	8000cb8 <HAL_GetTick>
 80011e2:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80011e4:	6a23      	ldr	r3, [r4, #32]
 80011e6:	0798      	lsls	r0, r3, #30
 80011e8:	d5d3      	bpl.n	8001192 <HAL_RCC_OscConfig+0x1e2>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80011ea:	f7ff fd65 	bl	8000cb8 <HAL_GetTick>
 80011ee:	1b80      	subs	r0, r0, r6
 80011f0:	4540      	cmp	r0, r8
 80011f2:	d9f7      	bls.n	80011e4 <HAL_RCC_OscConfig+0x234>
 80011f4:	e71e      	b.n	8001034 <HAL_RCC_OscConfig+0x84>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80011f6:	2b05      	cmp	r3, #5
 80011f8:	6a23      	ldr	r3, [r4, #32]
 80011fa:	d103      	bne.n	8001204 <HAL_RCC_OscConfig+0x254>
 80011fc:	f043 0304 	orr.w	r3, r3, #4
 8001200:	6223      	str	r3, [r4, #32]
 8001202:	e7ba      	b.n	800117a <HAL_RCC_OscConfig+0x1ca>
 8001204:	f023 0301 	bic.w	r3, r3, #1
 8001208:	6223      	str	r3, [r4, #32]
 800120a:	6a23      	ldr	r3, [r4, #32]
 800120c:	f023 0304 	bic.w	r3, r3, #4
 8001210:	e7b6      	b.n	8001180 <HAL_RCC_OscConfig+0x1d0>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8001212:	f7ff fd51 	bl	8000cb8 <HAL_GetTick>
 8001216:	eba0 0008 	sub.w	r0, r0, r8
 800121a:	42b0      	cmp	r0, r6
 800121c:	d9b6      	bls.n	800118c <HAL_RCC_OscConfig+0x1dc>
 800121e:	e709      	b.n	8001034 <HAL_RCC_OscConfig+0x84>
 8001220:	40021000 	.word	0x40021000
 8001224:	42420000 	.word	0x42420000
 8001228:	42420480 	.word	0x42420480
 800122c:	20000000 	.word	0x20000000
 8001230:	40007000 	.word	0x40007000
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8001234:	4c22      	ldr	r4, [pc, #136]	; (80012c0 <HAL_RCC_OscConfig+0x310>)
 8001236:	6863      	ldr	r3, [r4, #4]
 8001238:	f003 030c 	and.w	r3, r3, #12
 800123c:	2b08      	cmp	r3, #8
 800123e:	f43f aee2 	beq.w	8001006 <HAL_RCC_OscConfig+0x56>
 8001242:	2300      	movs	r3, #0
 8001244:	4e1f      	ldr	r6, [pc, #124]	; (80012c4 <HAL_RCC_OscConfig+0x314>)
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8001246:	2a02      	cmp	r2, #2
        __HAL_RCC_PLL_DISABLE();
 8001248:	6033      	str	r3, [r6, #0]
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 800124a:	d12b      	bne.n	80012a4 <HAL_RCC_OscConfig+0x2f4>
        tickstart = HAL_GetTick();
 800124c:	f7ff fd34 	bl	8000cb8 <HAL_GetTick>
 8001250:	4607      	mov	r7, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8001252:	6823      	ldr	r3, [r4, #0]
 8001254:	0199      	lsls	r1, r3, #6
 8001256:	d41f      	bmi.n	8001298 <HAL_RCC_OscConfig+0x2e8>
        if(RCC_OscInitStruct->PLL.PLLSource == RCC_PLLSOURCE_HSE)
 8001258:	6a2b      	ldr	r3, [r5, #32]
 800125a:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800125e:	d105      	bne.n	800126c <HAL_RCC_OscConfig+0x2bc>
          __HAL_RCC_HSE_PREDIV_CONFIG(RCC_OscInitStruct->HSEPredivValue);
 8001260:	6862      	ldr	r2, [r4, #4]
 8001262:	68a9      	ldr	r1, [r5, #8]
 8001264:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 8001268:	430a      	orrs	r2, r1
 800126a:	6062      	str	r2, [r4, #4]
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 800126c:	6a69      	ldr	r1, [r5, #36]	; 0x24
 800126e:	6862      	ldr	r2, [r4, #4]
 8001270:	430b      	orrs	r3, r1
 8001272:	f422 1274 	bic.w	r2, r2, #3997696	; 0x3d0000
 8001276:	4313      	orrs	r3, r2
 8001278:	6063      	str	r3, [r4, #4]
        __HAL_RCC_PLL_ENABLE();
 800127a:	2301      	movs	r3, #1
 800127c:	6033      	str	r3, [r6, #0]
        tickstart = HAL_GetTick();
 800127e:	f7ff fd1b 	bl	8000cb8 <HAL_GetTick>
 8001282:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 8001284:	6823      	ldr	r3, [r4, #0]
 8001286:	019a      	lsls	r2, r3, #6
 8001288:	f53f aea7 	bmi.w	8000fda <HAL_RCC_OscConfig+0x2a>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800128c:	f7ff fd14 	bl	8000cb8 <HAL_GetTick>
 8001290:	1b40      	subs	r0, r0, r5
 8001292:	2802      	cmp	r0, #2
 8001294:	d9f6      	bls.n	8001284 <HAL_RCC_OscConfig+0x2d4>
 8001296:	e6cd      	b.n	8001034 <HAL_RCC_OscConfig+0x84>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8001298:	f7ff fd0e 	bl	8000cb8 <HAL_GetTick>
 800129c:	1bc0      	subs	r0, r0, r7
 800129e:	2802      	cmp	r0, #2
 80012a0:	d9d7      	bls.n	8001252 <HAL_RCC_OscConfig+0x2a2>
 80012a2:	e6c7      	b.n	8001034 <HAL_RCC_OscConfig+0x84>
        tickstart = HAL_GetTick();
 80012a4:	f7ff fd08 	bl	8000cb8 <HAL_GetTick>
 80012a8:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 80012aa:	6823      	ldr	r3, [r4, #0]
 80012ac:	019b      	lsls	r3, r3, #6
 80012ae:	f57f ae94 	bpl.w	8000fda <HAL_RCC_OscConfig+0x2a>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80012b2:	f7ff fd01 	bl	8000cb8 <HAL_GetTick>
 80012b6:	1b40      	subs	r0, r0, r5
 80012b8:	2802      	cmp	r0, #2
 80012ba:	d9f6      	bls.n	80012aa <HAL_RCC_OscConfig+0x2fa>
 80012bc:	e6ba      	b.n	8001034 <HAL_RCC_OscConfig+0x84>
 80012be:	bf00      	nop
 80012c0:	40021000 	.word	0x40021000
 80012c4:	42420060 	.word	0x42420060

080012c8 <HAL_RCC_GetSysClockFreq>:
{
 80012c8:	b530      	push	{r4, r5, lr}
  const uint8_t aPLLMULFactorTable[16] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 16};
 80012ca:	4b19      	ldr	r3, [pc, #100]	; (8001330 <HAL_RCC_GetSysClockFreq+0x68>)
{
 80012cc:	b087      	sub	sp, #28
  const uint8_t aPLLMULFactorTable[16] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 16};
 80012ce:	ac02      	add	r4, sp, #8
 80012d0:	f103 0510 	add.w	r5, r3, #16
 80012d4:	4622      	mov	r2, r4
 80012d6:	6818      	ldr	r0, [r3, #0]
 80012d8:	6859      	ldr	r1, [r3, #4]
 80012da:	3308      	adds	r3, #8
 80012dc:	c203      	stmia	r2!, {r0, r1}
 80012de:	42ab      	cmp	r3, r5
 80012e0:	4614      	mov	r4, r2
 80012e2:	d1f7      	bne.n	80012d4 <HAL_RCC_GetSysClockFreq+0xc>
  const uint8_t aPredivFactorTable[2] = {1, 2};
 80012e4:	2301      	movs	r3, #1
 80012e6:	f88d 3004 	strb.w	r3, [sp, #4]
 80012ea:	2302      	movs	r3, #2
  tmpreg = RCC->CFGR;
 80012ec:	4911      	ldr	r1, [pc, #68]	; (8001334 <HAL_RCC_GetSysClockFreq+0x6c>)
  const uint8_t aPredivFactorTable[2] = {1, 2};
 80012ee:	f88d 3005 	strb.w	r3, [sp, #5]
  tmpreg = RCC->CFGR;
 80012f2:	684b      	ldr	r3, [r1, #4]
  switch (tmpreg & RCC_CFGR_SWS)
 80012f4:	f003 020c 	and.w	r2, r3, #12
 80012f8:	2a08      	cmp	r2, #8
 80012fa:	d117      	bne.n	800132c <HAL_RCC_GetSysClockFreq+0x64>
      pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMULL) >> RCC_CFGR_PLLMULL_Pos];
 80012fc:	f3c3 4283 	ubfx	r2, r3, #18, #4
 8001300:	a806      	add	r0, sp, #24
 8001302:	4402      	add	r2, r0
      if ((tmpreg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
 8001304:	03db      	lsls	r3, r3, #15
      pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMULL) >> RCC_CFGR_PLLMULL_Pos];
 8001306:	f812 2c10 	ldrb.w	r2, [r2, #-16]
      if ((tmpreg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
 800130a:	d50c      	bpl.n	8001326 <HAL_RCC_GetSysClockFreq+0x5e>
        prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR & RCC_CFGR_PLLXTPRE) >> RCC_CFGR_PLLXTPRE_Pos];
 800130c:	684b      	ldr	r3, [r1, #4]
        pllclk = (uint32_t)((HSE_VALUE  * pllmul) / prediv);
 800130e:	480a      	ldr	r0, [pc, #40]	; (8001338 <HAL_RCC_GetSysClockFreq+0x70>)
        prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR & RCC_CFGR_PLLXTPRE) >> RCC_CFGR_PLLXTPRE_Pos];
 8001310:	f3c3 4340 	ubfx	r3, r3, #17, #1
        pllclk = (uint32_t)((HSE_VALUE  * pllmul) / prediv);
 8001314:	4350      	muls	r0, r2
        prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR & RCC_CFGR_PLLXTPRE) >> RCC_CFGR_PLLXTPRE_Pos];
 8001316:	aa06      	add	r2, sp, #24
 8001318:	4413      	add	r3, r2
 800131a:	f813 3c14 	ldrb.w	r3, [r3, #-20]
        pllclk = (uint32_t)((HSE_VALUE  * pllmul) / prediv);
 800131e:	fbb0 f0f3 	udiv	r0, r0, r3
}
 8001322:	b007      	add	sp, #28
 8001324:	bd30      	pop	{r4, r5, pc}
        pllclk = (uint32_t)((HSI_VALUE >> 1) * pllmul);
 8001326:	4805      	ldr	r0, [pc, #20]	; (800133c <HAL_RCC_GetSysClockFreq+0x74>)
 8001328:	4350      	muls	r0, r2
 800132a:	e7fa      	b.n	8001322 <HAL_RCC_GetSysClockFreq+0x5a>
      sysclockfreq = HSE_VALUE;
 800132c:	4802      	ldr	r0, [pc, #8]	; (8001338 <HAL_RCC_GetSysClockFreq+0x70>)
  return sysclockfreq;
 800132e:	e7f8      	b.n	8001322 <HAL_RCC_GetSysClockFreq+0x5a>
 8001330:	08003984 	.word	0x08003984
 8001334:	40021000 	.word	0x40021000
 8001338:	007a1200 	.word	0x007a1200
 800133c:	003d0900 	.word	0x003d0900

08001340 <HAL_RCC_ClockConfig>:
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8001340:	4a4d      	ldr	r2, [pc, #308]	; (8001478 <HAL_RCC_ClockConfig+0x138>)
{
 8001342:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8001346:	6813      	ldr	r3, [r2, #0]
{
 8001348:	4605      	mov	r5, r0
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 800134a:	f003 0307 	and.w	r3, r3, #7
 800134e:	428b      	cmp	r3, r1
{
 8001350:	460e      	mov	r6, r1
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8001352:	d328      	bcc.n	80013a6 <HAL_RCC_ClockConfig+0x66>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8001354:	682a      	ldr	r2, [r5, #0]
 8001356:	0791      	lsls	r1, r2, #30
 8001358:	d432      	bmi.n	80013c0 <HAL_RCC_ClockConfig+0x80>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800135a:	07d2      	lsls	r2, r2, #31
 800135c:	d438      	bmi.n	80013d0 <HAL_RCC_ClockConfig+0x90>
  if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
 800135e:	4a46      	ldr	r2, [pc, #280]	; (8001478 <HAL_RCC_ClockConfig+0x138>)
 8001360:	6813      	ldr	r3, [r2, #0]
 8001362:	f003 0307 	and.w	r3, r3, #7
 8001366:	429e      	cmp	r6, r3
 8001368:	d373      	bcc.n	8001452 <HAL_RCC_ClockConfig+0x112>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800136a:	682a      	ldr	r2, [r5, #0]
 800136c:	4c43      	ldr	r4, [pc, #268]	; (800147c <HAL_RCC_ClockConfig+0x13c>)
 800136e:	f012 0f04 	tst.w	r2, #4
 8001372:	d179      	bne.n	8001468 <HAL_RCC_ClockConfig+0x128>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8001374:	0713      	lsls	r3, r2, #28
 8001376:	d506      	bpl.n	8001386 <HAL_RCC_ClockConfig+0x46>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 8001378:	6863      	ldr	r3, [r4, #4]
 800137a:	692a      	ldr	r2, [r5, #16]
 800137c:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 8001380:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 8001384:	6063      	str	r3, [r4, #4]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 8001386:	f7ff ff9f 	bl	80012c8 <HAL_RCC_GetSysClockFreq>
 800138a:	6863      	ldr	r3, [r4, #4]
 800138c:	4a3c      	ldr	r2, [pc, #240]	; (8001480 <HAL_RCC_ClockConfig+0x140>)
 800138e:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8001392:	5cd3      	ldrb	r3, [r2, r3]
 8001394:	40d8      	lsrs	r0, r3
 8001396:	4b3b      	ldr	r3, [pc, #236]	; (8001484 <HAL_RCC_ClockConfig+0x144>)
 8001398:	6018      	str	r0, [r3, #0]
  HAL_InitTick (TICK_INT_PRIORITY);
 800139a:	2000      	movs	r0, #0
 800139c:	f7ff fc4a 	bl	8000c34 <HAL_InitTick>
  return HAL_OK;
 80013a0:	2000      	movs	r0, #0
}
 80013a2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    __HAL_FLASH_SET_LATENCY(FLatency);
 80013a6:	6813      	ldr	r3, [r2, #0]
 80013a8:	f023 0307 	bic.w	r3, r3, #7
 80013ac:	430b      	orrs	r3, r1
 80013ae:	6013      	str	r3, [r2, #0]
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 80013b0:	6813      	ldr	r3, [r2, #0]
 80013b2:	f003 0307 	and.w	r3, r3, #7
 80013b6:	4299      	cmp	r1, r3
 80013b8:	d0cc      	beq.n	8001354 <HAL_RCC_ClockConfig+0x14>
      return HAL_ERROR;
 80013ba:	2001      	movs	r0, #1
 80013bc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 80013c0:	492e      	ldr	r1, [pc, #184]	; (800147c <HAL_RCC_ClockConfig+0x13c>)
 80013c2:	68a8      	ldr	r0, [r5, #8]
 80013c4:	684b      	ldr	r3, [r1, #4]
 80013c6:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80013ca:	4303      	orrs	r3, r0
 80013cc:	604b      	str	r3, [r1, #4]
 80013ce:	e7c4      	b.n	800135a <HAL_RCC_ClockConfig+0x1a>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80013d0:	686a      	ldr	r2, [r5, #4]
 80013d2:	4c2a      	ldr	r4, [pc, #168]	; (800147c <HAL_RCC_ClockConfig+0x13c>)
 80013d4:	2a01      	cmp	r2, #1
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80013d6:	6823      	ldr	r3, [r4, #0]
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80013d8:	d11c      	bne.n	8001414 <HAL_RCC_ClockConfig+0xd4>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80013da:	f413 3f00 	tst.w	r3, #131072	; 0x20000
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80013de:	d0ec      	beq.n	80013ba <HAL_RCC_ClockConfig+0x7a>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 80013e0:	6863      	ldr	r3, [r4, #4]
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80013e2:	f241 3888 	movw	r8, #5000	; 0x1388
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 80013e6:	f023 0303 	bic.w	r3, r3, #3
 80013ea:	4313      	orrs	r3, r2
 80013ec:	6063      	str	r3, [r4, #4]
    tickstart = HAL_GetTick();
 80013ee:	f7ff fc63 	bl	8000cb8 <HAL_GetTick>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80013f2:	686b      	ldr	r3, [r5, #4]
    tickstart = HAL_GetTick();
 80013f4:	4607      	mov	r7, r0
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80013f6:	2b01      	cmp	r3, #1
 80013f8:	d114      	bne.n	8001424 <HAL_RCC_ClockConfig+0xe4>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 80013fa:	6863      	ldr	r3, [r4, #4]
 80013fc:	f003 030c 	and.w	r3, r3, #12
 8001400:	2b04      	cmp	r3, #4
 8001402:	d0ac      	beq.n	800135e <HAL_RCC_ClockConfig+0x1e>
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001404:	f7ff fc58 	bl	8000cb8 <HAL_GetTick>
 8001408:	1bc0      	subs	r0, r0, r7
 800140a:	4540      	cmp	r0, r8
 800140c:	d9f5      	bls.n	80013fa <HAL_RCC_ClockConfig+0xba>
          return HAL_TIMEOUT;
 800140e:	2003      	movs	r0, #3
 8001410:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8001414:	2a02      	cmp	r2, #2
 8001416:	d102      	bne.n	800141e <HAL_RCC_ClockConfig+0xde>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001418:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 800141c:	e7df      	b.n	80013de <HAL_RCC_ClockConfig+0x9e>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800141e:	f013 0f02 	tst.w	r3, #2
 8001422:	e7dc      	b.n	80013de <HAL_RCC_ClockConfig+0x9e>
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8001424:	2b02      	cmp	r3, #2
 8001426:	d10f      	bne.n	8001448 <HAL_RCC_ClockConfig+0x108>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8001428:	6863      	ldr	r3, [r4, #4]
 800142a:	f003 030c 	and.w	r3, r3, #12
 800142e:	2b08      	cmp	r3, #8
 8001430:	d095      	beq.n	800135e <HAL_RCC_ClockConfig+0x1e>
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001432:	f7ff fc41 	bl	8000cb8 <HAL_GetTick>
 8001436:	1bc0      	subs	r0, r0, r7
 8001438:	4540      	cmp	r0, r8
 800143a:	d9f5      	bls.n	8001428 <HAL_RCC_ClockConfig+0xe8>
 800143c:	e7e7      	b.n	800140e <HAL_RCC_ClockConfig+0xce>
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800143e:	f7ff fc3b 	bl	8000cb8 <HAL_GetTick>
 8001442:	1bc0      	subs	r0, r0, r7
 8001444:	4540      	cmp	r0, r8
 8001446:	d8e2      	bhi.n	800140e <HAL_RCC_ClockConfig+0xce>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 8001448:	6863      	ldr	r3, [r4, #4]
 800144a:	f013 0f0c 	tst.w	r3, #12
 800144e:	d1f6      	bne.n	800143e <HAL_RCC_ClockConfig+0xfe>
 8001450:	e785      	b.n	800135e <HAL_RCC_ClockConfig+0x1e>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8001452:	6813      	ldr	r3, [r2, #0]
 8001454:	f023 0307 	bic.w	r3, r3, #7
 8001458:	4333      	orrs	r3, r6
 800145a:	6013      	str	r3, [r2, #0]
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 800145c:	6813      	ldr	r3, [r2, #0]
 800145e:	f003 0307 	and.w	r3, r3, #7
 8001462:	429e      	cmp	r6, r3
 8001464:	d1a9      	bne.n	80013ba <HAL_RCC_ClockConfig+0x7a>
 8001466:	e780      	b.n	800136a <HAL_RCC_ClockConfig+0x2a>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8001468:	6863      	ldr	r3, [r4, #4]
 800146a:	68e9      	ldr	r1, [r5, #12]
 800146c:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8001470:	430b      	orrs	r3, r1
 8001472:	6063      	str	r3, [r4, #4]
 8001474:	e77e      	b.n	8001374 <HAL_RCC_ClockConfig+0x34>
 8001476:	bf00      	nop
 8001478:	40022000 	.word	0x40022000
 800147c:	40021000 	.word	0x40021000
 8001480:	080039b3 	.word	0x080039b3
 8001484:	20000000 	.word	0x20000000

08001488 <HAL_RCC_GetHCLKFreq>:
}
 8001488:	4b01      	ldr	r3, [pc, #4]	; (8001490 <HAL_RCC_GetHCLKFreq+0x8>)
 800148a:	6818      	ldr	r0, [r3, #0]
 800148c:	4770      	bx	lr
 800148e:	bf00      	nop
 8001490:	20000000 	.word	0x20000000

08001494 <SPI_WaitFlagStateUntilTimeout>:
  * @param Timeout: Timeout duration
  * @param Tickstart: tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, uint32_t State, uint32_t Timeout, uint32_t Tickstart)
{
 8001494:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001498:	4604      	mov	r4, r0
 800149a:	4688      	mov	r8, r1
 800149c:	4617      	mov	r7, r2
 800149e:	461d      	mov	r5, r3
 80014a0:	9e06      	ldr	r6, [sp, #24]
  while((((hspi->Instance->SR & Flag) == (Flag)) ? SET : RESET) != State)
 80014a2:	6822      	ldr	r2, [r4, #0]
 80014a4:	6893      	ldr	r3, [r2, #8]
 80014a6:	ea38 0303 	bics.w	r3, r8, r3
 80014aa:	bf0c      	ite	eq
 80014ac:	2301      	moveq	r3, #1
 80014ae:	2300      	movne	r3, #0
 80014b0:	429f      	cmp	r7, r3
 80014b2:	d102      	bne.n	80014ba <SPI_WaitFlagStateUntilTimeout+0x26>
        return HAL_TIMEOUT;
      }
    }
  }

  return HAL_OK;
 80014b4:	2000      	movs	r0, #0
}
 80014b6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if(Timeout != HAL_MAX_DELAY)
 80014ba:	1c6b      	adds	r3, r5, #1
 80014bc:	d0f2      	beq.n	80014a4 <SPI_WaitFlagStateUntilTimeout+0x10>
      if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) >= Timeout))
 80014be:	bb55      	cbnz	r5, 8001516 <SPI_WaitFlagStateUntilTimeout+0x82>
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 80014c0:	6823      	ldr	r3, [r4, #0]
 80014c2:	685a      	ldr	r2, [r3, #4]
 80014c4:	f022 02e0 	bic.w	r2, r2, #224	; 0xe0
 80014c8:	605a      	str	r2, [r3, #4]
        if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 80014ca:	6862      	ldr	r2, [r4, #4]
 80014cc:	f5b2 7f82 	cmp.w	r2, #260	; 0x104
 80014d0:	d10a      	bne.n	80014e8 <SPI_WaitFlagStateUntilTimeout+0x54>
 80014d2:	68a2      	ldr	r2, [r4, #8]
 80014d4:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
 80014d8:	d002      	beq.n	80014e0 <SPI_WaitFlagStateUntilTimeout+0x4c>
 80014da:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 80014de:	d103      	bne.n	80014e8 <SPI_WaitFlagStateUntilTimeout+0x54>
          __HAL_SPI_DISABLE(hspi);
 80014e0:	681a      	ldr	r2, [r3, #0]
 80014e2:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 80014e6:	601a      	str	r2, [r3, #0]
        if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80014e8:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80014ea:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 80014ee:	d109      	bne.n	8001504 <SPI_WaitFlagStateUntilTimeout+0x70>
          SPI_RESET_CRC(hspi);
 80014f0:	681a      	ldr	r2, [r3, #0]
 80014f2:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 80014f6:	0412      	lsls	r2, r2, #16
 80014f8:	0c12      	lsrs	r2, r2, #16
 80014fa:	601a      	str	r2, [r3, #0]
 80014fc:	681a      	ldr	r2, [r3, #0]
 80014fe:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8001502:	601a      	str	r2, [r3, #0]
        hspi->State= HAL_SPI_STATE_READY;
 8001504:	2301      	movs	r3, #1
 8001506:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
        __HAL_UNLOCK(hspi);
 800150a:	2300      	movs	r3, #0
 800150c:	2003      	movs	r0, #3
 800150e:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
 8001512:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) >= Timeout))
 8001516:	f7ff fbcf 	bl	8000cb8 <HAL_GetTick>
 800151a:	1b80      	subs	r0, r0, r6
 800151c:	4285      	cmp	r5, r0
 800151e:	d8c0      	bhi.n	80014a2 <SPI_WaitFlagStateUntilTimeout+0xe>
 8001520:	e7ce      	b.n	80014c0 <SPI_WaitFlagStateUntilTimeout+0x2c>

08001522 <SPI_CheckFlag_BSY>:
  * @param Timeout: Timeout duration
  * @param Tickstart: tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_CheckFlag_BSY(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
{
 8001522:	b513      	push	{r0, r1, r4, lr}
  /* Control the BSY flag */
  if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 8001524:	460b      	mov	r3, r1
 8001526:	9200      	str	r2, [sp, #0]
 8001528:	2180      	movs	r1, #128	; 0x80
 800152a:	2200      	movs	r2, #0
{
 800152c:	4604      	mov	r4, r0
  if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 800152e:	f7ff ffb1 	bl	8001494 <SPI_WaitFlagStateUntilTimeout>
 8001532:	b120      	cbz	r0, 800153e <SPI_CheckFlag_BSY+0x1c>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
    return HAL_TIMEOUT;
 8001534:	2003      	movs	r0, #3
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8001536:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8001538:	f043 0320 	orr.w	r3, r3, #32
 800153c:	6563      	str	r3, [r4, #84]	; 0x54
  }
  return HAL_OK;
}
 800153e:	b002      	add	sp, #8
 8001540:	bd10      	pop	{r4, pc}

08001542 <HAL_SPI_Transmit>:
{
 8001542:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 8001546:	461e      	mov	r6, r3
  __HAL_LOCK(hspi);
 8001548:	f890 3050 	ldrb.w	r3, [r0, #80]	; 0x50
{
 800154c:	4604      	mov	r4, r0
  __HAL_LOCK(hspi);
 800154e:	2b01      	cmp	r3, #1
{
 8001550:	460d      	mov	r5, r1
 8001552:	4690      	mov	r8, r2
  __HAL_LOCK(hspi);
 8001554:	f000 809c 	beq.w	8001690 <HAL_SPI_Transmit+0x14e>
 8001558:	2301      	movs	r3, #1
 800155a:	f880 3050 	strb.w	r3, [r0, #80]	; 0x50
  tickstart = HAL_GetTick();
 800155e:	f7ff fbab 	bl	8000cb8 <HAL_GetTick>
 8001562:	4607      	mov	r7, r0
  if(hspi->State != HAL_SPI_STATE_READY)
 8001564:	f894 0051 	ldrb.w	r0, [r4, #81]	; 0x51
 8001568:	b2c0      	uxtb	r0, r0
 800156a:	2801      	cmp	r0, #1
 800156c:	f040 808e 	bne.w	800168c <HAL_SPI_Transmit+0x14a>
  if((pData == NULL ) || (Size == 0U))
 8001570:	2d00      	cmp	r5, #0
 8001572:	d04e      	beq.n	8001612 <HAL_SPI_Transmit+0xd0>
 8001574:	f1b8 0f00 	cmp.w	r8, #0
 8001578:	d04b      	beq.n	8001612 <HAL_SPI_Transmit+0xd0>
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 800157a:	2303      	movs	r3, #3
 800157c:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8001580:	2300      	movs	r3, #0
 8001582:	6563      	str	r3, [r4, #84]	; 0x54
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
 8001584:	63a3      	str	r3, [r4, #56]	; 0x38
  hspi->TxXferCount = Size;
 8001586:	f8a4 8036 	strh.w	r8, [r4, #54]	; 0x36
  hspi->RxXferSize  = 0U;
 800158a:	87a3      	strh	r3, [r4, #60]	; 0x3c
  hspi->RxXferCount = 0U;
 800158c:	87e3      	strh	r3, [r4, #62]	; 0x3e
  hspi->TxISR       = NULL;
 800158e:	6463      	str	r3, [r4, #68]	; 0x44
  hspi->RxISR       = NULL;
 8001590:	6423      	str	r3, [r4, #64]	; 0x40
  if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8001592:	68a3      	ldr	r3, [r4, #8]
  hspi->pTxBuffPtr  = (uint8_t *)pData;
 8001594:	6325      	str	r5, [r4, #48]	; 0x30
  if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8001596:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800159a:	6823      	ldr	r3, [r4, #0]
  hspi->TxXferSize  = Size;
 800159c:	f8a4 8034 	strh.w	r8, [r4, #52]	; 0x34
    SPI_1LINE_TX(hspi);
 80015a0:	bf02      	ittt	eq
 80015a2:	681a      	ldreq	r2, [r3, #0]
 80015a4:	f442 4280 	orreq.w	r2, r2, #16384	; 0x4000
 80015a8:	601a      	streq	r2, [r3, #0]
  if((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 80015aa:	681a      	ldr	r2, [r3, #0]
 80015ac:	0652      	lsls	r2, r2, #25
    __HAL_SPI_ENABLE(hspi);
 80015ae:	bf5e      	ittt	pl
 80015b0:	681a      	ldrpl	r2, [r3, #0]
 80015b2:	f042 0240 	orrpl.w	r2, r2, #64	; 0x40
 80015b6:	601a      	strpl	r2, [r3, #0]
  if(hspi->Init.DataSize == SPI_DATASIZE_16BIT)
 80015b8:	68e2      	ldr	r2, [r4, #12]
 80015ba:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
 80015be:	6862      	ldr	r2, [r4, #4]
 80015c0:	d138      	bne.n	8001634 <HAL_SPI_Transmit+0xf2>
    if((hspi->Init.Mode == SPI_MODE_SLAVE) || (hspi->TxXferCount == 0x01))
 80015c2:	b11a      	cbz	r2, 80015cc <HAL_SPI_Transmit+0x8a>
 80015c4:	8ee2      	ldrh	r2, [r4, #54]	; 0x36
 80015c6:	b292      	uxth	r2, r2
 80015c8:	2a01      	cmp	r2, #1
 80015ca:	d106      	bne.n	80015da <HAL_SPI_Transmit+0x98>
          hspi->Instance->DR = *((uint16_t *)pData);
 80015cc:	f835 2b02 	ldrh.w	r2, [r5], #2
 80015d0:	60da      	str	r2, [r3, #12]
          hspi->TxXferCount--;
 80015d2:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 80015d4:	3b01      	subs	r3, #1
 80015d6:	b29b      	uxth	r3, r3
 80015d8:	86e3      	strh	r3, [r4, #54]	; 0x36
    while (hspi->TxXferCount > 0U)
 80015da:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 80015dc:	b29b      	uxth	r3, r3
 80015de:	b993      	cbnz	r3, 8001606 <HAL_SPI_Transmit+0xc4>
  if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_TXE, SET, Timeout, tickstart) != HAL_OK)
 80015e0:	9700      	str	r7, [sp, #0]
 80015e2:	4633      	mov	r3, r6
 80015e4:	2201      	movs	r2, #1
 80015e6:	2102      	movs	r1, #2
 80015e8:	4620      	mov	r0, r4
 80015ea:	f7ff ff53 	bl	8001494 <SPI_WaitFlagStateUntilTimeout>
 80015ee:	b978      	cbnz	r0, 8001610 <HAL_SPI_Transmit+0xce>
  if(SPI_CheckFlag_BSY(hspi, Timeout, tickstart) != HAL_OK)
 80015f0:	463a      	mov	r2, r7
 80015f2:	4631      	mov	r1, r6
 80015f4:	4620      	mov	r0, r4
 80015f6:	f7ff ff94 	bl	8001522 <SPI_CheckFlag_BSY>
 80015fa:	2800      	cmp	r0, #0
 80015fc:	d038      	beq.n	8001670 <HAL_SPI_Transmit+0x12e>
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 80015fe:	2320      	movs	r3, #32
    errorcode = HAL_ERROR;
 8001600:	2001      	movs	r0, #1
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 8001602:	6563      	str	r3, [r4, #84]	; 0x54
    goto error;
 8001604:	e005      	b.n	8001612 <HAL_SPI_Transmit+0xd0>
      if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 8001606:	6823      	ldr	r3, [r4, #0]
 8001608:	689a      	ldr	r2, [r3, #8]
 800160a:	0790      	lsls	r0, r2, #30
 800160c:	d4de      	bmi.n	80015cc <HAL_SPI_Transmit+0x8a>
        if((Timeout == 0U) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick()-tickstart) >=  Timeout)))
 800160e:	b94e      	cbnz	r6, 8001624 <HAL_SPI_Transmit+0xe2>
          errorcode = HAL_TIMEOUT;
 8001610:	2003      	movs	r0, #3
  hspi->State = HAL_SPI_STATE_READY;
 8001612:	2301      	movs	r3, #1
 8001614:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
  __HAL_UNLOCK(hspi);
 8001618:	2300      	movs	r3, #0
 800161a:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
}
 800161e:	b004      	add	sp, #16
 8001620:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if((Timeout == 0U) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick()-tickstart) >=  Timeout)))
 8001624:	1c71      	adds	r1, r6, #1
 8001626:	d0d8      	beq.n	80015da <HAL_SPI_Transmit+0x98>
 8001628:	f7ff fb46 	bl	8000cb8 <HAL_GetTick>
 800162c:	1bc0      	subs	r0, r0, r7
 800162e:	4286      	cmp	r6, r0
 8001630:	d8d3      	bhi.n	80015da <HAL_SPI_Transmit+0x98>
 8001632:	e7ed      	b.n	8001610 <HAL_SPI_Transmit+0xce>
    if((hspi->Init.Mode == SPI_MODE_SLAVE)|| (hspi->TxXferCount == 0x01))
 8001634:	b11a      	cbz	r2, 800163e <HAL_SPI_Transmit+0xfc>
 8001636:	8ee2      	ldrh	r2, [r4, #54]	; 0x36
 8001638:	b292      	uxth	r2, r2
 800163a:	2a01      	cmp	r2, #1
 800163c:	d106      	bne.n	800164c <HAL_SPI_Transmit+0x10a>
        *((__IO uint8_t*)&hspi->Instance->DR) = (*pData);
 800163e:	f815 2b01 	ldrb.w	r2, [r5], #1
 8001642:	731a      	strb	r2, [r3, #12]
        hspi->TxXferCount--;
 8001644:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8001646:	3b01      	subs	r3, #1
 8001648:	b29b      	uxth	r3, r3
 800164a:	86e3      	strh	r3, [r4, #54]	; 0x36
    while (hspi->TxXferCount > 0U)
 800164c:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 800164e:	b29b      	uxth	r3, r3
 8001650:	2b00      	cmp	r3, #0
 8001652:	d0c5      	beq.n	80015e0 <HAL_SPI_Transmit+0x9e>
      if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 8001654:	6823      	ldr	r3, [r4, #0]
 8001656:	689a      	ldr	r2, [r3, #8]
 8001658:	0792      	lsls	r2, r2, #30
 800165a:	d4f0      	bmi.n	800163e <HAL_SPI_Transmit+0xfc>
        if((Timeout == 0U) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick()-tickstart) >=  Timeout)))
 800165c:	2e00      	cmp	r6, #0
 800165e:	d0d7      	beq.n	8001610 <HAL_SPI_Transmit+0xce>
 8001660:	1c73      	adds	r3, r6, #1
 8001662:	d0f3      	beq.n	800164c <HAL_SPI_Transmit+0x10a>
 8001664:	f7ff fb28 	bl	8000cb8 <HAL_GetTick>
 8001668:	1bc0      	subs	r0, r0, r7
 800166a:	4286      	cmp	r6, r0
 800166c:	d8ee      	bhi.n	800164c <HAL_SPI_Transmit+0x10a>
 800166e:	e7cf      	b.n	8001610 <HAL_SPI_Transmit+0xce>
  if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
 8001670:	68a3      	ldr	r3, [r4, #8]
 8001672:	b933      	cbnz	r3, 8001682 <HAL_SPI_Transmit+0x140>
    __HAL_SPI_CLEAR_OVRFLAG(hspi);
 8001674:	9303      	str	r3, [sp, #12]
 8001676:	6823      	ldr	r3, [r4, #0]
 8001678:	68da      	ldr	r2, [r3, #12]
 800167a:	9203      	str	r2, [sp, #12]
 800167c:	689b      	ldr	r3, [r3, #8]
 800167e:	9303      	str	r3, [sp, #12]
 8001680:	9b03      	ldr	r3, [sp, #12]
  if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8001682:	6d60      	ldr	r0, [r4, #84]	; 0x54
    errorcode = HAL_BUSY;
 8001684:	3000      	adds	r0, #0
 8001686:	bf18      	it	ne
 8001688:	2001      	movne	r0, #1
 800168a:	e7c2      	b.n	8001612 <HAL_SPI_Transmit+0xd0>
 800168c:	2002      	movs	r0, #2
 800168e:	e7c0      	b.n	8001612 <HAL_SPI_Transmit+0xd0>
  __HAL_LOCK(hspi);
 8001690:	2002      	movs	r0, #2
 8001692:	e7c4      	b.n	800161e <HAL_SPI_Transmit+0xdc>

08001694 <HAL_SPI_Init>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *                the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
 8001694:	b510      	push	{r4, lr}
  /* Check the SPI handle allocation */
  if(hspi == NULL)
 8001696:	4604      	mov	r4, r0
 8001698:	2800      	cmp	r0, #0
 800169a:	d034      	beq.n	8001706 <HAL_SPI_Init+0x72>
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
  }
#else
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 800169c:	2300      	movs	r3, #0
 800169e:	6283      	str	r3, [r0, #40]	; 0x28
#endif /* USE_SPI_CRC */

  if(hspi->State == HAL_SPI_STATE_RESET)
 80016a0:	f890 3051 	ldrb.w	r3, [r0, #81]	; 0x51
 80016a4:	b90b      	cbnz	r3, 80016aa <HAL_SPI_Init+0x16>
  {
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
 80016a6:	f7fe ff7f 	bl	80005a8 <HAL_SPI_MspInit>
  }
  
  hspi->State = HAL_SPI_STATE_BUSY;
 80016aa:	2302      	movs	r3, #2

  /* Disble the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 80016ac:	6821      	ldr	r1, [r4, #0]
  hspi->State = HAL_SPI_STATE_BUSY;
 80016ae:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
  __HAL_SPI_DISABLE(hspi);
 80016b2:	680b      	ldr	r3, [r1, #0]

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 80016b4:	68a0      	ldr	r0, [r4, #8]
  __HAL_SPI_DISABLE(hspi);
 80016b6:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80016ba:	600b      	str	r3, [r1, #0]
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 80016bc:	6863      	ldr	r3, [r4, #4]
 80016be:	69a2      	ldr	r2, [r4, #24]
 80016c0:	4303      	orrs	r3, r0
 80016c2:	68e0      	ldr	r0, [r4, #12]
 80016c4:	4303      	orrs	r3, r0
 80016c6:	6920      	ldr	r0, [r4, #16]
 80016c8:	4303      	orrs	r3, r0
 80016ca:	6960      	ldr	r0, [r4, #20]
 80016cc:	4303      	orrs	r3, r0
 80016ce:	69e0      	ldr	r0, [r4, #28]
 80016d0:	4303      	orrs	r3, r0
 80016d2:	6a20      	ldr	r0, [r4, #32]
 80016d4:	4303      	orrs	r3, r0
 80016d6:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80016d8:	4303      	orrs	r3, r0
 80016da:	f402 7000 	and.w	r0, r2, #512	; 0x200
 80016de:	4303      	orrs	r3, r0
 80016e0:	600b      	str	r3, [r1, #0]
                                  hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
                                  hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation) );

  /* Configure : NSS management */
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode));
 80016e2:	0c12      	lsrs	r2, r2, #16
 80016e4:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80016e6:	f002 0204 	and.w	r2, r2, #4
 80016ea:	431a      	orrs	r2, r3

  /*---------------------------- SPIx CRCPOLY Configuration ------------------*/
  /* Configure : CRC Polynomial */
  WRITE_REG(hspi->Instance->CRCPR, hspi->Init.CRCPolynomial);
 80016ec:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode));
 80016ee:	604a      	str	r2, [r1, #4]
  WRITE_REG(hspi->Instance->CRCPR, hspi->Init.CRCPolynomial);
 80016f0:	610b      	str	r3, [r1, #16]

#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 80016f2:	69cb      	ldr	r3, [r1, #28]
#else
  uCRCErrorWorkaroundCheck = 0U;
#endif /* STM32F101xE || STM32F103xE */
#endif /* USE_SPI_CRC */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 80016f4:	2000      	movs	r0, #0
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 80016f6:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 80016fa:	61cb      	str	r3, [r1, #28]
  hspi->State = HAL_SPI_STATE_READY;
 80016fc:	2301      	movs	r3, #1
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 80016fe:	6560      	str	r0, [r4, #84]	; 0x54
  hspi->State = HAL_SPI_STATE_READY;
 8001700:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
  
  return HAL_OK;
 8001704:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 8001706:	2001      	movs	r0, #1
}
 8001708:	bd10      	pop	{r4, pc}

0800170a <HAL_TIM_Encoder_Start>:
  *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
  *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
  * @retval HAL status
*/
HAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
{
 800170a:	6803      	ldr	r3, [r0, #0]
  /* Check the parameters */
  assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));

  /* Enable the encoder interface channels */
  switch (Channel)
 800170c:	b189      	cbz	r1, 8001732 <HAL_TIM_Encoder_Start+0x28>
 800170e:	2904      	cmp	r1, #4
 8001710:	d007      	beq.n	8001722 <HAL_TIM_Encoder_Start+0x18>
  assert_param(IS_TIM_CHANNELS(Channel));

  tmp = TIM_CCER_CC1E << Channel;

  /* Reset the CCxE Bit */
  TIMx->CCER &= ~tmp;
 8001712:	6a1a      	ldr	r2, [r3, #32]
 8001714:	f022 0201 	bic.w	r2, r2, #1
 8001718:	621a      	str	r2, [r3, #32]

  /* Set or reset the CCxE Bit */
  TIMx->CCER |=  (uint32_t)(ChannelState << Channel);
 800171a:	6a1a      	ldr	r2, [r3, #32]
 800171c:	f042 0201 	orr.w	r2, r2, #1
 8001720:	621a      	str	r2, [r3, #32]
  TIMx->CCER &= ~tmp;
 8001722:	6a1a      	ldr	r2, [r3, #32]
 8001724:	f022 0210 	bic.w	r2, r2, #16
 8001728:	621a      	str	r2, [r3, #32]
  TIMx->CCER |=  (uint32_t)(ChannelState << Channel);
 800172a:	6a1a      	ldr	r2, [r3, #32]
 800172c:	f042 0210 	orr.w	r2, r2, #16
 8001730:	e006      	b.n	8001740 <HAL_TIM_Encoder_Start+0x36>
  TIMx->CCER &= ~tmp;
 8001732:	6a1a      	ldr	r2, [r3, #32]
 8001734:	f022 0201 	bic.w	r2, r2, #1
 8001738:	621a      	str	r2, [r3, #32]
  TIMx->CCER |=  (uint32_t)(ChannelState << Channel);
 800173a:	6a1a      	ldr	r2, [r3, #32]
 800173c:	f042 0201 	orr.w	r2, r2, #1
 8001740:	621a      	str	r2, [r3, #32]
  __HAL_TIM_ENABLE(htim);
 8001742:	681a      	ldr	r2, [r3, #0]
}
 8001744:	2000      	movs	r0, #0
  __HAL_TIM_ENABLE(htim);
 8001746:	f042 0201 	orr.w	r2, r2, #1
 800174a:	601a      	str	r2, [r3, #0]
}
 800174c:	4770      	bx	lr
	...

08001750 <TIM_Base_SetConfig>:
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8001750:	4a24      	ldr	r2, [pc, #144]	; (80017e4 <TIM_Base_SetConfig+0x94>)
  tmpcr1 = TIMx->CR1;
 8001752:	6803      	ldr	r3, [r0, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8001754:	4290      	cmp	r0, r2
 8001756:	d012      	beq.n	800177e <TIM_Base_SetConfig+0x2e>
 8001758:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 800175c:	4290      	cmp	r0, r2
 800175e:	d00e      	beq.n	800177e <TIM_Base_SetConfig+0x2e>
 8001760:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8001764:	d00b      	beq.n	800177e <TIM_Base_SetConfig+0x2e>
 8001766:	f5a2 3298 	sub.w	r2, r2, #77824	; 0x13000
 800176a:	4290      	cmp	r0, r2
 800176c:	d007      	beq.n	800177e <TIM_Base_SetConfig+0x2e>
 800176e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001772:	4290      	cmp	r0, r2
 8001774:	d003      	beq.n	800177e <TIM_Base_SetConfig+0x2e>
 8001776:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800177a:	4290      	cmp	r0, r2
 800177c:	d11d      	bne.n	80017ba <TIM_Base_SetConfig+0x6a>
    tmpcr1 |= Structure->CounterMode;
 800177e:	684a      	ldr	r2, [r1, #4]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8001780:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8001784:	4313      	orrs	r3, r2
  if(IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8001786:	4a17      	ldr	r2, [pc, #92]	; (80017e4 <TIM_Base_SetConfig+0x94>)
 8001788:	4290      	cmp	r0, r2
 800178a:	d012      	beq.n	80017b2 <TIM_Base_SetConfig+0x62>
 800178c:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 8001790:	4290      	cmp	r0, r2
 8001792:	d00e      	beq.n	80017b2 <TIM_Base_SetConfig+0x62>
 8001794:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8001798:	d00b      	beq.n	80017b2 <TIM_Base_SetConfig+0x62>
 800179a:	f5a2 3298 	sub.w	r2, r2, #77824	; 0x13000
 800179e:	4290      	cmp	r0, r2
 80017a0:	d007      	beq.n	80017b2 <TIM_Base_SetConfig+0x62>
 80017a2:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80017a6:	4290      	cmp	r0, r2
 80017a8:	d003      	beq.n	80017b2 <TIM_Base_SetConfig+0x62>
 80017aa:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80017ae:	4290      	cmp	r0, r2
 80017b0:	d103      	bne.n	80017ba <TIM_Base_SetConfig+0x6a>
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80017b2:	68ca      	ldr	r2, [r1, #12]
    tmpcr1 &= ~TIM_CR1_CKD;
 80017b4:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80017b8:	4313      	orrs	r3, r2
  tmpcr1 |= (uint32_t)Structure->AutoReloadPreload;
 80017ba:	694a      	ldr	r2, [r1, #20]
  tmpcr1 &= ~TIM_CR1_ARPE;
 80017bc:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  tmpcr1 |= (uint32_t)Structure->AutoReloadPreload;
 80017c0:	4313      	orrs	r3, r2
  TIMx->CR1 = tmpcr1;
 80017c2:	6003      	str	r3, [r0, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 80017c4:	688b      	ldr	r3, [r1, #8]
 80017c6:	62c3      	str	r3, [r0, #44]	; 0x2c
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 80017c8:	680b      	ldr	r3, [r1, #0]
 80017ca:	6283      	str	r3, [r0, #40]	; 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 80017cc:	4b05      	ldr	r3, [pc, #20]	; (80017e4 <TIM_Base_SetConfig+0x94>)
 80017ce:	4298      	cmp	r0, r3
 80017d0:	d003      	beq.n	80017da <TIM_Base_SetConfig+0x8a>
 80017d2:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 80017d6:	4298      	cmp	r0, r3
 80017d8:	d101      	bne.n	80017de <TIM_Base_SetConfig+0x8e>
    TIMx->RCR = Structure->RepetitionCounter;
 80017da:	690b      	ldr	r3, [r1, #16]
 80017dc:	6303      	str	r3, [r0, #48]	; 0x30
  TIMx->EGR = TIM_EGR_UG;
 80017de:	2301      	movs	r3, #1
 80017e0:	6143      	str	r3, [r0, #20]
 80017e2:	4770      	bx	lr
 80017e4:	40012c00 	.word	0x40012c00

080017e8 <HAL_TIM_Encoder_Init>:
{
 80017e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80017ea:	460c      	mov	r4, r1
  if(htim == NULL)
 80017ec:	4605      	mov	r5, r0
 80017ee:	2800      	cmp	r0, #0
 80017f0:	d041      	beq.n	8001876 <HAL_TIM_Encoder_Init+0x8e>
  if(htim->State == HAL_TIM_STATE_RESET)
 80017f2:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 80017f6:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80017fa:	b91b      	cbnz	r3, 8001804 <HAL_TIM_Encoder_Init+0x1c>
    htim->Lock = HAL_UNLOCKED;
 80017fc:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
    HAL_TIM_Encoder_MspInit(htim);
 8001800:	f7fe fef4 	bl	80005ec <HAL_TIM_Encoder_MspInit>
  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
 8001804:	4629      	mov	r1, r5
  htim->State= HAL_TIM_STATE_BUSY;
 8001806:	2302      	movs	r3, #2
  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
 8001808:	f851 0b04 	ldr.w	r0, [r1], #4
  htim->State= HAL_TIM_STATE_BUSY;
 800180c:	f885 303d 	strb.w	r3, [r5, #61]	; 0x3d
  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
 8001810:	6883      	ldr	r3, [r0, #8]
 8001812:	f023 0307 	bic.w	r3, r3, #7
 8001816:	6083      	str	r3, [r0, #8]
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8001818:	f7ff ff9a 	bl	8001750 <TIM_Base_SetConfig>
  tmpsmcr = htim->Instance->SMCR;
 800181c:	6828      	ldr	r0, [r5, #0]
  tmpsmcr |= sConfig->EncoderMode;
 800181e:	6823      	ldr	r3, [r4, #0]
  tmpsmcr = htim->Instance->SMCR;
 8001820:	6886      	ldr	r6, [r0, #8]
  tmpccmr1 = htim->Instance->CCMR1;
 8001822:	6982      	ldr	r2, [r0, #24]
  tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8U));
 8001824:	68a1      	ldr	r1, [r4, #8]
  tmpsmcr |= sConfig->EncoderMode;
 8001826:	431e      	orrs	r6, r3
  tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8U));
 8001828:	69a3      	ldr	r3, [r4, #24]
  tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
 800182a:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 800182e:	f022 0203 	bic.w	r2, r2, #3
  tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8U));
 8001832:	ea41 2303 	orr.w	r3, r1, r3, lsl #8
 8001836:	4313      	orrs	r3, r2
  tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
 8001838:	f423 427c 	bic.w	r2, r3, #64512	; 0xfc00
  tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
 800183c:	6923      	ldr	r3, [r4, #16]
  tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8U);
 800183e:	69e1      	ldr	r1, [r4, #28]
  tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
 8001840:	011b      	lsls	r3, r3, #4
 8001842:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8001846:	68e1      	ldr	r1, [r4, #12]
  tmpccer = htim->Instance->CCER;
 8001848:	6a07      	ldr	r7, [r0, #32]
  tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
 800184a:	430b      	orrs	r3, r1
 800184c:	6a21      	ldr	r1, [r4, #32]
  tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
 800184e:	f022 02fc 	bic.w	r2, r2, #252	; 0xfc
  tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
 8001852:	ea43 3301 	orr.w	r3, r3, r1, lsl #12
 8001856:	4313      	orrs	r3, r2
  tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4U);
 8001858:	6961      	ldr	r1, [r4, #20]
  tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
 800185a:	f027 02aa 	bic.w	r2, r7, #170	; 0xaa
  tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4U);
 800185e:	6867      	ldr	r7, [r4, #4]
  htim->Instance->SMCR = tmpsmcr;
 8001860:	6086      	str	r6, [r0, #8]
  htim->Instance->CCMR1 = tmpccmr1;
 8001862:	6183      	str	r3, [r0, #24]
  htim->State= HAL_TIM_STATE_READY;
 8001864:	2301      	movs	r3, #1
  tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4U);
 8001866:	ea47 1701 	orr.w	r7, r7, r1, lsl #4
 800186a:	4317      	orrs	r7, r2
  htim->Instance->CCER = tmpccer;
 800186c:	6207      	str	r7, [r0, #32]
  htim->State= HAL_TIM_STATE_READY;
 800186e:	f885 303d 	strb.w	r3, [r5, #61]	; 0x3d
  return HAL_OK;
 8001872:	2000      	movs	r0, #0
 8001874:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_ERROR;
 8001876:	2001      	movs	r0, #1
}
 8001878:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0800187a <HAL_TIMEx_MasterConfigSynchronization>:
  /* Check the parameters */
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  __HAL_LOCK(htim);
 800187a:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
{
 800187e:	b510      	push	{r4, lr}
  __HAL_LOCK(htim);
 8001880:	2b01      	cmp	r3, #1
 8001882:	f04f 0302 	mov.w	r3, #2
 8001886:	d018      	beq.n	80018ba <HAL_TIMEx_MasterConfigSynchronization+0x40>

  htim->State = HAL_TIM_STATE_BUSY;
 8001888:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d

  /* Reset the MMS Bits */
  htim->Instance->CR2 &= ~TIM_CR2_MMS;
 800188c:	6803      	ldr	r3, [r0, #0]
  /* Select the TRGO source */
  htim->Instance->CR2 |=  sMasterConfig->MasterOutputTrigger;
 800188e:	680c      	ldr	r4, [r1, #0]
  htim->Instance->CR2 &= ~TIM_CR2_MMS;
 8001890:	685a      	ldr	r2, [r3, #4]

  /* Reset the MSM Bit */
  htim->Instance->SMCR &= ~TIM_SMCR_MSM;
  /* Set or Reset the MSM Bit */
  htim->Instance->SMCR |= sMasterConfig->MasterSlaveMode;
 8001892:	6849      	ldr	r1, [r1, #4]
  htim->Instance->CR2 &= ~TIM_CR2_MMS;
 8001894:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 8001898:	605a      	str	r2, [r3, #4]
  htim->Instance->CR2 |=  sMasterConfig->MasterOutputTrigger;
 800189a:	685a      	ldr	r2, [r3, #4]
 800189c:	4322      	orrs	r2, r4
 800189e:	605a      	str	r2, [r3, #4]
  htim->Instance->SMCR &= ~TIM_SMCR_MSM;
 80018a0:	689a      	ldr	r2, [r3, #8]
 80018a2:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 80018a6:	609a      	str	r2, [r3, #8]
  htim->Instance->SMCR |= sMasterConfig->MasterSlaveMode;
 80018a8:	689a      	ldr	r2, [r3, #8]
 80018aa:	430a      	orrs	r2, r1
 80018ac:	609a      	str	r2, [r3, #8]

  htim->State = HAL_TIM_STATE_READY;
 80018ae:	2301      	movs	r3, #1
 80018b0:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d

  __HAL_UNLOCK(htim);
 80018b4:	2300      	movs	r3, #0
 80018b6:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  __HAL_LOCK(htim);
 80018ba:	4618      	mov	r0, r3

  return HAL_OK;
}
 80018bc:	bd10      	pop	{r4, pc}

080018be <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80018be:	f100 0308 	add.w	r3, r0, #8
 80018c2:	6043      	str	r3, [r0, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 80018c4:	f04f 32ff 	mov.w	r2, #4294967295

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80018c8:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80018ca:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 80018cc:	2300      	movs	r3, #0
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 80018ce:	6082      	str	r2, [r0, #8]
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 80018d0:	6003      	str	r3, [r0, #0]
 80018d2:	4770      	bx	lr

080018d4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 80018d4:	2300      	movs	r3, #0
 80018d6:	6103      	str	r3, [r0, #16]
 80018d8:	4770      	bx	lr

080018da <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 80018da:	6843      	ldr	r3, [r0, #4]

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 80018dc:	689a      	ldr	r2, [r3, #8]
	pxNewListItem->pxNext = pxIndex;
 80018de:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 80018e0:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 80018e2:	689a      	ldr	r2, [r3, #8]
 80018e4:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
 80018e6:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 80018e8:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = ( void * ) pxList;
 80018ea:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 80018ec:	3301      	adds	r3, #1
 80018ee:	6003      	str	r3, [r0, #0]
 80018f0:	4770      	bx	lr

080018f2 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 80018f2:	680a      	ldr	r2, [r1, #0]
{
 80018f4:	b530      	push	{r4, r5, lr}
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 80018f6:	1c53      	adds	r3, r2, #1
 80018f8:	d10a      	bne.n	8001910 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 80018fa:	6903      	ldr	r3, [r0, #16]
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 80018fc:	685a      	ldr	r2, [r3, #4]
 80018fe:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 8001900:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious = pxIterator;
 8001902:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 8001904:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8001906:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = ( void * ) pxList;
 8001908:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 800190a:	3301      	adds	r3, #1
 800190c:	6003      	str	r3, [r0, #0]
 800190e:	bd30      	pop	{r4, r5, pc}
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8001910:	f100 0308 	add.w	r3, r0, #8
 8001914:	685c      	ldr	r4, [r3, #4]
 8001916:	6825      	ldr	r5, [r4, #0]
 8001918:	42aa      	cmp	r2, r5
 800191a:	d3ef      	bcc.n	80018fc <vListInsert+0xa>
 800191c:	4623      	mov	r3, r4
 800191e:	e7f9      	b.n	8001914 <vListInsert+0x22>

08001920 <uxListRemove>:
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8001920:	6841      	ldr	r1, [r0, #4]
 8001922:	6882      	ldr	r2, [r0, #8]
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 8001924:	6903      	ldr	r3, [r0, #16]
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8001926:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8001928:	6882      	ldr	r2, [r0, #8]
 800192a:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 800192c:	6859      	ldr	r1, [r3, #4]
 800192e:	4288      	cmp	r0, r1
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8001930:	bf08      	it	eq
 8001932:	605a      	streq	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 8001934:	2200      	movs	r2, #0
 8001936:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 8001938:	681a      	ldr	r2, [r3, #0]
 800193a:	3a01      	subs	r2, #1
 800193c:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
 800193e:	6818      	ldr	r0, [r3, #0]
}
 8001940:	4770      	bx	lr
	...

08001944 <prvTaskExitError>:
}
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
	volatile uint32_t ulDummy = 0UL;
 8001944:	2300      	movs	r3, #0
{
 8001946:	b082      	sub	sp, #8
	volatile uint32_t ulDummy = 0UL;
 8001948:	9301      	str	r3, [sp, #4]
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
 800194a:	4b0d      	ldr	r3, [pc, #52]	; (8001980 <prvTaskExitError+0x3c>)
 800194c:	681b      	ldr	r3, [r3, #0]
 800194e:	3301      	adds	r3, #1
 8001950:	d008      	beq.n	8001964 <prvTaskExitError+0x20>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 8001952:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001956:	f383 8811 	msr	BASEPRI, r3
 800195a:	f3bf 8f6f 	isb	sy
 800195e:	f3bf 8f4f 	dsb	sy
 8001962:	e7fe      	b.n	8001962 <prvTaskExitError+0x1e>
 8001964:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001968:	f383 8811 	msr	BASEPRI, r3
 800196c:	f3bf 8f6f 	isb	sy
 8001970:	f3bf 8f4f 	dsb	sy
	portDISABLE_INTERRUPTS();
	while( ulDummy == 0 )
 8001974:	9b01      	ldr	r3, [sp, #4]
 8001976:	2b00      	cmp	r3, #0
 8001978:	d0fc      	beq.n	8001974 <prvTaskExitError+0x30>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
 800197a:	b002      	add	sp, #8
 800197c:	4770      	bx	lr
 800197e:	bf00      	nop
 8001980:	20000010 	.word	0x20000010

08001984 <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
 8001984:	4806      	ldr	r0, [pc, #24]	; (80019a0 <prvPortStartFirstTask+0x1c>)
 8001986:	6800      	ldr	r0, [r0, #0]
 8001988:	6800      	ldr	r0, [r0, #0]
 800198a:	f380 8808 	msr	MSP, r0
 800198e:	b662      	cpsie	i
 8001990:	b661      	cpsie	f
 8001992:	f3bf 8f4f 	dsb	sy
 8001996:	f3bf 8f6f 	isb	sy
 800199a:	df00      	svc	0
 800199c:	bf00      	nop
 800199e:	0000      	.short	0x0000
 80019a0:	e000ed08 	.word	0xe000ed08

080019a4 <pxPortInitialiseStack>:
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 80019a4:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 80019a8:	f840 3c04 	str.w	r3, [r0, #-4]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 80019ac:	4b05      	ldr	r3, [pc, #20]	; (80019c4 <pxPortInitialiseStack+0x20>)
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 80019ae:	f021 0101 	bic.w	r1, r1, #1
 80019b2:	f840 1c08 	str.w	r1, [r0, #-8]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 80019b6:	f840 3c0c 	str.w	r3, [r0, #-12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 80019ba:	f840 2c20 	str.w	r2, [r0, #-32]
}
 80019be:	3840      	subs	r0, #64	; 0x40
 80019c0:	4770      	bx	lr
 80019c2:	bf00      	nop
 80019c4:	08001945 	.word	0x08001945
	...

080019d0 <SVC_Handler>:
	__asm volatile(
 80019d0:	4b07      	ldr	r3, [pc, #28]	; (80019f0 <pxCurrentTCBConst2>)
 80019d2:	6819      	ldr	r1, [r3, #0]
 80019d4:	6808      	ldr	r0, [r1, #0]
 80019d6:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 80019da:	f380 8809 	msr	PSP, r0
 80019de:	f3bf 8f6f 	isb	sy
 80019e2:	f04f 0000 	mov.w	r0, #0
 80019e6:	f380 8811 	msr	BASEPRI, r0
 80019ea:	f04e 0e0d 	orr.w	lr, lr, #13
 80019ee:	4770      	bx	lr

080019f0 <pxCurrentTCBConst2>:
 80019f0:	20003d18 	.word	0x20003d18

080019f4 <vPortEnterCritical>:
 80019f4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80019f8:	f383 8811 	msr	BASEPRI, r3
 80019fc:	f3bf 8f6f 	isb	sy
 8001a00:	f3bf 8f4f 	dsb	sy
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
	portDISABLE_INTERRUPTS();
	uxCriticalNesting++;
 8001a04:	4a0a      	ldr	r2, [pc, #40]	; (8001a30 <vPortEnterCritical+0x3c>)
 8001a06:	6813      	ldr	r3, [r2, #0]
 8001a08:	3301      	adds	r3, #1
	/* This is not the interrupt safe version of the enter critical function so
	assert() if it is being called from an interrupt context.  Only API
	functions that end in "FromISR" can be used in an interrupt.  Only assert if
	the critical nesting count is 1 to protect against recursive calls if the
	assert function also uses a critical section. */
	if( uxCriticalNesting == 1 )
 8001a0a:	2b01      	cmp	r3, #1
	uxCriticalNesting++;
 8001a0c:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 1 )
 8001a0e:	d10d      	bne.n	8001a2c <vPortEnterCritical+0x38>
	{
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
 8001a10:	4b08      	ldr	r3, [pc, #32]	; (8001a34 <vPortEnterCritical+0x40>)
 8001a12:	681b      	ldr	r3, [r3, #0]
 8001a14:	f013 0fff 	tst.w	r3, #255	; 0xff
 8001a18:	d008      	beq.n	8001a2c <vPortEnterCritical+0x38>
 8001a1a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001a1e:	f383 8811 	msr	BASEPRI, r3
 8001a22:	f3bf 8f6f 	isb	sy
 8001a26:	f3bf 8f4f 	dsb	sy
 8001a2a:	e7fe      	b.n	8001a2a <vPortEnterCritical+0x36>
 8001a2c:	4770      	bx	lr
 8001a2e:	bf00      	nop
 8001a30:	20000010 	.word	0x20000010
 8001a34:	e000ed04 	.word	0xe000ed04

08001a38 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
	configASSERT( uxCriticalNesting );
 8001a38:	4a08      	ldr	r2, [pc, #32]	; (8001a5c <vPortExitCritical+0x24>)
 8001a3a:	6813      	ldr	r3, [r2, #0]
 8001a3c:	b943      	cbnz	r3, 8001a50 <vPortExitCritical+0x18>
 8001a3e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001a42:	f383 8811 	msr	BASEPRI, r3
 8001a46:	f3bf 8f6f 	isb	sy
 8001a4a:	f3bf 8f4f 	dsb	sy
 8001a4e:	e7fe      	b.n	8001a4e <vPortExitCritical+0x16>
	uxCriticalNesting--;
 8001a50:	3b01      	subs	r3, #1
 8001a52:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 8001a54:	b90b      	cbnz	r3, 8001a5a <vPortExitCritical+0x22>
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 8001a56:	f383 8811 	msr	BASEPRI, r3
 8001a5a:	4770      	bx	lr
 8001a5c:	20000010 	.word	0x20000010

08001a60 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 8001a60:	f3ef 8009 	mrs	r0, PSP
 8001a64:	f3bf 8f6f 	isb	sy
 8001a68:	4b0d      	ldr	r3, [pc, #52]	; (8001aa0 <pxCurrentTCBConst>)
 8001a6a:	681a      	ldr	r2, [r3, #0]
 8001a6c:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8001a70:	6010      	str	r0, [r2, #0]
 8001a72:	e92d 4008 	stmdb	sp!, {r3, lr}
 8001a76:	f04f 0050 	mov.w	r0, #80	; 0x50
 8001a7a:	f380 8811 	msr	BASEPRI, r0
 8001a7e:	f000 ffcf 	bl	8002a20 <vTaskSwitchContext>
 8001a82:	f04f 0000 	mov.w	r0, #0
 8001a86:	f380 8811 	msr	BASEPRI, r0
 8001a8a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8001a8e:	6819      	ldr	r1, [r3, #0]
 8001a90:	6808      	ldr	r0, [r1, #0]
 8001a92:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8001a96:	f380 8809 	msr	PSP, r0
 8001a9a:	f3bf 8f6f 	isb	sy
 8001a9e:	4770      	bx	lr

08001aa0 <pxCurrentTCBConst>:
 8001aa0:	20003d18 	.word	0x20003d18

08001aa4 <xPortSysTickHandler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 8001aa4:	b508      	push	{r3, lr}
	__asm volatile
 8001aa6:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001aaa:	f383 8811 	msr	BASEPRI, r3
 8001aae:	f3bf 8f6f 	isb	sy
 8001ab2:	f3bf 8f4f 	dsb	sy
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
 8001ab6:	f000 fe85 	bl	80027c4 <xTaskIncrementTick>
 8001aba:	b118      	cbz	r0, 8001ac4 <xPortSysTickHandler+0x20>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 8001abc:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8001ac0:	4b02      	ldr	r3, [pc, #8]	; (8001acc <xPortSysTickHandler+0x28>)
 8001ac2:	601a      	str	r2, [r3, #0]
	__asm volatile
 8001ac4:	2300      	movs	r3, #0
 8001ac6:	f383 8811 	msr	BASEPRI, r3
 8001aca:	bd08      	pop	{r3, pc}
 8001acc:	e000ed04 	.word	0xe000ed04

08001ad0 <vPortSetupTimerInterrupt>:
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Stop and clear the SysTick. */
	portNVIC_SYSTICK_CTRL_REG = 0UL;
 8001ad0:	2200      	movs	r2, #0
 8001ad2:	4b05      	ldr	r3, [pc, #20]	; (8001ae8 <vPortSetupTimerInterrupt+0x18>)
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 8001ad4:	4905      	ldr	r1, [pc, #20]	; (8001aec <vPortSetupTimerInterrupt+0x1c>)
	portNVIC_SYSTICK_CTRL_REG = 0UL;
 8001ad6:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 8001ad8:	600a      	str	r2, [r1, #0]

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8001ada:	4a05      	ldr	r2, [pc, #20]	; (8001af0 <vPortSetupTimerInterrupt+0x20>)
 8001adc:	4905      	ldr	r1, [pc, #20]	; (8001af4 <vPortSetupTimerInterrupt+0x24>)
 8001ade:	6011      	str	r1, [r2, #0]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 8001ae0:	2207      	movs	r2, #7
 8001ae2:	601a      	str	r2, [r3, #0]
 8001ae4:	4770      	bx	lr
 8001ae6:	bf00      	nop
 8001ae8:	e000e010 	.word	0xe000e010
 8001aec:	e000e018 	.word	0xe000e018
 8001af0:	e000e014 	.word	0xe000e014
 8001af4:	0001193f 	.word	0x0001193f

08001af8 <xPortStartScheduler>:
{
 8001af8:	b513      	push	{r0, r1, r4, lr}
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 8001afa:	4b27      	ldr	r3, [pc, #156]	; (8001b98 <xPortStartScheduler+0xa0>)
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8001afc:	2100      	movs	r1, #0
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 8001afe:	781a      	ldrb	r2, [r3, #0]
 8001b00:	b2d2      	uxtb	r2, r2
 8001b02:	9201      	str	r2, [sp, #4]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 8001b04:	22ff      	movs	r2, #255	; 0xff
 8001b06:	701a      	strb	r2, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 8001b08:	781b      	ldrb	r3, [r3, #0]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8001b0a:	4a24      	ldr	r2, [pc, #144]	; (8001b9c <xPortStartScheduler+0xa4>)
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 8001b0c:	b2db      	uxtb	r3, r3
 8001b0e:	f88d 3003 	strb.w	r3, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8001b12:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001b16:	f003 0350 	and.w	r3, r3, #80	; 0x50
 8001b1a:	7013      	strb	r3, [r2, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 8001b1c:	2207      	movs	r2, #7
 8001b1e:	4b20      	ldr	r3, [pc, #128]	; (8001ba0 <xPortStartScheduler+0xa8>)
 8001b20:	601a      	str	r2, [r3, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8001b22:	f89d 0003 	ldrb.w	r0, [sp, #3]
 8001b26:	1e54      	subs	r4, r2, #1
 8001b28:	0600      	lsls	r0, r0, #24
 8001b2a:	d40d      	bmi.n	8001b48 <xPortStartScheduler+0x50>
 8001b2c:	b101      	cbz	r1, 8001b30 <xPortStartScheduler+0x38>
 8001b2e:	601a      	str	r2, [r3, #0]
			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
 8001b30:	681a      	ldr	r2, [r3, #0]
 8001b32:	2a03      	cmp	r2, #3
 8001b34:	d011      	beq.n	8001b5a <xPortStartScheduler+0x62>
	__asm volatile
 8001b36:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001b3a:	f383 8811 	msr	BASEPRI, r3
 8001b3e:	f3bf 8f6f 	isb	sy
 8001b42:	f3bf 8f4f 	dsb	sy
 8001b46:	e7fe      	b.n	8001b46 <xPortStartScheduler+0x4e>
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 8001b48:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8001b4c:	2101      	movs	r1, #1
 8001b4e:	0052      	lsls	r2, r2, #1
 8001b50:	b2d2      	uxtb	r2, r2
 8001b52:	f88d 2003 	strb.w	r2, [sp, #3]
 8001b56:	4622      	mov	r2, r4
 8001b58:	e7e3      	b.n	8001b22 <xPortStartScheduler+0x2a>
	uxCriticalNesting = 0;
 8001b5a:	2400      	movs	r4, #0
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
 8001b5c:	0212      	lsls	r2, r2, #8
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 8001b5e:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 8001b62:	601a      	str	r2, [r3, #0]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 8001b64:	9b01      	ldr	r3, [sp, #4]
 8001b66:	4a0c      	ldr	r2, [pc, #48]	; (8001b98 <xPortStartScheduler+0xa0>)
 8001b68:	b2db      	uxtb	r3, r3
 8001b6a:	7013      	strb	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 8001b6c:	4b0d      	ldr	r3, [pc, #52]	; (8001ba4 <xPortStartScheduler+0xac>)
 8001b6e:	681a      	ldr	r2, [r3, #0]
 8001b70:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 8001b74:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 8001b76:	681a      	ldr	r2, [r3, #0]
 8001b78:	f042 4270 	orr.w	r2, r2, #4026531840	; 0xf0000000
 8001b7c:	601a      	str	r2, [r3, #0]
	vPortSetupTimerInterrupt();
 8001b7e:	f7ff ffa7 	bl	8001ad0 <vPortSetupTimerInterrupt>
	uxCriticalNesting = 0;
 8001b82:	4b09      	ldr	r3, [pc, #36]	; (8001ba8 <xPortStartScheduler+0xb0>)
 8001b84:	601c      	str	r4, [r3, #0]
	prvPortStartFirstTask();
 8001b86:	f7ff fefd 	bl	8001984 <prvPortStartFirstTask>
	vTaskSwitchContext();
 8001b8a:	f000 ff49 	bl	8002a20 <vTaskSwitchContext>
	prvTaskExitError();
 8001b8e:	f7ff fed9 	bl	8001944 <prvTaskExitError>
}
 8001b92:	4620      	mov	r0, r4
 8001b94:	b002      	add	sp, #8
 8001b96:	bd10      	pop	{r4, pc}
 8001b98:	e000e400 	.word	0xe000e400
 8001b9c:	200020f8 	.word	0x200020f8
 8001ba0:	200020fc 	.word	0x200020fc
 8001ba4:	e000ed20 	.word	0xe000ed20
 8001ba8:	20000010 	.word	0x20000010

08001bac <vPortValidateInterruptPriority>:
	{
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
 8001bac:	f3ef 8305 	mrs	r3, IPSR

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
 8001bb0:	2b0f      	cmp	r3, #15
 8001bb2:	d90e      	bls.n	8001bd2 <vPortValidateInterruptPriority+0x26>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 8001bb4:	4a10      	ldr	r2, [pc, #64]	; (8001bf8 <vPortValidateInterruptPriority+0x4c>)
 8001bb6:	5c9b      	ldrb	r3, [r3, r2]
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 8001bb8:	4a10      	ldr	r2, [pc, #64]	; (8001bfc <vPortValidateInterruptPriority+0x50>)
 8001bba:	7812      	ldrb	r2, [r2, #0]
 8001bbc:	429a      	cmp	r2, r3
 8001bbe:	d908      	bls.n	8001bd2 <vPortValidateInterruptPriority+0x26>
 8001bc0:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001bc4:	f383 8811 	msr	BASEPRI, r3
 8001bc8:	f3bf 8f6f 	isb	sy
 8001bcc:	f3bf 8f4f 	dsb	sy
 8001bd0:	e7fe      	b.n	8001bd0 <vPortValidateInterruptPriority+0x24>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredictable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 8001bd2:	4b0b      	ldr	r3, [pc, #44]	; (8001c00 <vPortValidateInterruptPriority+0x54>)
 8001bd4:	4a0b      	ldr	r2, [pc, #44]	; (8001c04 <vPortValidateInterruptPriority+0x58>)
 8001bd6:	681b      	ldr	r3, [r3, #0]
 8001bd8:	6812      	ldr	r2, [r2, #0]
 8001bda:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8001bde:	4293      	cmp	r3, r2
 8001be0:	d908      	bls.n	8001bf4 <vPortValidateInterruptPriority+0x48>
 8001be2:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001be6:	f383 8811 	msr	BASEPRI, r3
 8001bea:	f3bf 8f6f 	isb	sy
 8001bee:	f3bf 8f4f 	dsb	sy
 8001bf2:	e7fe      	b.n	8001bf2 <vPortValidateInterruptPriority+0x46>
 8001bf4:	4770      	bx	lr
 8001bf6:	bf00      	nop
 8001bf8:	e000e3f0 	.word	0xe000e3f0
 8001bfc:	200020f8 	.word	0x200020f8
 8001c00:	e000ed0c 	.word	0xe000ed0c
 8001c04:	200020fc 	.word	0x200020fc

08001c08 <prvInsertBlockIntoFreeList>:
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
 8001c08:	b510      	push	{r4, lr}
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 8001c0a:	4b0f      	ldr	r3, [pc, #60]	; (8001c48 <prvInsertBlockIntoFreeList+0x40>)
 8001c0c:	681a      	ldr	r2, [r3, #0]
 8001c0e:	4282      	cmp	r2, r0
 8001c10:	d318      	bcc.n	8001c44 <prvInsertBlockIntoFreeList+0x3c>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 8001c12:	685c      	ldr	r4, [r3, #4]
 8001c14:	1919      	adds	r1, r3, r4
 8001c16:	4288      	cmp	r0, r1
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 8001c18:	bf01      	itttt	eq
 8001c1a:	6841      	ldreq	r1, [r0, #4]
 8001c1c:	4618      	moveq	r0, r3
 8001c1e:	1909      	addeq	r1, r1, r4
 8001c20:	6059      	streq	r1, [r3, #4]
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 8001c22:	6844      	ldr	r4, [r0, #4]
 8001c24:	1901      	adds	r1, r0, r4
 8001c26:	428a      	cmp	r2, r1
 8001c28:	d107      	bne.n	8001c3a <prvInsertBlockIntoFreeList+0x32>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
 8001c2a:	4908      	ldr	r1, [pc, #32]	; (8001c4c <prvInsertBlockIntoFreeList+0x44>)
 8001c2c:	6809      	ldr	r1, [r1, #0]
 8001c2e:	428a      	cmp	r2, r1
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8001c30:	bf1f      	itttt	ne
 8001c32:	6851      	ldrne	r1, [r2, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 8001c34:	6812      	ldrne	r2, [r2, #0]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8001c36:	1909      	addne	r1, r1, r4
 8001c38:	6041      	strne	r1, [r0, #4]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 8001c3a:	4298      	cmp	r0, r3
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 8001c3c:	6002      	str	r2, [r0, #0]
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 8001c3e:	bf18      	it	ne
 8001c40:	6018      	strne	r0, [r3, #0]
 8001c42:	bd10      	pop	{r4, pc}
 8001c44:	4613      	mov	r3, r2
 8001c46:	e7e1      	b.n	8001c0c <prvInsertBlockIntoFreeList+0x4>
 8001c48:	20003d10 	.word	0x20003d10
 8001c4c:	20002100 	.word	0x20002100

08001c50 <pvPortMalloc>:
{
 8001c50:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001c54:	4604      	mov	r4, r0
	vTaskSuspendAll();
 8001c56:	f000 fda7 	bl	80027a8 <vTaskSuspendAll>
		if( pxEnd == NULL )
 8001c5a:	493e      	ldr	r1, [pc, #248]	; (8001d54 <pvPortMalloc+0x104>)
 8001c5c:	4d3e      	ldr	r5, [pc, #248]	; (8001d58 <pvPortMalloc+0x108>)
 8001c5e:	680b      	ldr	r3, [r1, #0]
 8001c60:	bb0b      	cbnz	r3, 8001ca6 <pvPortMalloc+0x56>
	uxAddress = ( size_t ) ucHeap;
 8001c62:	4a3e      	ldr	r2, [pc, #248]	; (8001d5c <pvPortMalloc+0x10c>)
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 8001c64:	0756      	lsls	r6, r2, #29
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
 8001c66:	bf1d      	ittte	ne
 8001c68:	1dd0      	addne	r0, r2, #7
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8001c6a:	f020 0007 	bicne.w	r0, r0, #7
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
 8001c6e:	f502 53e0 	addne.w	r3, r2, #7168	; 0x1c00
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
 8001c72:	f44f 53e0 	moveq.w	r3, #7168	; 0x1c00
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8001c76:	bf1c      	itt	ne
 8001c78:	4602      	movne	r2, r0
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
 8001c7a:	1a1b      	subne	r3, r3, r0
	xStart.xBlockSize = ( size_t ) 0;
 8001c7c:	2000      	movs	r0, #0
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
 8001c7e:	4413      	add	r3, r2
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 8001c80:	4e37      	ldr	r6, [pc, #220]	; (8001d60 <pvPortMalloc+0x110>)
	uxAddress -= xHeapStructSize;
 8001c82:	3b08      	subs	r3, #8
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8001c84:	f023 0307 	bic.w	r3, r3, #7
	xStart.xBlockSize = ( size_t ) 0;
 8001c88:	6070      	str	r0, [r6, #4]
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 8001c8a:	6032      	str	r2, [r6, #0]
	pxEnd->xBlockSize = 0;
 8001c8c:	6058      	str	r0, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
 8001c8e:	6018      	str	r0, [r3, #0]
	pxEnd = ( void * ) uxAddress;
 8001c90:	600b      	str	r3, [r1, #0]
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 8001c92:	1a98      	subs	r0, r3, r2
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 8001c94:	6013      	str	r3, [r2, #0]
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8001c96:	4b33      	ldr	r3, [pc, #204]	; (8001d64 <pvPortMalloc+0x114>)
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 8001c98:	6050      	str	r0, [r2, #4]
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8001c9a:	6018      	str	r0, [r3, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8001c9c:	4b32      	ldr	r3, [pc, #200]	; (8001d68 <pvPortMalloc+0x118>)
 8001c9e:	6018      	str	r0, [r3, #0]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 8001ca0:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 8001ca4:	602b      	str	r3, [r5, #0]
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 8001ca6:	682f      	ldr	r7, [r5, #0]
 8001ca8:	4227      	tst	r7, r4
 8001caa:	d116      	bne.n	8001cda <pvPortMalloc+0x8a>
			if( xWantedSize > 0 )
 8001cac:	2c00      	cmp	r4, #0
 8001cae:	d040      	beq.n	8001d32 <pvPortMalloc+0xe2>
				xWantedSize += xHeapStructSize;
 8001cb0:	f104 0308 	add.w	r3, r4, #8
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 8001cb4:	0758      	lsls	r0, r3, #29
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 8001cb6:	bf1c      	itt	ne
 8001cb8:	f023 0307 	bicne.w	r3, r3, #7
 8001cbc:	3308      	addne	r3, #8
			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 8001cbe:	b163      	cbz	r3, 8001cda <pvPortMalloc+0x8a>
 8001cc0:	4a29      	ldr	r2, [pc, #164]	; (8001d68 <pvPortMalloc+0x118>)
 8001cc2:	6816      	ldr	r6, [r2, #0]
 8001cc4:	4690      	mov	r8, r2
 8001cc6:	42b3      	cmp	r3, r6
 8001cc8:	d807      	bhi.n	8001cda <pvPortMalloc+0x8a>
				pxBlock = xStart.pxNextFreeBlock;
 8001cca:	4a25      	ldr	r2, [pc, #148]	; (8001d60 <pvPortMalloc+0x110>)
 8001ccc:	6815      	ldr	r5, [r2, #0]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8001cce:	6868      	ldr	r0, [r5, #4]
 8001cd0:	4283      	cmp	r3, r0
 8001cd2:	d804      	bhi.n	8001cde <pvPortMalloc+0x8e>
				if( pxBlock != pxEnd )
 8001cd4:	6809      	ldr	r1, [r1, #0]
 8001cd6:	428d      	cmp	r5, r1
 8001cd8:	d107      	bne.n	8001cea <pvPortMalloc+0x9a>
void *pvReturn = NULL;
 8001cda:	2400      	movs	r4, #0
 8001cdc:	e029      	b.n	8001d32 <pvPortMalloc+0xe2>
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8001cde:	682c      	ldr	r4, [r5, #0]
 8001ce0:	2c00      	cmp	r4, #0
 8001ce2:	d0f7      	beq.n	8001cd4 <pvPortMalloc+0x84>
 8001ce4:	462a      	mov	r2, r5
 8001ce6:	4625      	mov	r5, r4
 8001ce8:	e7f1      	b.n	8001cce <pvPortMalloc+0x7e>
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 8001cea:	6829      	ldr	r1, [r5, #0]
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 8001cec:	6814      	ldr	r4, [r2, #0]
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 8001cee:	6011      	str	r1, [r2, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 8001cf0:	1ac2      	subs	r2, r0, r3
 8001cf2:	2a10      	cmp	r2, #16
 8001cf4:	d90f      	bls.n	8001d16 <pvPortMalloc+0xc6>
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 8001cf6:	18e8      	adds	r0, r5, r3
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 8001cf8:	0741      	lsls	r1, r0, #29
 8001cfa:	d008      	beq.n	8001d0e <pvPortMalloc+0xbe>
 8001cfc:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001d00:	f383 8811 	msr	BASEPRI, r3
 8001d04:	f3bf 8f6f 	isb	sy
 8001d08:	f3bf 8f4f 	dsb	sy
 8001d0c:	e7fe      	b.n	8001d0c <pvPortMalloc+0xbc>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 8001d0e:	6042      	str	r2, [r0, #4]
						pxBlock->xBlockSize = xWantedSize;
 8001d10:	606b      	str	r3, [r5, #4]
						prvInsertBlockIntoFreeList( pxNewBlockLink );
 8001d12:	f7ff ff79 	bl	8001c08 <prvInsertBlockIntoFreeList>
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8001d16:	686b      	ldr	r3, [r5, #4]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8001d18:	4912      	ldr	r1, [pc, #72]	; (8001d64 <pvPortMalloc+0x114>)
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8001d1a:	1af6      	subs	r6, r6, r3
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 8001d1c:	431f      	orrs	r7, r3
					pxBlock->pxNextFreeBlock = NULL;
 8001d1e:	2300      	movs	r3, #0
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8001d20:	6808      	ldr	r0, [r1, #0]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8001d22:	f8c8 6000 	str.w	r6, [r8]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8001d26:	4286      	cmp	r6, r0
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 8001d28:	bf38      	it	cc
 8001d2a:	600e      	strcc	r6, [r1, #0]
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 8001d2c:	3408      	adds	r4, #8
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 8001d2e:	606f      	str	r7, [r5, #4]
					pxBlock->pxNextFreeBlock = NULL;
 8001d30:	602b      	str	r3, [r5, #0]
	( void ) xTaskResumeAll();
 8001d32:	f000 fdd9 	bl	80028e8 <xTaskResumeAll>
	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 8001d36:	0763      	lsls	r3, r4, #29
 8001d38:	d008      	beq.n	8001d4c <pvPortMalloc+0xfc>
 8001d3a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001d3e:	f383 8811 	msr	BASEPRI, r3
 8001d42:	f3bf 8f6f 	isb	sy
 8001d46:	f3bf 8f4f 	dsb	sy
 8001d4a:	e7fe      	b.n	8001d4a <pvPortMalloc+0xfa>
}
 8001d4c:	4620      	mov	r0, r4
 8001d4e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001d52:	bf00      	nop
 8001d54:	20002100 	.word	0x20002100
 8001d58:	20003d04 	.word	0x20003d04
 8001d5c:	20002104 	.word	0x20002104
 8001d60:	20003d10 	.word	0x20003d10
 8001d64:	20003d0c 	.word	0x20003d0c
 8001d68:	20003d08 	.word	0x20003d08

08001d6c <vPortFree>:
{
 8001d6c:	b510      	push	{r4, lr}
	if( pv != NULL )
 8001d6e:	4604      	mov	r4, r0
 8001d70:	b370      	cbz	r0, 8001dd0 <vPortFree+0x64>
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 8001d72:	4a18      	ldr	r2, [pc, #96]	; (8001dd4 <vPortFree+0x68>)
 8001d74:	f850 3c04 	ldr.w	r3, [r0, #-4]
 8001d78:	6812      	ldr	r2, [r2, #0]
 8001d7a:	4213      	tst	r3, r2
 8001d7c:	d108      	bne.n	8001d90 <vPortFree+0x24>
 8001d7e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001d82:	f383 8811 	msr	BASEPRI, r3
 8001d86:	f3bf 8f6f 	isb	sy
 8001d8a:	f3bf 8f4f 	dsb	sy
 8001d8e:	e7fe      	b.n	8001d8e <vPortFree+0x22>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 8001d90:	f850 1c08 	ldr.w	r1, [r0, #-8]
 8001d94:	b141      	cbz	r1, 8001da8 <vPortFree+0x3c>
 8001d96:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001d9a:	f383 8811 	msr	BASEPRI, r3
 8001d9e:	f3bf 8f6f 	isb	sy
 8001da2:	f3bf 8f4f 	dsb	sy
 8001da6:	e7fe      	b.n	8001da6 <vPortFree+0x3a>
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 8001da8:	ea23 0302 	bic.w	r3, r3, r2
 8001dac:	f840 3c04 	str.w	r3, [r0, #-4]
				vTaskSuspendAll();
 8001db0:	f000 fcfa 	bl	80027a8 <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
 8001db4:	4a08      	ldr	r2, [pc, #32]	; (8001dd8 <vPortFree+0x6c>)
 8001db6:	f854 3c04 	ldr.w	r3, [r4, #-4]
 8001dba:	6811      	ldr	r1, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 8001dbc:	f1a4 0008 	sub.w	r0, r4, #8
					xFreeBytesRemaining += pxLink->xBlockSize;
 8001dc0:	440b      	add	r3, r1
 8001dc2:	6013      	str	r3, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 8001dc4:	f7ff ff20 	bl	8001c08 <prvInsertBlockIntoFreeList>
}
 8001dc8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
				( void ) xTaskResumeAll();
 8001dcc:	f000 bd8c 	b.w	80028e8 <xTaskResumeAll>
 8001dd0:	bd10      	pop	{r4, pc}
 8001dd2:	bf00      	nop
 8001dd4:	20003d04 	.word	0x20003d04
 8001dd8:	20003d08 	.word	0x20003d08

08001ddc <prvIsQueueEmpty>:
	taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
 8001ddc:	b510      	push	{r4, lr}
 8001dde:	4604      	mov	r4, r0
BaseType_t xReturn;

	taskENTER_CRITICAL();
 8001de0:	f7ff fe08 	bl	80019f4 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 8001de4:	6ba4      	ldr	r4, [r4, #56]	; 0x38
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 8001de6:	f7ff fe27 	bl	8001a38 <vPortExitCritical>

	return xReturn;
}
 8001dea:	fab4 f084 	clz	r0, r4
 8001dee:	0940      	lsrs	r0, r0, #5
 8001df0:	bd10      	pop	{r4, pc}

08001df2 <prvCopyDataToQueue>:
{
 8001df2:	b570      	push	{r4, r5, r6, lr}
 8001df4:	4615      	mov	r5, r2
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 8001df6:	6c02      	ldr	r2, [r0, #64]	; 0x40
{
 8001df8:	4604      	mov	r4, r0
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8001dfa:	6b86      	ldr	r6, [r0, #56]	; 0x38
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 8001dfc:	b942      	cbnz	r2, 8001e10 <prvCopyDataToQueue+0x1e>
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8001dfe:	6805      	ldr	r5, [r0, #0]
 8001e00:	b99d      	cbnz	r5, 8001e2a <prvCopyDataToQueue+0x38>
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 8001e02:	6840      	ldr	r0, [r0, #4]
 8001e04:	f000 ff20 	bl	8002c48 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
 8001e08:	6065      	str	r5, [r4, #4]
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 8001e0a:	3601      	adds	r6, #1
 8001e0c:	63a6      	str	r6, [r4, #56]	; 0x38
}
 8001e0e:	bd70      	pop	{r4, r5, r6, pc}
	else if( xPosition == queueSEND_TO_BACK )
 8001e10:	b96d      	cbnz	r5, 8001e2e <prvCopyDataToQueue+0x3c>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
 8001e12:	6880      	ldr	r0, [r0, #8]
 8001e14:	f001 fd9e 	bl	8003954 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8001e18:	68a3      	ldr	r3, [r4, #8]
 8001e1a:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8001e1c:	4413      	add	r3, r2
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8001e1e:	6862      	ldr	r2, [r4, #4]
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8001e20:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8001e22:	4293      	cmp	r3, r2
 8001e24:	d301      	bcc.n	8001e2a <prvCopyDataToQueue+0x38>
			pxQueue->pcWriteTo = pxQueue->pcHead;
 8001e26:	6823      	ldr	r3, [r4, #0]
 8001e28:	60a3      	str	r3, [r4, #8]
BaseType_t xReturn = pdFALSE;
 8001e2a:	2000      	movs	r0, #0
 8001e2c:	e7ed      	b.n	8001e0a <prvCopyDataToQueue+0x18>
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8001e2e:	68c0      	ldr	r0, [r0, #12]
 8001e30:	f001 fd90 	bl	8003954 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 8001e34:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8001e36:	68e2      	ldr	r2, [r4, #12]
 8001e38:	425b      	negs	r3, r3
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8001e3a:	6821      	ldr	r1, [r4, #0]
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 8001e3c:	441a      	add	r2, r3
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8001e3e:	428a      	cmp	r2, r1
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 8001e40:	60e2      	str	r2, [r4, #12]
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 8001e42:	bf3e      	ittt	cc
 8001e44:	6862      	ldrcc	r2, [r4, #4]
 8001e46:	189b      	addcc	r3, r3, r2
 8001e48:	60e3      	strcc	r3, [r4, #12]
		if( xPosition == queueOVERWRITE )
 8001e4a:	2d02      	cmp	r5, #2
 8001e4c:	d1ed      	bne.n	8001e2a <prvCopyDataToQueue+0x38>
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8001e4e:	b10e      	cbz	r6, 8001e54 <prvCopyDataToQueue+0x62>
				--uxMessagesWaiting;
 8001e50:	3e01      	subs	r6, #1
 8001e52:	e7ea      	b.n	8001e2a <prvCopyDataToQueue+0x38>
BaseType_t xReturn = pdFALSE;
 8001e54:	4630      	mov	r0, r6
 8001e56:	e7d8      	b.n	8001e0a <prvCopyDataToQueue+0x18>

08001e58 <prvCopyDataFromQueue>:
{
 8001e58:	4603      	mov	r3, r0
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 8001e5a:	6c1a      	ldr	r2, [r3, #64]	; 0x40
{
 8001e5c:	b410      	push	{r4}
 8001e5e:	4608      	mov	r0, r1
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 8001e60:	b162      	cbz	r2, 8001e7c <prvCopyDataFromQueue+0x24>
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8001e62:	68d9      	ldr	r1, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8001e64:	685c      	ldr	r4, [r3, #4]
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8001e66:	4411      	add	r1, r2
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8001e68:	42a1      	cmp	r1, r4
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8001e6a:	60d9      	str	r1, [r3, #12]
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 8001e6c:	bf28      	it	cs
 8001e6e:	6819      	ldrcs	r1, [r3, #0]
}
 8001e70:	bc10      	pop	{r4}
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 8001e72:	bf28      	it	cs
 8001e74:	60d9      	strcs	r1, [r3, #12]
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
 8001e76:	68d9      	ldr	r1, [r3, #12]
 8001e78:	f001 bd6c 	b.w	8003954 <memcpy>
}
 8001e7c:	bc10      	pop	{r4}
 8001e7e:	4770      	bx	lr

08001e80 <prvUnlockQueue>:
{
 8001e80:	b570      	push	{r4, r5, r6, lr}
 8001e82:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
 8001e84:	f7ff fdb6 	bl	80019f4 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 8001e88:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8001e8c:	f104 0624 	add.w	r6, r4, #36	; 0x24
		int8_t cTxLock = pxQueue->cTxLock;
 8001e90:	b26d      	sxtb	r5, r5
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8001e92:	2d00      	cmp	r5, #0
 8001e94:	dc14      	bgt.n	8001ec0 <prvUnlockQueue+0x40>
		pxQueue->cTxLock = queueUNLOCKED;
 8001e96:	23ff      	movs	r3, #255	; 0xff
 8001e98:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
 8001e9c:	f7ff fdcc 	bl	8001a38 <vPortExitCritical>
	taskENTER_CRITICAL();
 8001ea0:	f7ff fda8 	bl	80019f4 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 8001ea4:	f894 5044 	ldrb.w	r5, [r4, #68]	; 0x44
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8001ea8:	f104 0610 	add.w	r6, r4, #16
		int8_t cRxLock = pxQueue->cRxLock;
 8001eac:	b26d      	sxtb	r5, r5
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8001eae:	2d00      	cmp	r5, #0
 8001eb0:	dc12      	bgt.n	8001ed8 <prvUnlockQueue+0x58>
		pxQueue->cRxLock = queueUNLOCKED;
 8001eb2:	23ff      	movs	r3, #255	; 0xff
 8001eb4:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
}
 8001eb8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	taskEXIT_CRITICAL();
 8001ebc:	f7ff bdbc 	b.w	8001a38 <vPortExitCritical>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8001ec0:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8001ec2:	2b00      	cmp	r3, #0
 8001ec4:	d0e7      	beq.n	8001e96 <prvUnlockQueue+0x16>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8001ec6:	4630      	mov	r0, r6
 8001ec8:	f000 fe1e 	bl	8002b08 <xTaskRemoveFromEventList>
 8001ecc:	b108      	cbz	r0, 8001ed2 <prvUnlockQueue+0x52>
						vTaskMissedYield();
 8001ece:	f000 fea5 	bl	8002c1c <vTaskMissedYield>
 8001ed2:	3d01      	subs	r5, #1
 8001ed4:	b26d      	sxtb	r5, r5
 8001ed6:	e7dc      	b.n	8001e92 <prvUnlockQueue+0x12>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8001ed8:	6923      	ldr	r3, [r4, #16]
 8001eda:	2b00      	cmp	r3, #0
 8001edc:	d0e9      	beq.n	8001eb2 <prvUnlockQueue+0x32>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8001ede:	4630      	mov	r0, r6
 8001ee0:	f000 fe12 	bl	8002b08 <xTaskRemoveFromEventList>
 8001ee4:	b108      	cbz	r0, 8001eea <prvUnlockQueue+0x6a>
					vTaskMissedYield();
 8001ee6:	f000 fe99 	bl	8002c1c <vTaskMissedYield>
 8001eea:	3d01      	subs	r5, #1
 8001eec:	b26d      	sxtb	r5, r5
 8001eee:	e7de      	b.n	8001eae <prvUnlockQueue+0x2e>

08001ef0 <xQueueGenericReset>:
{
 8001ef0:	b538      	push	{r3, r4, r5, lr}
 8001ef2:	460d      	mov	r5, r1
	configASSERT( pxQueue );
 8001ef4:	4604      	mov	r4, r0
 8001ef6:	b940      	cbnz	r0, 8001f0a <xQueueGenericReset+0x1a>
 8001ef8:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001efc:	f383 8811 	msr	BASEPRI, r3
 8001f00:	f3bf 8f6f 	isb	sy
 8001f04:	f3bf 8f4f 	dsb	sy
 8001f08:	e7fe      	b.n	8001f08 <xQueueGenericReset+0x18>
	taskENTER_CRITICAL();
 8001f0a:	f7ff fd73 	bl	80019f4 <vPortEnterCritical>
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8001f0e:	6c20      	ldr	r0, [r4, #64]	; 0x40
 8001f10:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8001f12:	6822      	ldr	r2, [r4, #0]
 8001f14:	4343      	muls	r3, r0
 8001f16:	18d1      	adds	r1, r2, r3
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 8001f18:	1a1b      	subs	r3, r3, r0
 8001f1a:	4413      	add	r3, r2
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8001f1c:	6061      	str	r1, [r4, #4]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 8001f1e:	60e3      	str	r3, [r4, #12]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 8001f20:	2100      	movs	r1, #0
		pxQueue->cRxLock = queueUNLOCKED;
 8001f22:	23ff      	movs	r3, #255	; 0xff
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 8001f24:	63a1      	str	r1, [r4, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
 8001f26:	60a2      	str	r2, [r4, #8]
		pxQueue->cRxLock = queueUNLOCKED;
 8001f28:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
		pxQueue->cTxLock = queueUNLOCKED;
 8001f2c:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
		if( xNewQueue == pdFALSE )
 8001f30:	b995      	cbnz	r5, 8001f58 <xQueueGenericReset+0x68>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8001f32:	6923      	ldr	r3, [r4, #16]
 8001f34:	b163      	cbz	r3, 8001f50 <xQueueGenericReset+0x60>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8001f36:	f104 0010 	add.w	r0, r4, #16
 8001f3a:	f000 fde5 	bl	8002b08 <xTaskRemoveFromEventList>
 8001f3e:	b138      	cbz	r0, 8001f50 <xQueueGenericReset+0x60>
					queueYIELD_IF_USING_PREEMPTION();
 8001f40:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8001f44:	4b09      	ldr	r3, [pc, #36]	; (8001f6c <xQueueGenericReset+0x7c>)
 8001f46:	601a      	str	r2, [r3, #0]
 8001f48:	f3bf 8f4f 	dsb	sy
 8001f4c:	f3bf 8f6f 	isb	sy
	taskEXIT_CRITICAL();
 8001f50:	f7ff fd72 	bl	8001a38 <vPortExitCritical>
}
 8001f54:	2001      	movs	r0, #1
 8001f56:	bd38      	pop	{r3, r4, r5, pc}
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 8001f58:	f104 0010 	add.w	r0, r4, #16
 8001f5c:	f7ff fcaf 	bl	80018be <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 8001f60:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8001f64:	f7ff fcab 	bl	80018be <vListInitialise>
 8001f68:	e7f2      	b.n	8001f50 <xQueueGenericReset+0x60>
 8001f6a:	bf00      	nop
 8001f6c:	e000ed04 	.word	0xe000ed04

08001f70 <xQueueGenericCreate>:
	{
 8001f70:	b570      	push	{r4, r5, r6, lr}
 8001f72:	460d      	mov	r5, r1
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 8001f74:	4606      	mov	r6, r0
 8001f76:	b940      	cbnz	r0, 8001f8a <xQueueGenericCreate+0x1a>
 8001f78:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001f7c:	f383 8811 	msr	BASEPRI, r3
 8001f80:	f3bf 8f6f 	isb	sy
 8001f84:	f3bf 8f4f 	dsb	sy
 8001f88:	e7fe      	b.n	8001f88 <xQueueGenericCreate+0x18>
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8001f8a:	4348      	muls	r0, r1
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 8001f8c:	3048      	adds	r0, #72	; 0x48
 8001f8e:	f7ff fe5f 	bl	8001c50 <pvPortMalloc>
		if( pxNewQueue != NULL )
 8001f92:	4604      	mov	r4, r0
 8001f94:	b138      	cbz	r0, 8001fa6 <xQueueGenericCreate+0x36>
	if( uxItemSize == ( UBaseType_t ) 0 )
 8001f96:	b945      	cbnz	r5, 8001faa <xQueueGenericCreate+0x3a>
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 8001f98:	6020      	str	r0, [r4, #0]
	pxNewQueue->uxLength = uxQueueLength;
 8001f9a:	63e6      	str	r6, [r4, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
 8001f9c:	6425      	str	r5, [r4, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 8001f9e:	2101      	movs	r1, #1
 8001fa0:	4620      	mov	r0, r4
 8001fa2:	f7ff ffa5 	bl	8001ef0 <xQueueGenericReset>
	}
 8001fa6:	4620      	mov	r0, r4
 8001fa8:	bd70      	pop	{r4, r5, r6, pc}
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
 8001faa:	f100 0348 	add.w	r3, r0, #72	; 0x48
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 8001fae:	6003      	str	r3, [r0, #0]
 8001fb0:	e7f3      	b.n	8001f9a <xQueueGenericCreate+0x2a>
	...

08001fb4 <xQueueGenericSend>:
{
 8001fb4:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 8001fb8:	4689      	mov	r9, r1
 8001fba:	9201      	str	r2, [sp, #4]
 8001fbc:	461f      	mov	r7, r3
	configASSERT( pxQueue );
 8001fbe:	4604      	mov	r4, r0
 8001fc0:	b940      	cbnz	r0, 8001fd4 <xQueueGenericSend+0x20>
 8001fc2:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001fc6:	f383 8811 	msr	BASEPRI, r3
 8001fca:	f3bf 8f6f 	isb	sy
 8001fce:	f3bf 8f4f 	dsb	sy
 8001fd2:	e7fe      	b.n	8001fd2 <xQueueGenericSend+0x1e>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8001fd4:	2900      	cmp	r1, #0
 8001fd6:	f040 8088 	bne.w	80020ea <xQueueGenericSend+0x136>
 8001fda:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8001fdc:	2b00      	cmp	r3, #0
 8001fde:	f000 8084 	beq.w	80020ea <xQueueGenericSend+0x136>
 8001fe2:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001fe6:	f383 8811 	msr	BASEPRI, r3
 8001fea:	f3bf 8f6f 	isb	sy
 8001fee:	f3bf 8f4f 	dsb	sy
 8001ff2:	e7fe      	b.n	8001ff2 <xQueueGenericSend+0x3e>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8001ff4:	9e01      	ldr	r6, [sp, #4]
 8001ff6:	2e00      	cmp	r6, #0
 8001ff8:	f000 8082 	beq.w	8002100 <xQueueGenericSend+0x14c>
 8001ffc:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002000:	f383 8811 	msr	BASEPRI, r3
 8002004:	f3bf 8f6f 	isb	sy
 8002008:	f3bf 8f4f 	dsb	sy
 800200c:	e7fe      	b.n	800200c <xQueueGenericSend+0x58>
				if( xTicksToWait == ( TickType_t ) 0 )
 800200e:	9d01      	ldr	r5, [sp, #4]
 8002010:	b91d      	cbnz	r5, 800201a <xQueueGenericSend+0x66>
					taskEXIT_CRITICAL();
 8002012:	f7ff fd11 	bl	8001a38 <vPortExitCritical>
			return errQUEUE_FULL;
 8002016:	2000      	movs	r0, #0
 8002018:	e058      	b.n	80020cc <xQueueGenericSend+0x118>
				else if( xEntryTimeSet == pdFALSE )
 800201a:	b916      	cbnz	r6, 8002022 <xQueueGenericSend+0x6e>
					vTaskInternalSetTimeOutState( &xTimeOut );
 800201c:	a802      	add	r0, sp, #8
 800201e:	f000 fdb5 	bl	8002b8c <vTaskInternalSetTimeOutState>
		taskEXIT_CRITICAL();
 8002022:	f7ff fd09 	bl	8001a38 <vPortExitCritical>
		vTaskSuspendAll();
 8002026:	f000 fbbf 	bl	80027a8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 800202a:	f7ff fce3 	bl	80019f4 <vPortEnterCritical>
 800202e:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8002032:	2bff      	cmp	r3, #255	; 0xff
 8002034:	bf08      	it	eq
 8002036:	f884 8044 	strbeq.w	r8, [r4, #68]	; 0x44
 800203a:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 800203e:	2bff      	cmp	r3, #255	; 0xff
 8002040:	bf08      	it	eq
 8002042:	f884 8045 	strbeq.w	r8, [r4, #69]	; 0x45
 8002046:	f7ff fcf7 	bl	8001a38 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800204a:	a901      	add	r1, sp, #4
 800204c:	a802      	add	r0, sp, #8
 800204e:	f000 fda9 	bl	8002ba4 <xTaskCheckForTimeOut>
 8002052:	2800      	cmp	r0, #0
 8002054:	d143      	bne.n	80020de <xQueueGenericSend+0x12a>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
 8002056:	f7ff fccd 	bl	80019f4 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 800205a:	6ba6      	ldr	r6, [r4, #56]	; 0x38
 800205c:	6be5      	ldr	r5, [r4, #60]	; 0x3c
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 800205e:	f7ff fceb 	bl	8001a38 <vPortExitCritical>
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 8002062:	42ae      	cmp	r6, r5
 8002064:	d135      	bne.n	80020d2 <xQueueGenericSend+0x11e>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 8002066:	9901      	ldr	r1, [sp, #4]
 8002068:	f104 0010 	add.w	r0, r4, #16
 800206c:	f000 fd12 	bl	8002a94 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 8002070:	4620      	mov	r0, r4
 8002072:	f7ff ff05 	bl	8001e80 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 8002076:	f000 fc37 	bl	80028e8 <xTaskResumeAll>
 800207a:	b938      	cbnz	r0, 800208c <xQueueGenericSend+0xd8>
					portYIELD_WITHIN_API();
 800207c:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8002080:	f8ca 3000 	str.w	r3, [sl]
 8002084:	f3bf 8f4f 	dsb	sy
 8002088:	f3bf 8f6f 	isb	sy
 800208c:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
 800208e:	f7ff fcb1 	bl	80019f4 <vPortEnterCritical>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 8002092:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8002094:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8002096:	429a      	cmp	r2, r3
 8002098:	d301      	bcc.n	800209e <xQueueGenericSend+0xea>
 800209a:	2f02      	cmp	r7, #2
 800209c:	d1b7      	bne.n	800200e <xQueueGenericSend+0x5a>
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 800209e:	463a      	mov	r2, r7
 80020a0:	4649      	mov	r1, r9
 80020a2:	4620      	mov	r0, r4
 80020a4:	f7ff fea5 	bl	8001df2 <prvCopyDataToQueue>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80020a8:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80020aa:	b11b      	cbz	r3, 80020b4 <xQueueGenericSend+0x100>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80020ac:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80020b0:	f000 fd2a 	bl	8002b08 <xTaskRemoveFromEventList>
					else if( xYieldRequired != pdFALSE )
 80020b4:	b138      	cbz	r0, 80020c6 <xQueueGenericSend+0x112>
						queueYIELD_IF_USING_PREEMPTION();
 80020b6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80020ba:	4b18      	ldr	r3, [pc, #96]	; (800211c <xQueueGenericSend+0x168>)
 80020bc:	601a      	str	r2, [r3, #0]
 80020be:	f3bf 8f4f 	dsb	sy
 80020c2:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
 80020c6:	f7ff fcb7 	bl	8001a38 <vPortExitCritical>
				return pdPASS;
 80020ca:	2001      	movs	r0, #1
}
 80020cc:	b004      	add	sp, #16
 80020ce:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				prvUnlockQueue( pxQueue );
 80020d2:	4620      	mov	r0, r4
 80020d4:	f7ff fed4 	bl	8001e80 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 80020d8:	f000 fc06 	bl	80028e8 <xTaskResumeAll>
 80020dc:	e7d6      	b.n	800208c <xQueueGenericSend+0xd8>
			prvUnlockQueue( pxQueue );
 80020de:	4620      	mov	r0, r4
 80020e0:	f7ff fece 	bl	8001e80 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 80020e4:	f000 fc00 	bl	80028e8 <xTaskResumeAll>
 80020e8:	e795      	b.n	8002016 <xQueueGenericSend+0x62>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 80020ea:	2f02      	cmp	r7, #2
 80020ec:	d102      	bne.n	80020f4 <xQueueGenericSend+0x140>
 80020ee:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80020f0:	2b01      	cmp	r3, #1
 80020f2:	d10a      	bne.n	800210a <xQueueGenericSend+0x156>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 80020f4:	f000 fd98 	bl	8002c28 <xTaskGetSchedulerState>
 80020f8:	2800      	cmp	r0, #0
 80020fa:	f43f af7b 	beq.w	8001ff4 <xQueueGenericSend+0x40>
 80020fe:	2600      	movs	r6, #0
		prvLockQueue( pxQueue );
 8002100:	f04f 0800 	mov.w	r8, #0
					portYIELD_WITHIN_API();
 8002104:	f8df a014 	ldr.w	sl, [pc, #20]	; 800211c <xQueueGenericSend+0x168>
 8002108:	e7c1      	b.n	800208e <xQueueGenericSend+0xda>
 800210a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800210e:	f383 8811 	msr	BASEPRI, r3
 8002112:	f3bf 8f6f 	isb	sy
 8002116:	f3bf 8f4f 	dsb	sy
 800211a:	e7fe      	b.n	800211a <xQueueGenericSend+0x166>
 800211c:	e000ed04 	.word	0xe000ed04

08002120 <xQueueGenericSendFromISR>:
{
 8002120:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8002124:	4688      	mov	r8, r1
 8002126:	4691      	mov	r9, r2
 8002128:	461f      	mov	r7, r3
	configASSERT( pxQueue );
 800212a:	4604      	mov	r4, r0
 800212c:	b940      	cbnz	r0, 8002140 <xQueueGenericSendFromISR+0x20>
 800212e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002132:	f383 8811 	msr	BASEPRI, r3
 8002136:	f3bf 8f6f 	isb	sy
 800213a:	f3bf 8f4f 	dsb	sy
 800213e:	e7fe      	b.n	800213e <xQueueGenericSendFromISR+0x1e>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8002140:	bb09      	cbnz	r1, 8002186 <xQueueGenericSendFromISR+0x66>
 8002142:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8002144:	b1fb      	cbz	r3, 8002186 <xQueueGenericSendFromISR+0x66>
 8002146:	f04f 0350 	mov.w	r3, #80	; 0x50
 800214a:	f383 8811 	msr	BASEPRI, r3
 800214e:	f3bf 8f6f 	isb	sy
 8002152:	f3bf 8f4f 	dsb	sy
 8002156:	e7fe      	b.n	8002156 <xQueueGenericSendFromISR+0x36>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8002158:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800215c:	f000 fcd4 	bl	8002b08 <xTaskRemoveFromEventList>
 8002160:	2800      	cmp	r0, #0
 8002162:	d034      	beq.n	80021ce <xQueueGenericSendFromISR+0xae>
							if( pxHigherPriorityTaskWoken != NULL )
 8002164:	f1b9 0f00 	cmp.w	r9, #0
 8002168:	d031      	beq.n	80021ce <xQueueGenericSendFromISR+0xae>
								*pxHigherPriorityTaskWoken = pdTRUE;
 800216a:	2001      	movs	r0, #1
 800216c:	f8c9 0000 	str.w	r0, [r9]
	__asm volatile
 8002170:	f386 8811 	msr	BASEPRI, r6
}
 8002174:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 8002178:	3501      	adds	r5, #1
 800217a:	b26d      	sxtb	r5, r5
 800217c:	f884 5045 	strb.w	r5, [r4, #69]	; 0x45
 8002180:	e025      	b.n	80021ce <xQueueGenericSendFromISR+0xae>
			xReturn = errQUEUE_FULL;
 8002182:	2000      	movs	r0, #0
 8002184:	e7f4      	b.n	8002170 <xQueueGenericSendFromISR+0x50>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 8002186:	2f02      	cmp	r7, #2
 8002188:	d102      	bne.n	8002190 <xQueueGenericSendFromISR+0x70>
 800218a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800218c:	2b01      	cmp	r3, #1
 800218e:	d120      	bne.n	80021d2 <xQueueGenericSendFromISR+0xb2>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8002190:	f7ff fd0c 	bl	8001bac <vPortValidateInterruptPriority>
	__asm volatile
 8002194:	f3ef 8611 	mrs	r6, BASEPRI
 8002198:	f04f 0350 	mov.w	r3, #80	; 0x50
 800219c:	f383 8811 	msr	BASEPRI, r3
 80021a0:	f3bf 8f6f 	isb	sy
 80021a4:	f3bf 8f4f 	dsb	sy
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 80021a8:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 80021aa:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80021ac:	429a      	cmp	r2, r3
 80021ae:	d301      	bcc.n	80021b4 <xQueueGenericSendFromISR+0x94>
 80021b0:	2f02      	cmp	r7, #2
 80021b2:	d1e6      	bne.n	8002182 <xQueueGenericSendFromISR+0x62>
			const int8_t cTxLock = pxQueue->cTxLock;
 80021b4:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 80021b8:	463a      	mov	r2, r7
			const int8_t cTxLock = pxQueue->cTxLock;
 80021ba:	b26d      	sxtb	r5, r5
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 80021bc:	4641      	mov	r1, r8
 80021be:	4620      	mov	r0, r4
 80021c0:	f7ff fe17 	bl	8001df2 <prvCopyDataToQueue>
			if( cTxLock == queueUNLOCKED )
 80021c4:	1c6b      	adds	r3, r5, #1
 80021c6:	d1d7      	bne.n	8002178 <xQueueGenericSendFromISR+0x58>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80021c8:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80021ca:	2b00      	cmp	r3, #0
 80021cc:	d1c4      	bne.n	8002158 <xQueueGenericSendFromISR+0x38>
			xReturn = pdPASS;
 80021ce:	2001      	movs	r0, #1
 80021d0:	e7ce      	b.n	8002170 <xQueueGenericSendFromISR+0x50>
	__asm volatile
 80021d2:	f04f 0350 	mov.w	r3, #80	; 0x50
 80021d6:	f383 8811 	msr	BASEPRI, r3
 80021da:	f3bf 8f6f 	isb	sy
 80021de:	f3bf 8f4f 	dsb	sy
 80021e2:	e7fe      	b.n	80021e2 <xQueueGenericSendFromISR+0xc2>

080021e4 <xQueueReceive>:
{
 80021e4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80021e8:	b085      	sub	sp, #20
 80021ea:	4688      	mov	r8, r1
 80021ec:	9201      	str	r2, [sp, #4]
	configASSERT( ( pxQueue ) );
 80021ee:	4604      	mov	r4, r0
 80021f0:	b940      	cbnz	r0, 8002204 <xQueueReceive+0x20>
 80021f2:	f04f 0350 	mov.w	r3, #80	; 0x50
 80021f6:	f383 8811 	msr	BASEPRI, r3
 80021fa:	f3bf 8f6f 	isb	sy
 80021fe:	f3bf 8f4f 	dsb	sy
 8002202:	e7fe      	b.n	8002202 <xQueueReceive+0x1e>
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8002204:	2900      	cmp	r1, #0
 8002206:	f040 8086 	bne.w	8002316 <xQueueReceive+0x132>
 800220a:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800220c:	2b00      	cmp	r3, #0
 800220e:	f000 8082 	beq.w	8002316 <xQueueReceive+0x132>
 8002212:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002216:	f383 8811 	msr	BASEPRI, r3
 800221a:	f3bf 8f6f 	isb	sy
 800221e:	f3bf 8f4f 	dsb	sy
 8002222:	e7fe      	b.n	8002222 <xQueueReceive+0x3e>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8002224:	9e01      	ldr	r6, [sp, #4]
 8002226:	2e00      	cmp	r6, #0
 8002228:	d07a      	beq.n	8002320 <xQueueReceive+0x13c>
 800222a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800222e:	f383 8811 	msr	BASEPRI, r3
 8002232:	f3bf 8f6f 	isb	sy
 8002236:	f3bf 8f4f 	dsb	sy
 800223a:	e7fe      	b.n	800223a <xQueueReceive+0x56>
				if( xTicksToWait == ( TickType_t ) 0 )
 800223c:	9d01      	ldr	r5, [sp, #4]
 800223e:	b91d      	cbnz	r5, 8002248 <xQueueReceive+0x64>
					taskEXIT_CRITICAL();
 8002240:	f7ff fbfa 	bl	8001a38 <vPortExitCritical>
				return errQUEUE_EMPTY;
 8002244:	2000      	movs	r0, #0
 8002246:	e052      	b.n	80022ee <xQueueReceive+0x10a>
				else if( xEntryTimeSet == pdFALSE )
 8002248:	b916      	cbnz	r6, 8002250 <xQueueReceive+0x6c>
					vTaskInternalSetTimeOutState( &xTimeOut );
 800224a:	a802      	add	r0, sp, #8
 800224c:	f000 fc9e 	bl	8002b8c <vTaskInternalSetTimeOutState>
		taskEXIT_CRITICAL();
 8002250:	f7ff fbf2 	bl	8001a38 <vPortExitCritical>
		vTaskSuspendAll();
 8002254:	f000 faa8 	bl	80027a8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8002258:	f7ff fbcc 	bl	80019f4 <vPortEnterCritical>
 800225c:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8002260:	2bff      	cmp	r3, #255	; 0xff
 8002262:	bf08      	it	eq
 8002264:	f884 7044 	strbeq.w	r7, [r4, #68]	; 0x44
 8002268:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 800226c:	2bff      	cmp	r3, #255	; 0xff
 800226e:	bf08      	it	eq
 8002270:	f884 7045 	strbeq.w	r7, [r4, #69]	; 0x45
 8002274:	f7ff fbe0 	bl	8001a38 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8002278:	a901      	add	r1, sp, #4
 800227a:	a802      	add	r0, sp, #8
 800227c:	f000 fc92 	bl	8002ba4 <xTaskCheckForTimeOut>
 8002280:	2800      	cmp	r0, #0
 8002282:	d13d      	bne.n	8002300 <xQueueReceive+0x11c>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8002284:	4620      	mov	r0, r4
 8002286:	f7ff fda9 	bl	8001ddc <prvIsQueueEmpty>
 800228a:	b398      	cbz	r0, 80022f4 <xQueueReceive+0x110>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 800228c:	9901      	ldr	r1, [sp, #4]
 800228e:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8002292:	f000 fbff 	bl	8002a94 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 8002296:	4620      	mov	r0, r4
 8002298:	f7ff fdf2 	bl	8001e80 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 800229c:	f000 fb24 	bl	80028e8 <xTaskResumeAll>
 80022a0:	b938      	cbnz	r0, 80022b2 <xQueueReceive+0xce>
					portYIELD_WITHIN_API();
 80022a2:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 80022a6:	f8c9 3000 	str.w	r3, [r9]
 80022aa:	f3bf 8f4f 	dsb	sy
 80022ae:	f3bf 8f6f 	isb	sy
 80022b2:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
 80022b4:	f7ff fb9e 	bl	80019f4 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 80022b8:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 80022ba:	2d00      	cmp	r5, #0
 80022bc:	d0be      	beq.n	800223c <xQueueReceive+0x58>
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 80022be:	4641      	mov	r1, r8
 80022c0:	4620      	mov	r0, r4
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 80022c2:	3d01      	subs	r5, #1
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 80022c4:	f7ff fdc8 	bl	8001e58 <prvCopyDataFromQueue>
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 80022c8:	63a5      	str	r5, [r4, #56]	; 0x38
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80022ca:	6923      	ldr	r3, [r4, #16]
 80022cc:	b163      	cbz	r3, 80022e8 <xQueueReceive+0x104>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80022ce:	f104 0010 	add.w	r0, r4, #16
 80022d2:	f000 fc19 	bl	8002b08 <xTaskRemoveFromEventList>
 80022d6:	b138      	cbz	r0, 80022e8 <xQueueReceive+0x104>
						queueYIELD_IF_USING_PREEMPTION();
 80022d8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80022dc:	4b12      	ldr	r3, [pc, #72]	; (8002328 <xQueueReceive+0x144>)
 80022de:	601a      	str	r2, [r3, #0]
 80022e0:	f3bf 8f4f 	dsb	sy
 80022e4:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
 80022e8:	f7ff fba6 	bl	8001a38 <vPortExitCritical>
				return pdPASS;
 80022ec:	2001      	movs	r0, #1
}
 80022ee:	b005      	add	sp, #20
 80022f0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
				prvUnlockQueue( pxQueue );
 80022f4:	4620      	mov	r0, r4
 80022f6:	f7ff fdc3 	bl	8001e80 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 80022fa:	f000 faf5 	bl	80028e8 <xTaskResumeAll>
 80022fe:	e7d8      	b.n	80022b2 <xQueueReceive+0xce>
			prvUnlockQueue( pxQueue );
 8002300:	4620      	mov	r0, r4
 8002302:	f7ff fdbd 	bl	8001e80 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8002306:	f000 faef 	bl	80028e8 <xTaskResumeAll>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 800230a:	4620      	mov	r0, r4
 800230c:	f7ff fd66 	bl	8001ddc <prvIsQueueEmpty>
 8002310:	2800      	cmp	r0, #0
 8002312:	d0ce      	beq.n	80022b2 <xQueueReceive+0xce>
 8002314:	e796      	b.n	8002244 <xQueueReceive+0x60>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8002316:	f000 fc87 	bl	8002c28 <xTaskGetSchedulerState>
 800231a:	2800      	cmp	r0, #0
 800231c:	d082      	beq.n	8002224 <xQueueReceive+0x40>
 800231e:	2600      	movs	r6, #0
		prvLockQueue( pxQueue );
 8002320:	2700      	movs	r7, #0
					portYIELD_WITHIN_API();
 8002322:	f8df 9004 	ldr.w	r9, [pc, #4]	; 8002328 <xQueueReceive+0x144>
 8002326:	e7c5      	b.n	80022b4 <xQueueReceive+0xd0>
 8002328:	e000ed04 	.word	0xe000ed04

0800232c <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
 800232c:	b570      	push	{r4, r5, r6, lr}
 800232e:	4604      	mov	r4, r0
 8002330:	460d      	mov	r5, r1
 8002332:	4616      	mov	r6, r2
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
 8002334:	f7ff fb5e 	bl	80019f4 <vPortEnterCritical>
 8002338:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800233c:	2bff      	cmp	r3, #255	; 0xff
 800233e:	bf04      	itt	eq
 8002340:	2300      	moveq	r3, #0
 8002342:	f884 3044 	strbeq.w	r3, [r4, #68]	; 0x44
 8002346:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 800234a:	2bff      	cmp	r3, #255	; 0xff
 800234c:	bf04      	itt	eq
 800234e:	2300      	moveq	r3, #0
 8002350:	f884 3045 	strbeq.w	r3, [r4, #69]	; 0x45
 8002354:	f7ff fb70 	bl	8001a38 <vPortExitCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 8002358:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800235a:	b92b      	cbnz	r3, 8002368 <vQueueWaitForMessageRestricted+0x3c>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
 800235c:	4632      	mov	r2, r6
 800235e:	4629      	mov	r1, r5
 8002360:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8002364:	f000 fbb0 	bl	8002ac8 <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
 8002368:	4620      	mov	r0, r4
	}
 800236a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		prvUnlockQueue( pxQueue );
 800236e:	f7ff bd87 	b.w	8001e80 <prvUnlockQueue>
	...

08002374 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8002374:	4a06      	ldr	r2, [pc, #24]	; (8002390 <prvResetNextTaskUnblockTime+0x1c>)
 8002376:	6813      	ldr	r3, [r2, #0]
 8002378:	6819      	ldr	r1, [r3, #0]
 800237a:	4b06      	ldr	r3, [pc, #24]	; (8002394 <prvResetNextTaskUnblockTime+0x20>)
 800237c:	b919      	cbnz	r1, 8002386 <prvResetNextTaskUnblockTime+0x12>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 800237e:	f04f 32ff 	mov.w	r2, #4294967295
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 8002382:	601a      	str	r2, [r3, #0]
 8002384:	4770      	bx	lr
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8002386:	6812      	ldr	r2, [r2, #0]
 8002388:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 800238a:	68d2      	ldr	r2, [r2, #12]
 800238c:	6852      	ldr	r2, [r2, #4]
 800238e:	e7f8      	b.n	8002382 <prvResetNextTaskUnblockTime+0xe>
 8002390:	20003d1c 	.word	0x20003d1c
 8002394:	20003dcc 	.word	0x20003dcc

08002398 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 8002398:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 800239a:	4b1b      	ldr	r3, [pc, #108]	; (8002408 <prvAddCurrentTaskToDelayedList+0x70>)
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800239c:	4e1b      	ldr	r6, [pc, #108]	; (800240c <prvAddCurrentTaskToDelayedList+0x74>)
const TickType_t xConstTickCount = xTickCount;
 800239e:	681d      	ldr	r5, [r3, #0]
{
 80023a0:	4604      	mov	r4, r0
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80023a2:	6830      	ldr	r0, [r6, #0]
{
 80023a4:	460f      	mov	r7, r1
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80023a6:	3004      	adds	r0, #4
 80023a8:	f7ff faba 	bl	8001920 <uxListRemove>
 80023ac:	4633      	mov	r3, r6
 80023ae:	b940      	cbnz	r0, 80023c2 <prvAddCurrentTaskToDelayedList+0x2a>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 80023b0:	2001      	movs	r0, #1
 80023b2:	6831      	ldr	r1, [r6, #0]
 80023b4:	4e16      	ldr	r6, [pc, #88]	; (8002410 <prvAddCurrentTaskToDelayedList+0x78>)
 80023b6:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 80023b8:	6832      	ldr	r2, [r6, #0]
 80023ba:	4088      	lsls	r0, r1
 80023bc:	ea22 0200 	bic.w	r2, r2, r0
 80023c0:	6032      	str	r2, [r6, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 80023c2:	1c62      	adds	r2, r4, #1
 80023c4:	d107      	bne.n	80023d6 <prvAddCurrentTaskToDelayedList+0x3e>
 80023c6:	b137      	cbz	r7, 80023d6 <prvAddCurrentTaskToDelayedList+0x3e>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80023c8:	6819      	ldr	r1, [r3, #0]
 80023ca:	4812      	ldr	r0, [pc, #72]	; (8002414 <prvAddCurrentTaskToDelayedList+0x7c>)
 80023cc:	3104      	adds	r1, #4

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 80023ce:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80023d2:	f7ff ba82 	b.w	80018da <vListInsertEnd>
			xTimeToWake = xConstTickCount + xTicksToWait;
 80023d6:	442c      	add	r4, r5
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 80023d8:	681a      	ldr	r2, [r3, #0]
			if( xTimeToWake < xConstTickCount )
 80023da:	42a5      	cmp	r5, r4
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 80023dc:	6054      	str	r4, [r2, #4]
			if( xTimeToWake < xConstTickCount )
 80023de:	d907      	bls.n	80023f0 <prvAddCurrentTaskToDelayedList+0x58>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80023e0:	4a0d      	ldr	r2, [pc, #52]	; (8002418 <prvAddCurrentTaskToDelayedList+0x80>)
 80023e2:	6810      	ldr	r0, [r2, #0]
 80023e4:	6819      	ldr	r1, [r3, #0]
}
 80023e6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80023ea:	3104      	adds	r1, #4
 80023ec:	f7ff ba81 	b.w	80018f2 <vListInsert>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80023f0:	4a0a      	ldr	r2, [pc, #40]	; (800241c <prvAddCurrentTaskToDelayedList+0x84>)
 80023f2:	6810      	ldr	r0, [r2, #0]
 80023f4:	6819      	ldr	r1, [r3, #0]
 80023f6:	3104      	adds	r1, #4
 80023f8:	f7ff fa7b 	bl	80018f2 <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
 80023fc:	4b08      	ldr	r3, [pc, #32]	; (8002420 <prvAddCurrentTaskToDelayedList+0x88>)
 80023fe:	681a      	ldr	r2, [r3, #0]
 8002400:	4294      	cmp	r4, r2
					xNextTaskUnblockTime = xTimeToWake;
 8002402:	bf38      	it	cc
 8002404:	601c      	strcc	r4, [r3, #0]
 8002406:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002408:	20003e14 	.word	0x20003e14
 800240c:	20003d18 	.word	0x20003d18
 8002410:	20003d9c 	.word	0x20003d9c
 8002414:	20003dec 	.word	0x20003dec
 8002418:	20003d20 	.word	0x20003d20
 800241c:	20003d1c 	.word	0x20003d1c
 8002420:	20003dcc 	.word	0x20003dcc

08002424 <prvIdleTask>:
{
 8002424:	b580      	push	{r7, lr}
				taskYIELD();
 8002426:	f8df 8064 	ldr.w	r8, [pc, #100]	; 800248c <prvIdleTask+0x68>
				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 800242a:	4f14      	ldr	r7, [pc, #80]	; (800247c <prvIdleTask+0x58>)
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 800242c:	4c14      	ldr	r4, [pc, #80]	; (8002480 <prvIdleTask+0x5c>)
				--uxCurrentNumberOfTasks;
 800242e:	4e15      	ldr	r6, [pc, #84]	; (8002484 <prvIdleTask+0x60>)
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8002430:	6823      	ldr	r3, [r4, #0]
 8002432:	b963      	cbnz	r3, 800244e <prvIdleTask+0x2a>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 8002434:	4b14      	ldr	r3, [pc, #80]	; (8002488 <prvIdleTask+0x64>)
 8002436:	681b      	ldr	r3, [r3, #0]
 8002438:	2b01      	cmp	r3, #1
 800243a:	d9f8      	bls.n	800242e <prvIdleTask+0xa>
				taskYIELD();
 800243c:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8002440:	f8c8 3000 	str.w	r3, [r8]
 8002444:	f3bf 8f4f 	dsb	sy
 8002448:	f3bf 8f6f 	isb	sy
 800244c:	e7ee      	b.n	800242c <prvIdleTask+0x8>
			taskENTER_CRITICAL();
 800244e:	f7ff fad1 	bl	80019f4 <vPortEnterCritical>
				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 8002452:	68fb      	ldr	r3, [r7, #12]
 8002454:	68dd      	ldr	r5, [r3, #12]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8002456:	1d28      	adds	r0, r5, #4
 8002458:	f7ff fa62 	bl	8001920 <uxListRemove>
				--uxCurrentNumberOfTasks;
 800245c:	6833      	ldr	r3, [r6, #0]
 800245e:	3b01      	subs	r3, #1
 8002460:	6033      	str	r3, [r6, #0]
				--uxDeletedTasksWaitingCleanUp;
 8002462:	6823      	ldr	r3, [r4, #0]
 8002464:	3b01      	subs	r3, #1
 8002466:	6023      	str	r3, [r4, #0]
			taskEXIT_CRITICAL();
 8002468:	f7ff fae6 	bl	8001a38 <vPortExitCritical>
			vPortFree( pxTCB->pxStack );
 800246c:	6b28      	ldr	r0, [r5, #48]	; 0x30
 800246e:	f7ff fc7d 	bl	8001d6c <vPortFree>
			vPortFree( pxTCB );
 8002472:	4628      	mov	r0, r5
 8002474:	f7ff fc7a 	bl	8001d6c <vPortFree>
 8002478:	e7da      	b.n	8002430 <prvIdleTask+0xc>
 800247a:	bf00      	nop
 800247c:	20003e00 	.word	0x20003e00
 8002480:	20003d8c 	.word	0x20003d8c
 8002484:	20003d88 	.word	0x20003d88
 8002488:	20003d24 	.word	0x20003d24
 800248c:	e000ed04 	.word	0xe000ed04

08002490 <xTaskCreate>:
	{
 8002490:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8002494:	ea4f 0a82 	mov.w	sl, r2, lsl #2
	{
 8002498:	4680      	mov	r8, r0
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800249a:	4650      	mov	r0, sl
	{
 800249c:	460f      	mov	r7, r1
 800249e:	4699      	mov	r9, r3
 80024a0:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80024a2:	f7ff fbd5 	bl	8001c50 <pvPortMalloc>
			if( pxStack != NULL )
 80024a6:	4605      	mov	r5, r0
 80024a8:	2800      	cmp	r0, #0
 80024aa:	f000 809f 	beq.w	80025ec <xTaskCreate+0x15c>
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
 80024ae:	2050      	movs	r0, #80	; 0x50
 80024b0:	f7ff fbce 	bl	8001c50 <pvPortMalloc>
				if( pxNewTCB != NULL )
 80024b4:	4604      	mov	r4, r0
 80024b6:	2800      	cmp	r0, #0
 80024b8:	f000 8095 	beq.w	80025e6 <xTaskCreate+0x156>
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 80024bc:	f1aa 0a04 	sub.w	sl, sl, #4
					pxNewTCB->pxStack = pxStack;
 80024c0:	6305      	str	r5, [r0, #48]	; 0x30
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 80024c2:	4455      	add	r5, sl
 80024c4:	1e7b      	subs	r3, r7, #1
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 80024c6:	f025 0a07 	bic.w	sl, r5, #7
 80024ca:	f100 0234 	add.w	r2, r0, #52	; 0x34
 80024ce:	3709      	adds	r7, #9
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 80024d0:	7859      	ldrb	r1, [r3, #1]
 80024d2:	f802 1b01 	strb.w	r1, [r2], #1
		if( pcName[ x ] == 0x00 )
 80024d6:	f813 1f01 	ldrb.w	r1, [r3, #1]!
 80024da:	b109      	cbz	r1, 80024e0 <xTaskCreate+0x50>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 80024dc:	42bb      	cmp	r3, r7
 80024de:	d1f7      	bne.n	80024d0 <xTaskCreate+0x40>
 80024e0:	9d0a      	ldr	r5, [sp, #40]	; 0x28
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 80024e2:	f04f 0b00 	mov.w	fp, #0
 80024e6:	2d04      	cmp	r5, #4
 80024e8:	bf28      	it	cs
 80024ea:	2504      	movcs	r5, #4
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 80024ec:	1d27      	adds	r7, r4, #4
	pxNewTCB->uxPriority = uxPriority;
 80024ee:	62e5      	str	r5, [r4, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
 80024f0:	6425      	str	r5, [r4, #64]	; 0x40
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 80024f2:	4638      	mov	r0, r7
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 80024f4:	f884 b03d 	strb.w	fp, [r4, #61]	; 0x3d
		pxNewTCB->uxMutexesHeld = 0;
 80024f8:	f8c4 b044 	str.w	fp, [r4, #68]	; 0x44
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 80024fc:	f7ff f9ea 	bl	80018d4 <vListInitialiseItem>
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8002500:	f1c5 0505 	rsb	r5, r5, #5
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 8002504:	f104 0018 	add.w	r0, r4, #24
 8002508:	f7ff f9e4 	bl	80018d4 <vListInitialiseItem>
		pxNewTCB->ulNotifiedValue = 0;
 800250c:	f8c4 b048 	str.w	fp, [r4, #72]	; 0x48
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 8002510:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8002512:	61a5      	str	r5, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 8002514:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 8002516:	f884 b04c 	strb.w	fp, [r4, #76]	; 0x4c
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 800251a:	464a      	mov	r2, r9
 800251c:	4641      	mov	r1, r8
 800251e:	4650      	mov	r0, sl
 8002520:	f7ff fa40 	bl	80019a4 <pxPortInitialiseStack>
 8002524:	6020      	str	r0, [r4, #0]
	if( ( void * ) pxCreatedTask != NULL )
 8002526:	b106      	cbz	r6, 800252a <xTaskCreate+0x9a>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8002528:	6034      	str	r4, [r6, #0]
	taskENTER_CRITICAL();
 800252a:	f7ff fa63 	bl	80019f4 <vPortEnterCritical>
		uxCurrentNumberOfTasks++;
 800252e:	4b36      	ldr	r3, [pc, #216]	; (8002608 <xTaskCreate+0x178>)
		if( pxCurrentTCB == NULL )
 8002530:	4e36      	ldr	r6, [pc, #216]	; (800260c <xTaskCreate+0x17c>)
		uxCurrentNumberOfTasks++;
 8002532:	681a      	ldr	r2, [r3, #0]
 8002534:	f8df 8110 	ldr.w	r8, [pc, #272]	; 8002648 <xTaskCreate+0x1b8>
 8002538:	3201      	adds	r2, #1
 800253a:	601a      	str	r2, [r3, #0]
		if( pxCurrentTCB == NULL )
 800253c:	6832      	ldr	r2, [r6, #0]
 800253e:	2a00      	cmp	r2, #0
 8002540:	d157      	bne.n	80025f2 <xTaskCreate+0x162>
			pxCurrentTCB = pxNewTCB;
 8002542:	6034      	str	r4, [r6, #0]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 8002544:	681b      	ldr	r3, [r3, #0]
 8002546:	2b01      	cmp	r3, #1
 8002548:	d125      	bne.n	8002596 <xTaskCreate+0x106>
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 800254a:	4831      	ldr	r0, [pc, #196]	; (8002610 <xTaskCreate+0x180>)
 800254c:	f7ff f9b7 	bl	80018be <vListInitialise>
 8002550:	4830      	ldr	r0, [pc, #192]	; (8002614 <xTaskCreate+0x184>)
 8002552:	f7ff f9b4 	bl	80018be <vListInitialise>
 8002556:	4830      	ldr	r0, [pc, #192]	; (8002618 <xTaskCreate+0x188>)
 8002558:	f7ff f9b1 	bl	80018be <vListInitialise>
	vListInitialise( &xDelayedTaskList1 );
 800255c:	f8df 90ec 	ldr.w	r9, [pc, #236]	; 800264c <xTaskCreate+0x1bc>
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8002560:	482e      	ldr	r0, [pc, #184]	; (800261c <xTaskCreate+0x18c>)
 8002562:	f7ff f9ac 	bl	80018be <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 8002566:	4d2e      	ldr	r5, [pc, #184]	; (8002620 <xTaskCreate+0x190>)
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8002568:	482e      	ldr	r0, [pc, #184]	; (8002624 <xTaskCreate+0x194>)
 800256a:	f7ff f9a8 	bl	80018be <vListInitialise>
	vListInitialise( &xDelayedTaskList1 );
 800256e:	4648      	mov	r0, r9
 8002570:	f7ff f9a5 	bl	80018be <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 8002574:	4628      	mov	r0, r5
 8002576:	f7ff f9a2 	bl	80018be <vListInitialise>
	vListInitialise( &xPendingReadyList );
 800257a:	482b      	ldr	r0, [pc, #172]	; (8002628 <xTaskCreate+0x198>)
 800257c:	f7ff f99f 	bl	80018be <vListInitialise>
		vListInitialise( &xTasksWaitingTermination );
 8002580:	482a      	ldr	r0, [pc, #168]	; (800262c <xTaskCreate+0x19c>)
 8002582:	f7ff f99c 	bl	80018be <vListInitialise>
		vListInitialise( &xSuspendedTaskList );
 8002586:	482a      	ldr	r0, [pc, #168]	; (8002630 <xTaskCreate+0x1a0>)
 8002588:	f7ff f999 	bl	80018be <vListInitialise>
	pxDelayedTaskList = &xDelayedTaskList1;
 800258c:	4b29      	ldr	r3, [pc, #164]	; (8002634 <xTaskCreate+0x1a4>)
 800258e:	f8c3 9000 	str.w	r9, [r3]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8002592:	4b29      	ldr	r3, [pc, #164]	; (8002638 <xTaskCreate+0x1a8>)
 8002594:	601d      	str	r5, [r3, #0]
		prvAddTaskToReadyList( pxNewTCB );
 8002596:	2501      	movs	r5, #1
		uxTaskNumber++;
 8002598:	4a28      	ldr	r2, [pc, #160]	; (800263c <xTaskCreate+0x1ac>)
		prvAddTaskToReadyList( pxNewTCB );
 800259a:	4929      	ldr	r1, [pc, #164]	; (8002640 <xTaskCreate+0x1b0>)
		uxTaskNumber++;
 800259c:	6813      	ldr	r3, [r2, #0]
		prvAddTaskToReadyList( pxNewTCB );
 800259e:	6808      	ldr	r0, [r1, #0]
		uxTaskNumber++;
 80025a0:	3301      	adds	r3, #1
 80025a2:	6013      	str	r3, [r2, #0]
		prvAddTaskToReadyList( pxNewTCB );
 80025a4:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80025a6:	fa05 f302 	lsl.w	r3, r5, r2
 80025aa:	4303      	orrs	r3, r0
 80025ac:	2014      	movs	r0, #20
 80025ae:	600b      	str	r3, [r1, #0]
 80025b0:	4b17      	ldr	r3, [pc, #92]	; (8002610 <xTaskCreate+0x180>)
 80025b2:	4639      	mov	r1, r7
 80025b4:	fb00 3002 	mla	r0, r0, r2, r3
 80025b8:	f7ff f98f 	bl	80018da <vListInsertEnd>
	taskEXIT_CRITICAL();
 80025bc:	f7ff fa3c 	bl	8001a38 <vPortExitCritical>
	if( xSchedulerRunning != pdFALSE )
 80025c0:	f8d8 3000 	ldr.w	r3, [r8]
 80025c4:	b163      	cbz	r3, 80025e0 <xTaskCreate+0x150>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 80025c6:	6833      	ldr	r3, [r6, #0]
 80025c8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80025ca:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80025cc:	429a      	cmp	r2, r3
 80025ce:	d207      	bcs.n	80025e0 <xTaskCreate+0x150>
			taskYIELD_IF_USING_PREEMPTION();
 80025d0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80025d4:	4b1b      	ldr	r3, [pc, #108]	; (8002644 <xTaskCreate+0x1b4>)
 80025d6:	601a      	str	r2, [r3, #0]
 80025d8:	f3bf 8f4f 	dsb	sy
 80025dc:	f3bf 8f6f 	isb	sy
	}
 80025e0:	4628      	mov	r0, r5
 80025e2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
					vPortFree( pxStack );
 80025e6:	4628      	mov	r0, r5
 80025e8:	f7ff fbc0 	bl	8001d6c <vPortFree>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 80025ec:	f04f 35ff 	mov.w	r5, #4294967295
 80025f0:	e7f6      	b.n	80025e0 <xTaskCreate+0x150>
			if( xSchedulerRunning == pdFALSE )
 80025f2:	f8d8 3000 	ldr.w	r3, [r8]
 80025f6:	2b00      	cmp	r3, #0
 80025f8:	d1cd      	bne.n	8002596 <xTaskCreate+0x106>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 80025fa:	6833      	ldr	r3, [r6, #0]
 80025fc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80025fe:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8002600:	429a      	cmp	r2, r3
					pxCurrentTCB = pxNewTCB;
 8002602:	bf98      	it	ls
 8002604:	6034      	strls	r4, [r6, #0]
 8002606:	e7c6      	b.n	8002596 <xTaskCreate+0x106>
 8002608:	20003d88 	.word	0x20003d88
 800260c:	20003d18 	.word	0x20003d18
 8002610:	20003d24 	.word	0x20003d24
 8002614:	20003d38 	.word	0x20003d38
 8002618:	20003d4c 	.word	0x20003d4c
 800261c:	20003d60 	.word	0x20003d60
 8002620:	20003db4 	.word	0x20003db4
 8002624:	20003d74 	.word	0x20003d74
 8002628:	20003dd4 	.word	0x20003dd4
 800262c:	20003e00 	.word	0x20003e00
 8002630:	20003dec 	.word	0x20003dec
 8002634:	20003d1c 	.word	0x20003d1c
 8002638:	20003d20 	.word	0x20003d20
 800263c:	20003d98 	.word	0x20003d98
 8002640:	20003d9c 	.word	0x20003d9c
 8002644:	e000ed04 	.word	0xe000ed04
 8002648:	20003de8 	.word	0x20003de8
 800264c:	20003da0 	.word	0x20003da0

08002650 <vTaskDelete>:
	{
 8002650:	b570      	push	{r4, r5, r6, lr}
 8002652:	4604      	mov	r4, r0
 8002654:	4d2a      	ldr	r5, [pc, #168]	; (8002700 <vTaskDelete+0xb0>)
		taskENTER_CRITICAL();
 8002656:	f7ff f9cd 	bl	80019f4 <vPortEnterCritical>
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 800265a:	b904      	cbnz	r4, 800265e <vTaskDelete+0xe>
 800265c:	682c      	ldr	r4, [r5, #0]
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800265e:	1d26      	adds	r6, r4, #4
 8002660:	4630      	mov	r0, r6
 8002662:	f7ff f95d 	bl	8001920 <uxListRemove>
 8002666:	b960      	cbnz	r0, 8002682 <vTaskDelete+0x32>
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 8002668:	2114      	movs	r1, #20
 800266a:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 800266c:	4b25      	ldr	r3, [pc, #148]	; (8002704 <vTaskDelete+0xb4>)
 800266e:	4341      	muls	r1, r0
 8002670:	585b      	ldr	r3, [r3, r1]
 8002672:	b933      	cbnz	r3, 8002682 <vTaskDelete+0x32>
 8002674:	2201      	movs	r2, #1
 8002676:	4924      	ldr	r1, [pc, #144]	; (8002708 <vTaskDelete+0xb8>)
 8002678:	4082      	lsls	r2, r0
 800267a:	680b      	ldr	r3, [r1, #0]
 800267c:	ea23 0302 	bic.w	r3, r3, r2
 8002680:	600b      	str	r3, [r1, #0]
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8002682:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002684:	b11b      	cbz	r3, 800268e <vTaskDelete+0x3e>
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8002686:	f104 0018 	add.w	r0, r4, #24
 800268a:	f7ff f949 	bl	8001920 <uxListRemove>
			uxTaskNumber++;
 800268e:	4a1f      	ldr	r2, [pc, #124]	; (800270c <vTaskDelete+0xbc>)
 8002690:	6813      	ldr	r3, [r2, #0]
 8002692:	3301      	adds	r3, #1
 8002694:	6013      	str	r3, [r2, #0]
			if( pxTCB == pxCurrentTCB )
 8002696:	682b      	ldr	r3, [r5, #0]
 8002698:	429c      	cmp	r4, r3
 800269a:	d11b      	bne.n	80026d4 <vTaskDelete+0x84>
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
 800269c:	4631      	mov	r1, r6
 800269e:	481c      	ldr	r0, [pc, #112]	; (8002710 <vTaskDelete+0xc0>)
 80026a0:	f7ff f91b 	bl	80018da <vListInsertEnd>
				++uxDeletedTasksWaitingCleanUp;
 80026a4:	4a1b      	ldr	r2, [pc, #108]	; (8002714 <vTaskDelete+0xc4>)
 80026a6:	6813      	ldr	r3, [r2, #0]
 80026a8:	3301      	adds	r3, #1
 80026aa:	6013      	str	r3, [r2, #0]
		taskEXIT_CRITICAL();
 80026ac:	f7ff f9c4 	bl	8001a38 <vPortExitCritical>
		if( xSchedulerRunning != pdFALSE )
 80026b0:	4b19      	ldr	r3, [pc, #100]	; (8002718 <vTaskDelete+0xc8>)
 80026b2:	681b      	ldr	r3, [r3, #0]
 80026b4:	b31b      	cbz	r3, 80026fe <vTaskDelete+0xae>
			if( pxTCB == pxCurrentTCB )
 80026b6:	682b      	ldr	r3, [r5, #0]
 80026b8:	429c      	cmp	r4, r3
 80026ba:	d120      	bne.n	80026fe <vTaskDelete+0xae>
				configASSERT( uxSchedulerSuspended == 0 );
 80026bc:	4b17      	ldr	r3, [pc, #92]	; (800271c <vTaskDelete+0xcc>)
 80026be:	681b      	ldr	r3, [r3, #0]
 80026c0:	b1ab      	cbz	r3, 80026ee <vTaskDelete+0x9e>
 80026c2:	f04f 0350 	mov.w	r3, #80	; 0x50
 80026c6:	f383 8811 	msr	BASEPRI, r3
 80026ca:	f3bf 8f6f 	isb	sy
 80026ce:	f3bf 8f4f 	dsb	sy
 80026d2:	e7fe      	b.n	80026d2 <vTaskDelete+0x82>
				--uxCurrentNumberOfTasks;
 80026d4:	4a12      	ldr	r2, [pc, #72]	; (8002720 <vTaskDelete+0xd0>)
			vPortFree( pxTCB->pxStack );
 80026d6:	6b20      	ldr	r0, [r4, #48]	; 0x30
				--uxCurrentNumberOfTasks;
 80026d8:	6813      	ldr	r3, [r2, #0]
 80026da:	3b01      	subs	r3, #1
 80026dc:	6013      	str	r3, [r2, #0]
			vPortFree( pxTCB->pxStack );
 80026de:	f7ff fb45 	bl	8001d6c <vPortFree>
			vPortFree( pxTCB );
 80026e2:	4620      	mov	r0, r4
 80026e4:	f7ff fb42 	bl	8001d6c <vPortFree>
				prvResetNextTaskUnblockTime();
 80026e8:	f7ff fe44 	bl	8002374 <prvResetNextTaskUnblockTime>
 80026ec:	e7de      	b.n	80026ac <vTaskDelete+0x5c>
				portYIELD_WITHIN_API();
 80026ee:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80026f2:	4b0c      	ldr	r3, [pc, #48]	; (8002724 <vTaskDelete+0xd4>)
 80026f4:	601a      	str	r2, [r3, #0]
 80026f6:	f3bf 8f4f 	dsb	sy
 80026fa:	f3bf 8f6f 	isb	sy
 80026fe:	bd70      	pop	{r4, r5, r6, pc}
 8002700:	20003d18 	.word	0x20003d18
 8002704:	20003d24 	.word	0x20003d24
 8002708:	20003d9c 	.word	0x20003d9c
 800270c:	20003d98 	.word	0x20003d98
 8002710:	20003e00 	.word	0x20003e00
 8002714:	20003d8c 	.word	0x20003d8c
 8002718:	20003de8 	.word	0x20003de8
 800271c:	20003d94 	.word	0x20003d94
 8002720:	20003d88 	.word	0x20003d88
 8002724:	e000ed04 	.word	0xe000ed04

08002728 <vTaskStartScheduler>:
{
 8002728:	b513      	push	{r0, r1, r4, lr}
		xReturn = xTaskCreate(	prvIdleTask,
 800272a:	2400      	movs	r4, #0
 800272c:	4b18      	ldr	r3, [pc, #96]	; (8002790 <vTaskStartScheduler+0x68>)
 800272e:	9400      	str	r4, [sp, #0]
 8002730:	9301      	str	r3, [sp, #4]
 8002732:	2246      	movs	r2, #70	; 0x46
 8002734:	4623      	mov	r3, r4
 8002736:	4917      	ldr	r1, [pc, #92]	; (8002794 <vTaskStartScheduler+0x6c>)
 8002738:	4817      	ldr	r0, [pc, #92]	; (8002798 <vTaskStartScheduler+0x70>)
 800273a:	f7ff fea9 	bl	8002490 <xTaskCreate>
		if( xReturn == pdPASS )
 800273e:	2801      	cmp	r0, #1
 8002740:	d118      	bne.n	8002774 <vTaskStartScheduler+0x4c>
			xReturn = xTimerCreateTimerTask();
 8002742:	f000 fb15 	bl	8002d70 <xTimerCreateTimerTask>
	if( xReturn == pdPASS )
 8002746:	2801      	cmp	r0, #1
 8002748:	d114      	bne.n	8002774 <vTaskStartScheduler+0x4c>
 800274a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800274e:	f383 8811 	msr	BASEPRI, r3
 8002752:	f3bf 8f6f 	isb	sy
 8002756:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
 800275a:	f04f 32ff 	mov.w	r2, #4294967295
 800275e:	4b0f      	ldr	r3, [pc, #60]	; (800279c <vTaskStartScheduler+0x74>)
 8002760:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
 8002762:	4b0f      	ldr	r3, [pc, #60]	; (80027a0 <vTaskStartScheduler+0x78>)
 8002764:	6018      	str	r0, [r3, #0]
		xTickCount = ( TickType_t ) 0U;
 8002766:	4b0f      	ldr	r3, [pc, #60]	; (80027a4 <vTaskStartScheduler+0x7c>)
 8002768:	601c      	str	r4, [r3, #0]
}
 800276a:	b002      	add	sp, #8
 800276c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		if( xPortStartScheduler() != pdFALSE )
 8002770:	f7ff b9c2 	b.w	8001af8 <xPortStartScheduler>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 8002774:	3001      	adds	r0, #1
 8002776:	d108      	bne.n	800278a <vTaskStartScheduler+0x62>
 8002778:	f04f 0350 	mov.w	r3, #80	; 0x50
 800277c:	f383 8811 	msr	BASEPRI, r3
 8002780:	f3bf 8f6f 	isb	sy
 8002784:	f3bf 8f4f 	dsb	sy
 8002788:	e7fe      	b.n	8002788 <vTaskStartScheduler+0x60>
}
 800278a:	b002      	add	sp, #8
 800278c:	bd10      	pop	{r4, pc}
 800278e:	bf00      	nop
 8002790:	20003dc8 	.word	0x20003dc8
 8002794:	080039c3 	.word	0x080039c3
 8002798:	08002425 	.word	0x08002425
 800279c:	20003dcc 	.word	0x20003dcc
 80027a0:	20003de8 	.word	0x20003de8
 80027a4:	20003e14 	.word	0x20003e14

080027a8 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
 80027a8:	4a02      	ldr	r2, [pc, #8]	; (80027b4 <vTaskSuspendAll+0xc>)
 80027aa:	6813      	ldr	r3, [r2, #0]
 80027ac:	3301      	adds	r3, #1
 80027ae:	6013      	str	r3, [r2, #0]
 80027b0:	4770      	bx	lr
 80027b2:	bf00      	nop
 80027b4:	20003d94 	.word	0x20003d94

080027b8 <xTaskGetTickCount>:
		xTicks = xTickCount;
 80027b8:	4b01      	ldr	r3, [pc, #4]	; (80027c0 <xTaskGetTickCount+0x8>)
 80027ba:	6818      	ldr	r0, [r3, #0]
}
 80027bc:	4770      	bx	lr
 80027be:	bf00      	nop
 80027c0:	20003e14 	.word	0x20003e14

080027c4 <xTaskIncrementTick>:
{
 80027c4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80027c8:	4b3c      	ldr	r3, [pc, #240]	; (80028bc <xTaskIncrementTick+0xf8>)
 80027ca:	681b      	ldr	r3, [r3, #0]
 80027cc:	2b00      	cmp	r3, #0
 80027ce:	d153      	bne.n	8002878 <xTaskIncrementTick+0xb4>
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 80027d0:	4b3b      	ldr	r3, [pc, #236]	; (80028c0 <xTaskIncrementTick+0xfc>)
 80027d2:	681c      	ldr	r4, [r3, #0]
 80027d4:	3401      	adds	r4, #1
		xTickCount = xConstTickCount;
 80027d6:	601c      	str	r4, [r3, #0]
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 80027d8:	b9bc      	cbnz	r4, 800280a <xTaskIncrementTick+0x46>
			taskSWITCH_DELAYED_LISTS();
 80027da:	4b3a      	ldr	r3, [pc, #232]	; (80028c4 <xTaskIncrementTick+0x100>)
 80027dc:	681a      	ldr	r2, [r3, #0]
 80027de:	6812      	ldr	r2, [r2, #0]
 80027e0:	b142      	cbz	r2, 80027f4 <xTaskIncrementTick+0x30>
 80027e2:	f04f 0350 	mov.w	r3, #80	; 0x50
 80027e6:	f383 8811 	msr	BASEPRI, r3
 80027ea:	f3bf 8f6f 	isb	sy
 80027ee:	f3bf 8f4f 	dsb	sy
 80027f2:	e7fe      	b.n	80027f2 <xTaskIncrementTick+0x2e>
 80027f4:	4a34      	ldr	r2, [pc, #208]	; (80028c8 <xTaskIncrementTick+0x104>)
 80027f6:	6819      	ldr	r1, [r3, #0]
 80027f8:	6810      	ldr	r0, [r2, #0]
 80027fa:	6018      	str	r0, [r3, #0]
 80027fc:	6011      	str	r1, [r2, #0]
 80027fe:	4a33      	ldr	r2, [pc, #204]	; (80028cc <xTaskIncrementTick+0x108>)
 8002800:	6813      	ldr	r3, [r2, #0]
 8002802:	3301      	adds	r3, #1
 8002804:	6013      	str	r3, [r2, #0]
 8002806:	f7ff fdb5 	bl	8002374 <prvResetNextTaskUnblockTime>
		if( xConstTickCount >= xNextTaskUnblockTime )
 800280a:	4d31      	ldr	r5, [pc, #196]	; (80028d0 <xTaskIncrementTick+0x10c>)
 800280c:	f04f 0b00 	mov.w	fp, #0
 8002810:	682b      	ldr	r3, [r5, #0]
 8002812:	4f30      	ldr	r7, [pc, #192]	; (80028d4 <xTaskIncrementTick+0x110>)
 8002814:	429c      	cmp	r4, r3
 8002816:	d33e      	bcc.n	8002896 <xTaskIncrementTick+0xd2>
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8002818:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 80028c4 <xTaskIncrementTick+0x100>
					prvAddTaskToReadyList( pxTCB );
 800281c:	f8df 90c4 	ldr.w	r9, [pc, #196]	; 80028e4 <xTaskIncrementTick+0x120>
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8002820:	f8d8 2000 	ldr.w	r2, [r8]
 8002824:	6812      	ldr	r2, [r2, #0]
 8002826:	bb72      	cbnz	r2, 8002886 <xTaskIncrementTick+0xc2>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8002828:	f04f 32ff 	mov.w	r2, #4294967295
 800282c:	602a      	str	r2, [r5, #0]
					break;
 800282e:	e032      	b.n	8002896 <xTaskIncrementTick+0xd2>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8002830:	f106 0a04 	add.w	sl, r6, #4
 8002834:	4650      	mov	r0, sl
 8002836:	f7ff f873 	bl	8001920 <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 800283a:	6ab1      	ldr	r1, [r6, #40]	; 0x28
 800283c:	b119      	cbz	r1, 8002846 <xTaskIncrementTick+0x82>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800283e:	f106 0018 	add.w	r0, r6, #24
 8002842:	f7ff f86d 	bl	8001920 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8002846:	2201      	movs	r2, #1
 8002848:	f04f 0e14 	mov.w	lr, #20
 800284c:	6af0      	ldr	r0, [r6, #44]	; 0x2c
 800284e:	f8d9 3000 	ldr.w	r3, [r9]
 8002852:	fa02 f100 	lsl.w	r1, r2, r0
 8002856:	4319      	orrs	r1, r3
 8002858:	4b1f      	ldr	r3, [pc, #124]	; (80028d8 <xTaskIncrementTick+0x114>)
 800285a:	f8c9 1000 	str.w	r1, [r9]
 800285e:	fb0e 3000 	mla	r0, lr, r0, r3
 8002862:	4651      	mov	r1, sl
 8002864:	f7ff f839 	bl	80018da <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8002868:	6838      	ldr	r0, [r7, #0]
 800286a:	6af1      	ldr	r1, [r6, #44]	; 0x2c
 800286c:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
							xSwitchRequired = pdTRUE;
 800286e:	4291      	cmp	r1, r2
 8002870:	bf28      	it	cs
 8002872:	f04f 0b01 	movcs.w	fp, #1
 8002876:	e7d3      	b.n	8002820 <xTaskIncrementTick+0x5c>
		++uxPendedTicks;
 8002878:	4a18      	ldr	r2, [pc, #96]	; (80028dc <xTaskIncrementTick+0x118>)
BaseType_t xSwitchRequired = pdFALSE;
 800287a:	f04f 0b00 	mov.w	fp, #0
		++uxPendedTicks;
 800287e:	6813      	ldr	r3, [r2, #0]
 8002880:	3301      	adds	r3, #1
 8002882:	6013      	str	r3, [r2, #0]
 8002884:	e011      	b.n	80028aa <xTaskIncrementTick+0xe6>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8002886:	f8d8 2000 	ldr.w	r2, [r8]
 800288a:	68d2      	ldr	r2, [r2, #12]
 800288c:	68d6      	ldr	r6, [r2, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 800288e:	6871      	ldr	r1, [r6, #4]
					if( xConstTickCount < xItemValue )
 8002890:	428c      	cmp	r4, r1
 8002892:	d2cd      	bcs.n	8002830 <xTaskIncrementTick+0x6c>
						xNextTaskUnblockTime = xItemValue;
 8002894:	6029      	str	r1, [r5, #0]
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 8002896:	683a      	ldr	r2, [r7, #0]
 8002898:	4b0f      	ldr	r3, [pc, #60]	; (80028d8 <xTaskIncrementTick+0x114>)
 800289a:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
 800289c:	2214      	movs	r2, #20
 800289e:	434a      	muls	r2, r1
 80028a0:	589a      	ldr	r2, [r3, r2]
				xSwitchRequired = pdTRUE;
 80028a2:	2a02      	cmp	r2, #2
 80028a4:	bf28      	it	cs
 80028a6:	f04f 0b01 	movcs.w	fp, #1
		if( xYieldPending != pdFALSE )
 80028aa:	4a0d      	ldr	r2, [pc, #52]	; (80028e0 <xTaskIncrementTick+0x11c>)
 80028ac:	6812      	ldr	r2, [r2, #0]
			xSwitchRequired = pdTRUE;
 80028ae:	2a00      	cmp	r2, #0
 80028b0:	bf18      	it	ne
 80028b2:	f04f 0b01 	movne.w	fp, #1
}
 80028b6:	4658      	mov	r0, fp
 80028b8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80028bc:	20003d94 	.word	0x20003d94
 80028c0:	20003e14 	.word	0x20003e14
 80028c4:	20003d1c 	.word	0x20003d1c
 80028c8:	20003d20 	.word	0x20003d20
 80028cc:	20003dd0 	.word	0x20003dd0
 80028d0:	20003dcc 	.word	0x20003dcc
 80028d4:	20003d18 	.word	0x20003d18
 80028d8:	20003d24 	.word	0x20003d24
 80028dc:	20003d90 	.word	0x20003d90
 80028e0:	20003e18 	.word	0x20003e18
 80028e4:	20003d9c 	.word	0x20003d9c

080028e8 <xTaskResumeAll>:
{
 80028e8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	configASSERT( uxSchedulerSuspended );
 80028ec:	4c31      	ldr	r4, [pc, #196]	; (80029b4 <xTaskResumeAll+0xcc>)
 80028ee:	6823      	ldr	r3, [r4, #0]
 80028f0:	b943      	cbnz	r3, 8002904 <xTaskResumeAll+0x1c>
 80028f2:	f04f 0350 	mov.w	r3, #80	; 0x50
 80028f6:	f383 8811 	msr	BASEPRI, r3
 80028fa:	f3bf 8f6f 	isb	sy
 80028fe:	f3bf 8f4f 	dsb	sy
 8002902:	e7fe      	b.n	8002902 <xTaskResumeAll+0x1a>
	taskENTER_CRITICAL();
 8002904:	f7ff f876 	bl	80019f4 <vPortEnterCritical>
		--uxSchedulerSuspended;
 8002908:	6823      	ldr	r3, [r4, #0]
 800290a:	3b01      	subs	r3, #1
 800290c:	6023      	str	r3, [r4, #0]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800290e:	6824      	ldr	r4, [r4, #0]
 8002910:	b12c      	cbz	r4, 800291e <xTaskResumeAll+0x36>
BaseType_t xAlreadyYielded = pdFALSE;
 8002912:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 8002914:	f7ff f890 	bl	8001a38 <vPortExitCritical>
}
 8002918:	4620      	mov	r0, r4
 800291a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 800291e:	4b26      	ldr	r3, [pc, #152]	; (80029b8 <xTaskResumeAll+0xd0>)
 8002920:	681b      	ldr	r3, [r3, #0]
 8002922:	2b00      	cmp	r3, #0
 8002924:	d0f5      	beq.n	8002912 <xTaskResumeAll+0x2a>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8002926:	f8df 90a8 	ldr.w	r9, [pc, #168]	; 80029d0 <xTaskResumeAll+0xe8>
					prvAddTaskToReadyList( pxTCB );
 800292a:	4f24      	ldr	r7, [pc, #144]	; (80029bc <xTaskResumeAll+0xd4>)
 800292c:	f8df 80a4 	ldr.w	r8, [pc, #164]	; 80029d4 <xTaskResumeAll+0xec>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8002930:	f8d9 3000 	ldr.w	r3, [r9]
 8002934:	b9e3      	cbnz	r3, 8002970 <xTaskResumeAll+0x88>
				if( pxTCB != NULL )
 8002936:	b10c      	cbz	r4, 800293c <xTaskResumeAll+0x54>
					prvResetNextTaskUnblockTime();
 8002938:	f7ff fd1c 	bl	8002374 <prvResetNextTaskUnblockTime>
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 800293c:	4d20      	ldr	r5, [pc, #128]	; (80029c0 <xTaskResumeAll+0xd8>)
 800293e:	682c      	ldr	r4, [r5, #0]
					if( uxPendedCounts > ( UBaseType_t ) 0U )
 8002940:	b144      	cbz	r4, 8002954 <xTaskResumeAll+0x6c>
								xYieldPending = pdTRUE;
 8002942:	2701      	movs	r7, #1
 8002944:	4e1f      	ldr	r6, [pc, #124]	; (80029c4 <xTaskResumeAll+0xdc>)
							if( xTaskIncrementTick() != pdFALSE )
 8002946:	f7ff ff3d 	bl	80027c4 <xTaskIncrementTick>
 800294a:	b100      	cbz	r0, 800294e <xTaskResumeAll+0x66>
								xYieldPending = pdTRUE;
 800294c:	6037      	str	r7, [r6, #0]
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 800294e:	3c01      	subs	r4, #1
 8002950:	d1f9      	bne.n	8002946 <xTaskResumeAll+0x5e>
						uxPendedTicks = 0;
 8002952:	602c      	str	r4, [r5, #0]
				if( xYieldPending != pdFALSE )
 8002954:	4b1b      	ldr	r3, [pc, #108]	; (80029c4 <xTaskResumeAll+0xdc>)
 8002956:	681b      	ldr	r3, [r3, #0]
 8002958:	2b00      	cmp	r3, #0
 800295a:	d0da      	beq.n	8002912 <xTaskResumeAll+0x2a>
					taskYIELD_IF_USING_PREEMPTION();
 800295c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8002960:	4b19      	ldr	r3, [pc, #100]	; (80029c8 <xTaskResumeAll+0xe0>)
 8002962:	601a      	str	r2, [r3, #0]
 8002964:	f3bf 8f4f 	dsb	sy
 8002968:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
 800296c:	2401      	movs	r4, #1
 800296e:	e7d1      	b.n	8002914 <xTaskResumeAll+0x2c>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 8002970:	f8d9 300c 	ldr.w	r3, [r9, #12]
					prvAddTaskToReadyList( pxTCB );
 8002974:	2501      	movs	r5, #1
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 8002976:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8002978:	1d26      	adds	r6, r4, #4
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800297a:	f104 0018 	add.w	r0, r4, #24
 800297e:	f7fe ffcf 	bl	8001920 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8002982:	4630      	mov	r0, r6
 8002984:	f7fe ffcc 	bl	8001920 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8002988:	2014      	movs	r0, #20
 800298a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800298c:	6839      	ldr	r1, [r7, #0]
 800298e:	fa05 f302 	lsl.w	r3, r5, r2
 8002992:	430b      	orrs	r3, r1
 8002994:	fb00 8002 	mla	r0, r0, r2, r8
 8002998:	4631      	mov	r1, r6
 800299a:	603b      	str	r3, [r7, #0]
 800299c:	f7fe ff9d 	bl	80018da <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 80029a0:	4b0a      	ldr	r3, [pc, #40]	; (80029cc <xTaskResumeAll+0xe4>)
 80029a2:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80029a4:	681b      	ldr	r3, [r3, #0]
 80029a6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80029a8:	429a      	cmp	r2, r3
						xYieldPending = pdTRUE;
 80029aa:	bf24      	itt	cs
 80029ac:	4b05      	ldrcs	r3, [pc, #20]	; (80029c4 <xTaskResumeAll+0xdc>)
 80029ae:	601d      	strcs	r5, [r3, #0]
 80029b0:	e7be      	b.n	8002930 <xTaskResumeAll+0x48>
 80029b2:	bf00      	nop
 80029b4:	20003d94 	.word	0x20003d94
 80029b8:	20003d88 	.word	0x20003d88
 80029bc:	20003d9c 	.word	0x20003d9c
 80029c0:	20003d90 	.word	0x20003d90
 80029c4:	20003e18 	.word	0x20003e18
 80029c8:	e000ed04 	.word	0xe000ed04
 80029cc:	20003d18 	.word	0x20003d18
 80029d0:	20003dd4 	.word	0x20003dd4
 80029d4:	20003d24 	.word	0x20003d24

080029d8 <vTaskDelay>:
	{
 80029d8:	b508      	push	{r3, lr}
		if( xTicksToDelay > ( TickType_t ) 0U )
 80029da:	b940      	cbnz	r0, 80029ee <vTaskDelay+0x16>
			portYIELD_WITHIN_API();
 80029dc:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80029e0:	4b0d      	ldr	r3, [pc, #52]	; (8002a18 <vTaskDelay+0x40>)
 80029e2:	601a      	str	r2, [r3, #0]
 80029e4:	f3bf 8f4f 	dsb	sy
 80029e8:	f3bf 8f6f 	isb	sy
 80029ec:	bd08      	pop	{r3, pc}
			configASSERT( uxSchedulerSuspended == 0 );
 80029ee:	4b0b      	ldr	r3, [pc, #44]	; (8002a1c <vTaskDelay+0x44>)
 80029f0:	6819      	ldr	r1, [r3, #0]
 80029f2:	b141      	cbz	r1, 8002a06 <vTaskDelay+0x2e>
 80029f4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80029f8:	f383 8811 	msr	BASEPRI, r3
 80029fc:	f3bf 8f6f 	isb	sy
 8002a00:	f3bf 8f4f 	dsb	sy
 8002a04:	e7fe      	b.n	8002a04 <vTaskDelay+0x2c>
			vTaskSuspendAll();
 8002a06:	f7ff fecf 	bl	80027a8 <vTaskSuspendAll>
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 8002a0a:	f7ff fcc5 	bl	8002398 <prvAddCurrentTaskToDelayedList>
			xAlreadyYielded = xTaskResumeAll();
 8002a0e:	f7ff ff6b 	bl	80028e8 <xTaskResumeAll>
		if( xAlreadyYielded == pdFALSE )
 8002a12:	2800      	cmp	r0, #0
 8002a14:	d0e2      	beq.n	80029dc <vTaskDelay+0x4>
 8002a16:	bd08      	pop	{r3, pc}
 8002a18:	e000ed04 	.word	0xe000ed04
 8002a1c:	20003d94 	.word	0x20003d94

08002a20 <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8002a20:	4b17      	ldr	r3, [pc, #92]	; (8002a80 <vTaskSwitchContext+0x60>)
{
 8002a22:	b510      	push	{r4, lr}
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8002a24:	681a      	ldr	r2, [r3, #0]
 8002a26:	4b17      	ldr	r3, [pc, #92]	; (8002a84 <vTaskSwitchContext+0x64>)
 8002a28:	b112      	cbz	r2, 8002a30 <vTaskSwitchContext+0x10>
		xYieldPending = pdTRUE;
 8002a2a:	2201      	movs	r2, #1
		taskSELECT_HIGHEST_PRIORITY_TASK();
 8002a2c:	601a      	str	r2, [r3, #0]
 8002a2e:	bd10      	pop	{r4, pc}
		xYieldPending = pdFALSE;
 8002a30:	601a      	str	r2, [r3, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK();
 8002a32:	4b15      	ldr	r3, [pc, #84]	; (8002a88 <vTaskSwitchContext+0x68>)
 8002a34:	681b      	ldr	r3, [r3, #0]
		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
 8002a36:	fab3 f383 	clz	r3, r3
 8002a3a:	2214      	movs	r2, #20
 8002a3c:	b2db      	uxtb	r3, r3
 8002a3e:	f1c3 031f 	rsb	r3, r3, #31
 8002a42:	435a      	muls	r2, r3
 8002a44:	4911      	ldr	r1, [pc, #68]	; (8002a8c <vTaskSwitchContext+0x6c>)
 8002a46:	588c      	ldr	r4, [r1, r2]
 8002a48:	1888      	adds	r0, r1, r2
 8002a4a:	b944      	cbnz	r4, 8002a5e <vTaskSwitchContext+0x3e>
	__asm volatile
 8002a4c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002a50:	f383 8811 	msr	BASEPRI, r3
 8002a54:	f3bf 8f6f 	isb	sy
 8002a58:	f3bf 8f4f 	dsb	sy
 8002a5c:	e7fe      	b.n	8002a5c <vTaskSwitchContext+0x3c>
 8002a5e:	6844      	ldr	r4, [r0, #4]
 8002a60:	3208      	adds	r2, #8
 8002a62:	6864      	ldr	r4, [r4, #4]
 8002a64:	440a      	add	r2, r1
 8002a66:	4294      	cmp	r4, r2
 8002a68:	bf08      	it	eq
 8002a6a:	6862      	ldreq	r2, [r4, #4]
 8002a6c:	6044      	str	r4, [r0, #4]
 8002a6e:	bf08      	it	eq
 8002a70:	6042      	streq	r2, [r0, #4]
 8002a72:	2214      	movs	r2, #20
 8002a74:	fb02 1303 	mla	r3, r2, r3, r1
 8002a78:	685b      	ldr	r3, [r3, #4]
 8002a7a:	68da      	ldr	r2, [r3, #12]
 8002a7c:	4b04      	ldr	r3, [pc, #16]	; (8002a90 <vTaskSwitchContext+0x70>)
 8002a7e:	e7d5      	b.n	8002a2c <vTaskSwitchContext+0xc>
 8002a80:	20003d94 	.word	0x20003d94
 8002a84:	20003e18 	.word	0x20003e18
 8002a88:	20003d9c 	.word	0x20003d9c
 8002a8c:	20003d24 	.word	0x20003d24
 8002a90:	20003d18 	.word	0x20003d18

08002a94 <vTaskPlaceOnEventList>:
{
 8002a94:	b510      	push	{r4, lr}
 8002a96:	460c      	mov	r4, r1
	configASSERT( pxEventList );
 8002a98:	b940      	cbnz	r0, 8002aac <vTaskPlaceOnEventList+0x18>
 8002a9a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002a9e:	f383 8811 	msr	BASEPRI, r3
 8002aa2:	f3bf 8f6f 	isb	sy
 8002aa6:	f3bf 8f4f 	dsb	sy
 8002aaa:	e7fe      	b.n	8002aaa <vTaskPlaceOnEventList+0x16>
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8002aac:	4b05      	ldr	r3, [pc, #20]	; (8002ac4 <vTaskPlaceOnEventList+0x30>)
 8002aae:	6819      	ldr	r1, [r3, #0]
 8002ab0:	3118      	adds	r1, #24
 8002ab2:	f7fe ff1e 	bl	80018f2 <vListInsert>
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 8002ab6:	4620      	mov	r0, r4
}
 8002ab8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 8002abc:	2101      	movs	r1, #1
 8002abe:	f7ff bc6b 	b.w	8002398 <prvAddCurrentTaskToDelayedList>
 8002ac2:	bf00      	nop
 8002ac4:	20003d18 	.word	0x20003d18

08002ac8 <vTaskPlaceOnEventListRestricted>:
	{
 8002ac8:	b538      	push	{r3, r4, r5, lr}
 8002aca:	460d      	mov	r5, r1
 8002acc:	4614      	mov	r4, r2
		configASSERT( pxEventList );
 8002ace:	b940      	cbnz	r0, 8002ae2 <vTaskPlaceOnEventListRestricted+0x1a>
 8002ad0:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002ad4:	f383 8811 	msr	BASEPRI, r3
 8002ad8:	f3bf 8f6f 	isb	sy
 8002adc:	f3bf 8f4f 	dsb	sy
 8002ae0:	e7fe      	b.n	8002ae0 <vTaskPlaceOnEventListRestricted+0x18>
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8002ae2:	4b08      	ldr	r3, [pc, #32]	; (8002b04 <vTaskPlaceOnEventListRestricted+0x3c>)
 8002ae4:	6819      	ldr	r1, [r3, #0]
 8002ae6:	3118      	adds	r1, #24
 8002ae8:	f7fe fef7 	bl	80018da <vListInsertEnd>
			xTicksToWait = portMAX_DELAY;
 8002aec:	2c00      	cmp	r4, #0
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
 8002aee:	4621      	mov	r1, r4
 8002af0:	bf08      	it	eq
 8002af2:	4628      	moveq	r0, r5
	}
 8002af4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
 8002af8:	bf18      	it	ne
 8002afa:	f04f 30ff 	movne.w	r0, #4294967295
 8002afe:	f7ff bc4b 	b.w	8002398 <prvAddCurrentTaskToDelayedList>
 8002b02:	bf00      	nop
 8002b04:	20003d18 	.word	0x20003d18

08002b08 <xTaskRemoveFromEventList>:
{
 8002b08:	b538      	push	{r3, r4, r5, lr}
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 8002b0a:	68c3      	ldr	r3, [r0, #12]
 8002b0c:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
 8002b0e:	b944      	cbnz	r4, 8002b22 <xTaskRemoveFromEventList+0x1a>
 8002b10:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002b14:	f383 8811 	msr	BASEPRI, r3
 8002b18:	f3bf 8f6f 	isb	sy
 8002b1c:	f3bf 8f4f 	dsb	sy
 8002b20:	e7fe      	b.n	8002b20 <xTaskRemoveFromEventList+0x18>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 8002b22:	f104 0518 	add.w	r5, r4, #24
 8002b26:	4628      	mov	r0, r5
 8002b28:	f7fe fefa 	bl	8001920 <uxListRemove>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8002b2c:	4b11      	ldr	r3, [pc, #68]	; (8002b74 <xTaskRemoveFromEventList+0x6c>)
 8002b2e:	681b      	ldr	r3, [r3, #0]
 8002b30:	b9e3      	cbnz	r3, 8002b6c <xTaskRemoveFromEventList+0x64>
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 8002b32:	1d25      	adds	r5, r4, #4
 8002b34:	4628      	mov	r0, r5
 8002b36:	f7fe fef3 	bl	8001920 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 8002b3a:	2301      	movs	r3, #1
 8002b3c:	490e      	ldr	r1, [pc, #56]	; (8002b78 <xTaskRemoveFromEventList+0x70>)
 8002b3e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8002b40:	6808      	ldr	r0, [r1, #0]
 8002b42:	4093      	lsls	r3, r2
 8002b44:	4303      	orrs	r3, r0
 8002b46:	2014      	movs	r0, #20
 8002b48:	600b      	str	r3, [r1, #0]
 8002b4a:	4629      	mov	r1, r5
 8002b4c:	4b0b      	ldr	r3, [pc, #44]	; (8002b7c <xTaskRemoveFromEventList+0x74>)
 8002b4e:	fb00 3002 	mla	r0, r0, r2, r3
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8002b52:	f7fe fec2 	bl	80018da <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 8002b56:	4b0a      	ldr	r3, [pc, #40]	; (8002b80 <xTaskRemoveFromEventList+0x78>)
 8002b58:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8002b5a:	681b      	ldr	r3, [r3, #0]
 8002b5c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8002b5e:	429a      	cmp	r2, r3
		xYieldPending = pdTRUE;
 8002b60:	bf85      	ittet	hi
 8002b62:	2001      	movhi	r0, #1
 8002b64:	4b07      	ldrhi	r3, [pc, #28]	; (8002b84 <xTaskRemoveFromEventList+0x7c>)
		xReturn = pdFALSE;
 8002b66:	2000      	movls	r0, #0
		xYieldPending = pdTRUE;
 8002b68:	6018      	strhi	r0, [r3, #0]
}
 8002b6a:	bd38      	pop	{r3, r4, r5, pc}
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8002b6c:	4629      	mov	r1, r5
 8002b6e:	4806      	ldr	r0, [pc, #24]	; (8002b88 <xTaskRemoveFromEventList+0x80>)
 8002b70:	e7ef      	b.n	8002b52 <xTaskRemoveFromEventList+0x4a>
 8002b72:	bf00      	nop
 8002b74:	20003d94 	.word	0x20003d94
 8002b78:	20003d9c 	.word	0x20003d9c
 8002b7c:	20003d24 	.word	0x20003d24
 8002b80:	20003d18 	.word	0x20003d18
 8002b84:	20003e18 	.word	0x20003e18
 8002b88:	20003dd4 	.word	0x20003dd4

08002b8c <vTaskInternalSetTimeOutState>:
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 8002b8c:	4b03      	ldr	r3, [pc, #12]	; (8002b9c <vTaskInternalSetTimeOutState+0x10>)
 8002b8e:	681b      	ldr	r3, [r3, #0]
 8002b90:	6003      	str	r3, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 8002b92:	4b03      	ldr	r3, [pc, #12]	; (8002ba0 <vTaskInternalSetTimeOutState+0x14>)
 8002b94:	681b      	ldr	r3, [r3, #0]
 8002b96:	6043      	str	r3, [r0, #4]
 8002b98:	4770      	bx	lr
 8002b9a:	bf00      	nop
 8002b9c:	20003dd0 	.word	0x20003dd0
 8002ba0:	20003e14 	.word	0x20003e14

08002ba4 <xTaskCheckForTimeOut>:
{
 8002ba4:	b570      	push	{r4, r5, r6, lr}
 8002ba6:	460c      	mov	r4, r1
	configASSERT( pxTimeOut );
 8002ba8:	4605      	mov	r5, r0
 8002baa:	b940      	cbnz	r0, 8002bbe <xTaskCheckForTimeOut+0x1a>
 8002bac:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002bb0:	f383 8811 	msr	BASEPRI, r3
 8002bb4:	f3bf 8f6f 	isb	sy
 8002bb8:	f3bf 8f4f 	dsb	sy
 8002bbc:	e7fe      	b.n	8002bbc <xTaskCheckForTimeOut+0x18>
	configASSERT( pxTicksToWait );
 8002bbe:	b941      	cbnz	r1, 8002bd2 <xTaskCheckForTimeOut+0x2e>
 8002bc0:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002bc4:	f383 8811 	msr	BASEPRI, r3
 8002bc8:	f3bf 8f6f 	isb	sy
 8002bcc:	f3bf 8f4f 	dsb	sy
 8002bd0:	e7fe      	b.n	8002bd0 <xTaskCheckForTimeOut+0x2c>
	taskENTER_CRITICAL();
 8002bd2:	f7fe ff0f 	bl	80019f4 <vPortEnterCritical>
		const TickType_t xConstTickCount = xTickCount;
 8002bd6:	4b0f      	ldr	r3, [pc, #60]	; (8002c14 <xTaskCheckForTimeOut+0x70>)
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 8002bd8:	6869      	ldr	r1, [r5, #4]
		const TickType_t xConstTickCount = xTickCount;
 8002bda:	681a      	ldr	r2, [r3, #0]
			if( *pxTicksToWait == portMAX_DELAY )
 8002bdc:	6823      	ldr	r3, [r4, #0]
 8002bde:	1c58      	adds	r0, r3, #1
 8002be0:	d00e      	beq.n	8002c00 <xTaskCheckForTimeOut+0x5c>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 8002be2:	480d      	ldr	r0, [pc, #52]	; (8002c18 <xTaskCheckForTimeOut+0x74>)
 8002be4:	682e      	ldr	r6, [r5, #0]
 8002be6:	6800      	ldr	r0, [r0, #0]
 8002be8:	4286      	cmp	r6, r0
 8002bea:	d001      	beq.n	8002bf0 <xTaskCheckForTimeOut+0x4c>
 8002bec:	428a      	cmp	r2, r1
 8002bee:	d20e      	bcs.n	8002c0e <xTaskCheckForTimeOut+0x6a>
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 8002bf0:	1a52      	subs	r2, r2, r1
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 8002bf2:	429a      	cmp	r2, r3
 8002bf4:	d209      	bcs.n	8002c0a <xTaskCheckForTimeOut+0x66>
			*pxTicksToWait -= xElapsedTime;
 8002bf6:	1a9b      	subs	r3, r3, r2
 8002bf8:	6023      	str	r3, [r4, #0]
			vTaskInternalSetTimeOutState( pxTimeOut );
 8002bfa:	4628      	mov	r0, r5
 8002bfc:	f7ff ffc6 	bl	8002b8c <vTaskInternalSetTimeOutState>
				xReturn = pdFALSE;
 8002c00:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 8002c02:	f7fe ff19 	bl	8001a38 <vPortExitCritical>
}
 8002c06:	4620      	mov	r0, r4
 8002c08:	bd70      	pop	{r4, r5, r6, pc}
			*pxTicksToWait = 0;
 8002c0a:	2300      	movs	r3, #0
 8002c0c:	6023      	str	r3, [r4, #0]
			xReturn = pdTRUE;
 8002c0e:	2401      	movs	r4, #1
 8002c10:	e7f7      	b.n	8002c02 <xTaskCheckForTimeOut+0x5e>
 8002c12:	bf00      	nop
 8002c14:	20003e14 	.word	0x20003e14
 8002c18:	20003dd0 	.word	0x20003dd0

08002c1c <vTaskMissedYield>:
	xYieldPending = pdTRUE;
 8002c1c:	2201      	movs	r2, #1
 8002c1e:	4b01      	ldr	r3, [pc, #4]	; (8002c24 <vTaskMissedYield+0x8>)
 8002c20:	601a      	str	r2, [r3, #0]
 8002c22:	4770      	bx	lr
 8002c24:	20003e18 	.word	0x20003e18

08002c28 <xTaskGetSchedulerState>:
		if( xSchedulerRunning == pdFALSE )
 8002c28:	4b05      	ldr	r3, [pc, #20]	; (8002c40 <xTaskGetSchedulerState+0x18>)
 8002c2a:	681b      	ldr	r3, [r3, #0]
 8002c2c:	b133      	cbz	r3, 8002c3c <xTaskGetSchedulerState+0x14>
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8002c2e:	4b05      	ldr	r3, [pc, #20]	; (8002c44 <xTaskGetSchedulerState+0x1c>)
 8002c30:	681b      	ldr	r3, [r3, #0]
 8002c32:	2b00      	cmp	r3, #0
				xReturn = taskSCHEDULER_SUSPENDED;
 8002c34:	bf0c      	ite	eq
 8002c36:	2002      	moveq	r0, #2
 8002c38:	2000      	movne	r0, #0
 8002c3a:	4770      	bx	lr
			xReturn = taskSCHEDULER_NOT_STARTED;
 8002c3c:	2001      	movs	r0, #1
	}
 8002c3e:	4770      	bx	lr
 8002c40:	20003de8 	.word	0x20003de8
 8002c44:	20003d94 	.word	0x20003d94

08002c48 <xTaskPriorityDisinherit>:
	{
 8002c48:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		if( pxMutexHolder != NULL )
 8002c4a:	4604      	mov	r4, r0
 8002c4c:	b908      	cbnz	r0, 8002c52 <xTaskPriorityDisinherit+0xa>
	BaseType_t xReturn = pdFALSE;
 8002c4e:	2000      	movs	r0, #0
 8002c50:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			configASSERT( pxTCB == pxCurrentTCB );
 8002c52:	4b22      	ldr	r3, [pc, #136]	; (8002cdc <xTaskPriorityDisinherit+0x94>)
 8002c54:	681b      	ldr	r3, [r3, #0]
 8002c56:	4298      	cmp	r0, r3
 8002c58:	d008      	beq.n	8002c6c <xTaskPriorityDisinherit+0x24>
 8002c5a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002c5e:	f383 8811 	msr	BASEPRI, r3
 8002c62:	f3bf 8f6f 	isb	sy
 8002c66:	f3bf 8f4f 	dsb	sy
 8002c6a:	e7fe      	b.n	8002c6a <xTaskPriorityDisinherit+0x22>
			configASSERT( pxTCB->uxMutexesHeld );
 8002c6c:	6c43      	ldr	r3, [r0, #68]	; 0x44
 8002c6e:	b943      	cbnz	r3, 8002c82 <xTaskPriorityDisinherit+0x3a>
 8002c70:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002c74:	f383 8811 	msr	BASEPRI, r3
 8002c78:	f3bf 8f6f 	isb	sy
 8002c7c:	f3bf 8f4f 	dsb	sy
 8002c80:	e7fe      	b.n	8002c80 <xTaskPriorityDisinherit+0x38>
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8002c82:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 8002c84:	6c02      	ldr	r2, [r0, #64]	; 0x40
			( pxTCB->uxMutexesHeld )--;
 8002c86:	3b01      	subs	r3, #1
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8002c88:	4291      	cmp	r1, r2
			( pxTCB->uxMutexesHeld )--;
 8002c8a:	6443      	str	r3, [r0, #68]	; 0x44
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8002c8c:	d0df      	beq.n	8002c4e <xTaskPriorityDisinherit+0x6>
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 8002c8e:	2b00      	cmp	r3, #0
 8002c90:	d1dd      	bne.n	8002c4e <xTaskPriorityDisinherit+0x6>
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8002c92:	1d05      	adds	r5, r0, #4
 8002c94:	4628      	mov	r0, r5
 8002c96:	f7fe fe43 	bl	8001920 <uxListRemove>
 8002c9a:	4e11      	ldr	r6, [pc, #68]	; (8002ce0 <xTaskPriorityDisinherit+0x98>)
 8002c9c:	4a11      	ldr	r2, [pc, #68]	; (8002ce4 <xTaskPriorityDisinherit+0x9c>)
 8002c9e:	b950      	cbnz	r0, 8002cb6 <xTaskPriorityDisinherit+0x6e>
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 8002ca0:	2114      	movs	r1, #20
 8002ca2:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
 8002ca4:	4379      	muls	r1, r7
 8002ca6:	5873      	ldr	r3, [r6, r1]
 8002ca8:	b92b      	cbnz	r3, 8002cb6 <xTaskPriorityDisinherit+0x6e>
 8002caa:	2001      	movs	r0, #1
 8002cac:	6813      	ldr	r3, [r2, #0]
 8002cae:	40b8      	lsls	r0, r7
 8002cb0:	ea23 0300 	bic.w	r3, r3, r0
 8002cb4:	6013      	str	r3, [r2, #0]
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 8002cb6:	6c23      	ldr	r3, [r4, #64]	; 0x40
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8002cb8:	f1c3 0105 	rsb	r1, r3, #5
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 8002cbc:	62e3      	str	r3, [r4, #44]	; 0x2c
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8002cbe:	61a1      	str	r1, [r4, #24]
					prvAddTaskToReadyList( pxTCB );
 8002cc0:	2401      	movs	r4, #1
 8002cc2:	6811      	ldr	r1, [r2, #0]
 8002cc4:	fa04 f003 	lsl.w	r0, r4, r3
 8002cc8:	4308      	orrs	r0, r1
 8002cca:	6010      	str	r0, [r2, #0]
 8002ccc:	2014      	movs	r0, #20
 8002cce:	4629      	mov	r1, r5
 8002cd0:	fb00 6003 	mla	r0, r0, r3, r6
 8002cd4:	f7fe fe01 	bl	80018da <vListInsertEnd>
					xReturn = pdTRUE;
 8002cd8:	4620      	mov	r0, r4
	}
 8002cda:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002cdc:	20003d18 	.word	0x20003d18
 8002ce0:	20003d24 	.word	0x20003d24
 8002ce4:	20003d9c 	.word	0x20003d9c

08002ce8 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
 8002ce8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
	{
		if( xTimerQueue == NULL )
 8002cea:	4c0d      	ldr	r4, [pc, #52]	; (8002d20 <prvCheckForValidListAndQueue+0x38>)
	taskENTER_CRITICAL();
 8002cec:	f7fe fe82 	bl	80019f4 <vPortEnterCritical>
		if( xTimerQueue == NULL )
 8002cf0:	6825      	ldr	r5, [r4, #0]
 8002cf2:	b98d      	cbnz	r5, 8002d18 <prvCheckForValidListAndQueue+0x30>
		{
			vListInitialise( &xActiveTimerList1 );
 8002cf4:	4f0b      	ldr	r7, [pc, #44]	; (8002d24 <prvCheckForValidListAndQueue+0x3c>)
			vListInitialise( &xActiveTimerList2 );
 8002cf6:	4e0c      	ldr	r6, [pc, #48]	; (8002d28 <prvCheckForValidListAndQueue+0x40>)
			vListInitialise( &xActiveTimerList1 );
 8002cf8:	4638      	mov	r0, r7
 8002cfa:	f7fe fde0 	bl	80018be <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
 8002cfe:	4630      	mov	r0, r6
 8002d00:	f7fe fddd 	bl	80018be <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
 8002d04:	4b09      	ldr	r3, [pc, #36]	; (8002d2c <prvCheckForValidListAndQueue+0x44>)

				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
			}
			#else
			{
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
 8002d06:	462a      	mov	r2, r5
			pxCurrentTimerList = &xActiveTimerList1;
 8002d08:	601f      	str	r7, [r3, #0]
			pxOverflowTimerList = &xActiveTimerList2;
 8002d0a:	4b09      	ldr	r3, [pc, #36]	; (8002d30 <prvCheckForValidListAndQueue+0x48>)
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
 8002d0c:	210c      	movs	r1, #12
 8002d0e:	2005      	movs	r0, #5
			pxOverflowTimerList = &xActiveTimerList2;
 8002d10:	601e      	str	r6, [r3, #0]
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
 8002d12:	f7ff f92d 	bl	8001f70 <xQueueGenericCreate>
 8002d16:	6020      	str	r0, [r4, #0]
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
}
 8002d18:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	taskEXIT_CRITICAL();
 8002d1c:	f7fe be8c 	b.w	8001a38 <vPortExitCritical>
 8002d20:	20003e50 	.word	0x20003e50
 8002d24:	20003e24 	.word	0x20003e24
 8002d28:	20003e38 	.word	0x20003e38
 8002d2c:	20003e1c 	.word	0x20003e1c
 8002d30:	20003e20 	.word	0x20003e20

08002d34 <prvInsertTimerInActiveList>:
	if( xNextExpiryTime <= xTimeNow )
 8002d34:	4291      	cmp	r1, r2
{
 8002d36:	b508      	push	{r3, lr}
	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 8002d38:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8002d3a:	6100      	str	r0, [r0, #16]
	if( xNextExpiryTime <= xTimeNow )
 8002d3c:	d80a      	bhi.n	8002d54 <prvInsertTimerInActiveList+0x20>
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8002d3e:	1ad2      	subs	r2, r2, r3
 8002d40:	6983      	ldr	r3, [r0, #24]
 8002d42:	429a      	cmp	r2, r3
 8002d44:	d20d      	bcs.n	8002d62 <prvInsertTimerInActiveList+0x2e>
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 8002d46:	4b08      	ldr	r3, [pc, #32]	; (8002d68 <prvInsertTimerInActiveList+0x34>)
 8002d48:	1d01      	adds	r1, r0, #4
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8002d4a:	6818      	ldr	r0, [r3, #0]
 8002d4c:	f7fe fdd1 	bl	80018f2 <vListInsert>
BaseType_t xProcessTimerNow = pdFALSE;
 8002d50:	2000      	movs	r0, #0
 8002d52:	bd08      	pop	{r3, pc}
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 8002d54:	429a      	cmp	r2, r3
 8002d56:	d201      	bcs.n	8002d5c <prvInsertTimerInActiveList+0x28>
 8002d58:	4299      	cmp	r1, r3
 8002d5a:	d202      	bcs.n	8002d62 <prvInsertTimerInActiveList+0x2e>
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8002d5c:	1d01      	adds	r1, r0, #4
 8002d5e:	4b03      	ldr	r3, [pc, #12]	; (8002d6c <prvInsertTimerInActiveList+0x38>)
 8002d60:	e7f3      	b.n	8002d4a <prvInsertTimerInActiveList+0x16>
			xProcessTimerNow = pdTRUE;
 8002d62:	2001      	movs	r0, #1
}
 8002d64:	bd08      	pop	{r3, pc}
 8002d66:	bf00      	nop
 8002d68:	20003e20 	.word	0x20003e20
 8002d6c:	20003e1c 	.word	0x20003e1c

08002d70 <xTimerCreateTimerTask>:
{
 8002d70:	b507      	push	{r0, r1, r2, lr}
	prvCheckForValidListAndQueue();
 8002d72:	f7ff ffb9 	bl	8002ce8 <prvCheckForValidListAndQueue>
	if( xTimerQueue != NULL )
 8002d76:	4b0d      	ldr	r3, [pc, #52]	; (8002dac <xTimerCreateTimerTask+0x3c>)
 8002d78:	681b      	ldr	r3, [r3, #0]
 8002d7a:	b943      	cbnz	r3, 8002d8e <xTimerCreateTimerTask+0x1e>
 8002d7c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002d80:	f383 8811 	msr	BASEPRI, r3
 8002d84:	f3bf 8f6f 	isb	sy
 8002d88:	f3bf 8f4f 	dsb	sy
 8002d8c:	e7fe      	b.n	8002d8c <xTimerCreateTimerTask+0x1c>
			xReturn = xTaskCreate(	prvTimerTask,
 8002d8e:	4b08      	ldr	r3, [pc, #32]	; (8002db0 <xTimerCreateTimerTask+0x40>)
 8002d90:	2246      	movs	r2, #70	; 0x46
 8002d92:	9301      	str	r3, [sp, #4]
 8002d94:	2303      	movs	r3, #3
 8002d96:	4907      	ldr	r1, [pc, #28]	; (8002db4 <xTimerCreateTimerTask+0x44>)
 8002d98:	9300      	str	r3, [sp, #0]
 8002d9a:	4807      	ldr	r0, [pc, #28]	; (8002db8 <xTimerCreateTimerTask+0x48>)
 8002d9c:	2300      	movs	r3, #0
 8002d9e:	f7ff fb77 	bl	8002490 <xTaskCreate>
	configASSERT( xReturn );
 8002da2:	2800      	cmp	r0, #0
 8002da4:	d0ea      	beq.n	8002d7c <xTimerCreateTimerTask+0xc>
}
 8002da6:	b003      	add	sp, #12
 8002da8:	f85d fb04 	ldr.w	pc, [sp], #4
 8002dac:	20003e50 	.word	0x20003e50
 8002db0:	20003e54 	.word	0x20003e54
 8002db4:	080039c8 	.word	0x080039c8
 8002db8:	08002e91 	.word	0x08002e91

08002dbc <xTimerGenericCommand>:
{
 8002dbc:	b530      	push	{r4, r5, lr}
 8002dbe:	4615      	mov	r5, r2
 8002dc0:	b085      	sub	sp, #20
 8002dc2:	461a      	mov	r2, r3
	configASSERT( xTimer );
 8002dc4:	4603      	mov	r3, r0
 8002dc6:	b940      	cbnz	r0, 8002dda <xTimerGenericCommand+0x1e>
 8002dc8:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002dcc:	f383 8811 	msr	BASEPRI, r3
 8002dd0:	f3bf 8f6f 	isb	sy
 8002dd4:	f3bf 8f4f 	dsb	sy
 8002dd8:	e7fe      	b.n	8002dd8 <xTimerGenericCommand+0x1c>
	if( xTimerQueue != NULL )
 8002dda:	4c0d      	ldr	r4, [pc, #52]	; (8002e10 <xTimerGenericCommand+0x54>)
 8002ddc:	6820      	ldr	r0, [r4, #0]
 8002dde:	b178      	cbz	r0, 8002e00 <xTimerGenericCommand+0x44>
		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
 8002de0:	2905      	cmp	r1, #5
		xMessage.xMessageID = xCommandID;
 8002de2:	9101      	str	r1, [sp, #4]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 8002de4:	9502      	str	r5, [sp, #8]
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
 8002de6:	9303      	str	r3, [sp, #12]
		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
 8002de8:	dc0c      	bgt.n	8002e04 <xTimerGenericCommand+0x48>
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 8002dea:	f7ff ff1d 	bl	8002c28 <xTaskGetSchedulerState>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 8002dee:	2300      	movs	r3, #0
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 8002df0:	2802      	cmp	r0, #2
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 8002df2:	bf0c      	ite	eq
 8002df4:	9a08      	ldreq	r2, [sp, #32]
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 8002df6:	461a      	movne	r2, r3
 8002df8:	a901      	add	r1, sp, #4
 8002dfa:	6820      	ldr	r0, [r4, #0]
 8002dfc:	f7ff f8da 	bl	8001fb4 <xQueueGenericSend>
}
 8002e00:	b005      	add	sp, #20
 8002e02:	bd30      	pop	{r4, r5, pc}
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 8002e04:	2300      	movs	r3, #0
 8002e06:	a901      	add	r1, sp, #4
 8002e08:	f7ff f98a 	bl	8002120 <xQueueGenericSendFromISR>
 8002e0c:	e7f8      	b.n	8002e00 <xTimerGenericCommand+0x44>
 8002e0e:	bf00      	nop
 8002e10:	20003e50 	.word	0x20003e50

08002e14 <prvSwitchTimerLists>:
{
 8002e14:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 8002e18:	f04f 0800 	mov.w	r8, #0
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 8002e1c:	4d1a      	ldr	r5, [pc, #104]	; (8002e88 <prvSwitchTimerLists+0x74>)
 8002e1e:	682b      	ldr	r3, [r5, #0]
 8002e20:	681a      	ldr	r2, [r3, #0]
 8002e22:	b932      	cbnz	r2, 8002e32 <prvSwitchTimerLists+0x1e>
	pxCurrentTimerList = pxOverflowTimerList;
 8002e24:	4a19      	ldr	r2, [pc, #100]	; (8002e8c <prvSwitchTimerLists+0x78>)
 8002e26:	6811      	ldr	r1, [r2, #0]
	pxOverflowTimerList = pxTemp;
 8002e28:	6013      	str	r3, [r2, #0]
	pxCurrentTimerList = pxOverflowTimerList;
 8002e2a:	6029      	str	r1, [r5, #0]
}
 8002e2c:	b002      	add	sp, #8
 8002e2e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8002e32:	68db      	ldr	r3, [r3, #12]
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 8002e34:	68dc      	ldr	r4, [r3, #12]
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8002e36:	681e      	ldr	r6, [r3, #0]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8002e38:	1d27      	adds	r7, r4, #4
 8002e3a:	4638      	mov	r0, r7
 8002e3c:	f7fe fd70 	bl	8001920 <uxListRemove>
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8002e40:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8002e42:	4620      	mov	r0, r4
 8002e44:	4798      	blx	r3
		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
 8002e46:	69e3      	ldr	r3, [r4, #28]
 8002e48:	2b01      	cmp	r3, #1
 8002e4a:	d1e8      	bne.n	8002e1e <prvSwitchTimerLists+0xa>
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 8002e4c:	69a3      	ldr	r3, [r4, #24]
 8002e4e:	4433      	add	r3, r6
			if( xReloadTime > xNextExpireTime )
 8002e50:	429e      	cmp	r6, r3
 8002e52:	d206      	bcs.n	8002e62 <prvSwitchTimerLists+0x4e>
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
 8002e54:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8002e56:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8002e58:	4639      	mov	r1, r7
 8002e5a:	6828      	ldr	r0, [r5, #0]
 8002e5c:	f7fe fd49 	bl	80018f2 <vListInsert>
 8002e60:	e7dd      	b.n	8002e1e <prvSwitchTimerLists+0xa>
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 8002e62:	2300      	movs	r3, #0
 8002e64:	f8cd 8000 	str.w	r8, [sp]
 8002e68:	4632      	mov	r2, r6
 8002e6a:	4619      	mov	r1, r3
 8002e6c:	4620      	mov	r0, r4
 8002e6e:	f7ff ffa5 	bl	8002dbc <xTimerGenericCommand>
				configASSERT( xResult );
 8002e72:	2800      	cmp	r0, #0
 8002e74:	d1d3      	bne.n	8002e1e <prvSwitchTimerLists+0xa>
 8002e76:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002e7a:	f383 8811 	msr	BASEPRI, r3
 8002e7e:	f3bf 8f6f 	isb	sy
 8002e82:	f3bf 8f4f 	dsb	sy
 8002e86:	e7fe      	b.n	8002e86 <prvSwitchTimerLists+0x72>
 8002e88:	20003e1c 	.word	0x20003e1c
 8002e8c:	20003e20 	.word	0x20003e20

08002e90 <prvTimerTask>:
{
 8002e90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 8002e94:	4d6c      	ldr	r5, [pc, #432]	; (8003048 <prvTimerTask+0x1b8>)
					portYIELD_WITHIN_API();
 8002e96:	f8df 81c0 	ldr.w	r8, [pc, #448]	; 8003058 <prvTimerTask+0x1c8>
 8002e9a:	462f      	mov	r7, r5
{
 8002e9c:	b089      	sub	sp, #36	; 0x24
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 8002e9e:	682b      	ldr	r3, [r5, #0]
 8002ea0:	f8d3 b000 	ldr.w	fp, [r3]
	if( *pxListWasEmpty == pdFALSE )
 8002ea4:	f1bb 0f00 	cmp.w	fp, #0
 8002ea8:	d042      	beq.n	8002f30 <prvTimerTask+0xa0>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8002eaa:	68db      	ldr	r3, [r3, #12]
 8002eac:	f8d3 9000 	ldr.w	r9, [r3]
	vTaskSuspendAll();
 8002eb0:	f7ff fc7a 	bl	80027a8 <vTaskSuspendAll>
	xTimeNow = xTaskGetTickCount();
 8002eb4:	f7ff fc80 	bl	80027b8 <xTaskGetTickCount>
	if( xTimeNow < xLastTime )
 8002eb8:	4b64      	ldr	r3, [pc, #400]	; (800304c <prvTimerTask+0x1bc>)
	xTimeNow = xTaskGetTickCount();
 8002eba:	4682      	mov	sl, r0
	if( xTimeNow < xLastTime )
 8002ebc:	681a      	ldr	r2, [r3, #0]
 8002ebe:	461e      	mov	r6, r3
 8002ec0:	4290      	cmp	r0, r2
 8002ec2:	d237      	bcs.n	8002f34 <prvTimerTask+0xa4>
		*pxTimerListsWereSwitched = pdTRUE;
 8002ec4:	2401      	movs	r4, #1
 8002ec6:	9303      	str	r3, [sp, #12]
		prvSwitchTimerLists();
 8002ec8:	f7ff ffa4 	bl	8002e14 <prvSwitchTimerLists>
 8002ecc:	9b03      	ldr	r3, [sp, #12]
	xLastTime = xTimeNow;
 8002ece:	f8c3 a000 	str.w	sl, [r3]
		if( xTimerListsWereSwitched == pdFALSE )
 8002ed2:	2c00      	cmp	r4, #0
 8002ed4:	d17d      	bne.n	8002fd2 <prvTimerTask+0x142>
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 8002ed6:	f1bb 0f00 	cmp.w	fp, #0
 8002eda:	d05f      	beq.n	8002f9c <prvTimerTask+0x10c>
 8002edc:	45d1      	cmp	r9, sl
 8002ede:	d876      	bhi.n	8002fce <prvTimerTask+0x13e>
				( void ) xTaskResumeAll();
 8002ee0:	f7ff fd02 	bl	80028e8 <xTaskResumeAll>
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 8002ee4:	683b      	ldr	r3, [r7, #0]
 8002ee6:	68db      	ldr	r3, [r3, #12]
 8002ee8:	f8d3 b00c 	ldr.w	fp, [r3, #12]
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8002eec:	f10b 0004 	add.w	r0, fp, #4
 8002ef0:	f7fe fd16 	bl	8001920 <uxListRemove>
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
 8002ef4:	f8db 301c 	ldr.w	r3, [fp, #28]
 8002ef8:	2b01      	cmp	r3, #1
 8002efa:	d11d      	bne.n	8002f38 <prvTimerTask+0xa8>
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
 8002efc:	f8db 1018 	ldr.w	r1, [fp, #24]
 8002f00:	464b      	mov	r3, r9
 8002f02:	4652      	mov	r2, sl
 8002f04:	4449      	add	r1, r9
 8002f06:	4658      	mov	r0, fp
 8002f08:	f7ff ff14 	bl	8002d34 <prvInsertTimerInActiveList>
 8002f0c:	b1a0      	cbz	r0, 8002f38 <prvTimerTask+0xa8>
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 8002f0e:	9400      	str	r4, [sp, #0]
 8002f10:	4623      	mov	r3, r4
 8002f12:	464a      	mov	r2, r9
 8002f14:	4621      	mov	r1, r4
 8002f16:	4658      	mov	r0, fp
 8002f18:	f7ff ff50 	bl	8002dbc <xTimerGenericCommand>
			configASSERT( xResult );
 8002f1c:	b960      	cbnz	r0, 8002f38 <prvTimerTask+0xa8>
 8002f1e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002f22:	f383 8811 	msr	BASEPRI, r3
 8002f26:	f3bf 8f6f 	isb	sy
 8002f2a:	f3bf 8f4f 	dsb	sy
 8002f2e:	e7fe      	b.n	8002f2e <prvTimerTask+0x9e>
		xNextExpireTime = ( TickType_t ) 0U;
 8002f30:	46d9      	mov	r9, fp
 8002f32:	e7bd      	b.n	8002eb0 <prvTimerTask+0x20>
		*pxTimerListsWereSwitched = pdFALSE;
 8002f34:	2400      	movs	r4, #0
 8002f36:	e7ca      	b.n	8002ece <prvTimerTask+0x3e>
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8002f38:	f8db 3024 	ldr.w	r3, [fp, #36]	; 0x24
 8002f3c:	4658      	mov	r0, fp
 8002f3e:	4798      	blx	r3
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 8002f40:	f8df 9110 	ldr.w	r9, [pc, #272]	; 8003054 <prvTimerTask+0x1c4>
 8002f44:	2200      	movs	r2, #0
 8002f46:	a905      	add	r1, sp, #20
 8002f48:	f8d9 0000 	ldr.w	r0, [r9]
 8002f4c:	f7ff f94a 	bl	80021e4 <xQueueReceive>
 8002f50:	2800      	cmp	r0, #0
 8002f52:	d0a4      	beq.n	8002e9e <prvTimerTask+0xe>
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
 8002f54:	9b05      	ldr	r3, [sp, #20]
 8002f56:	2b00      	cmp	r3, #0
 8002f58:	dbf4      	blt.n	8002f44 <prvTimerTask+0xb4>
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
 8002f5a:	9c07      	ldr	r4, [sp, #28]
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
 8002f5c:	6963      	ldr	r3, [r4, #20]
 8002f5e:	b113      	cbz	r3, 8002f66 <prvTimerTask+0xd6>
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8002f60:	1d20      	adds	r0, r4, #4
 8002f62:	f7fe fcdd 	bl	8001920 <uxListRemove>
	xTimeNow = xTaskGetTickCount();
 8002f66:	f7ff fc27 	bl	80027b8 <xTaskGetTickCount>
	if( xTimeNow < xLastTime )
 8002f6a:	6833      	ldr	r3, [r6, #0]
	xTimeNow = xTaskGetTickCount();
 8002f6c:	4683      	mov	fp, r0
	if( xTimeNow < xLastTime )
 8002f6e:	4298      	cmp	r0, r3
 8002f70:	d201      	bcs.n	8002f76 <prvTimerTask+0xe6>
		prvSwitchTimerLists();
 8002f72:	f7ff ff4f 	bl	8002e14 <prvSwitchTimerLists>
 8002f76:	9a05      	ldr	r2, [sp, #20]
	xLastTime = xTimeNow;
 8002f78:	f8c6 b000 	str.w	fp, [r6]
 8002f7c:	2a09      	cmp	r2, #9
 8002f7e:	d8e1      	bhi.n	8002f44 <prvTimerTask+0xb4>
 8002f80:	2301      	movs	r3, #1
 8002f82:	4093      	lsls	r3, r2
 8002f84:	f413 7a04 	ands.w	sl, r3, #528	; 0x210
 8002f88:	d14a      	bne.n	8003020 <prvTimerTask+0x190>
 8002f8a:	f013 0fc7 	tst.w	r3, #199	; 0xc7
 8002f8e:	d123      	bne.n	8002fd8 <prvTimerTask+0x148>
 8002f90:	069b      	lsls	r3, r3, #26
 8002f92:	d5d7      	bpl.n	8002f44 <prvTimerTask+0xb4>
						vPortFree( pxTimer );
 8002f94:	4620      	mov	r0, r4
 8002f96:	f7fe fee9 	bl	8001d6c <vPortFree>
 8002f9a:	e7d3      	b.n	8002f44 <prvTimerTask+0xb4>
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 8002f9c:	4b2c      	ldr	r3, [pc, #176]	; (8003050 <prvTimerTask+0x1c0>)
 8002f9e:	681b      	ldr	r3, [r3, #0]
 8002fa0:	681a      	ldr	r2, [r3, #0]
 8002fa2:	fab2 f282 	clz	r2, r2
 8002fa6:	0952      	lsrs	r2, r2, #5
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
 8002fa8:	4b2a      	ldr	r3, [pc, #168]	; (8003054 <prvTimerTask+0x1c4>)
 8002faa:	eba9 010a 	sub.w	r1, r9, sl
 8002fae:	6818      	ldr	r0, [r3, #0]
 8002fb0:	f7ff f9bc 	bl	800232c <vQueueWaitForMessageRestricted>
				if( xTaskResumeAll() == pdFALSE )
 8002fb4:	f7ff fc98 	bl	80028e8 <xTaskResumeAll>
 8002fb8:	2800      	cmp	r0, #0
 8002fba:	d1c1      	bne.n	8002f40 <prvTimerTask+0xb0>
					portYIELD_WITHIN_API();
 8002fbc:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8002fc0:	f8c8 3000 	str.w	r3, [r8]
 8002fc4:	f3bf 8f4f 	dsb	sy
 8002fc8:	f3bf 8f6f 	isb	sy
 8002fcc:	e7b8      	b.n	8002f40 <prvTimerTask+0xb0>
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 8002fce:	4622      	mov	r2, r4
 8002fd0:	e7ea      	b.n	8002fa8 <prvTimerTask+0x118>
			( void ) xTaskResumeAll();
 8002fd2:	f7ff fc89 	bl	80028e8 <xTaskResumeAll>
 8002fd6:	e7b3      	b.n	8002f40 <prvTimerTask+0xb0>
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
 8002fd8:	69a1      	ldr	r1, [r4, #24]
 8002fda:	9b06      	ldr	r3, [sp, #24]
 8002fdc:	465a      	mov	r2, fp
 8002fde:	4419      	add	r1, r3
 8002fe0:	4620      	mov	r0, r4
 8002fe2:	f7ff fea7 	bl	8002d34 <prvInsertTimerInActiveList>
 8002fe6:	2800      	cmp	r0, #0
 8002fe8:	d0ac      	beq.n	8002f44 <prvTimerTask+0xb4>
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8002fea:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8002fec:	4620      	mov	r0, r4
 8002fee:	4798      	blx	r3
						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
 8002ff0:	69e3      	ldr	r3, [r4, #28]
 8002ff2:	2b01      	cmp	r3, #1
 8002ff4:	d1a6      	bne.n	8002f44 <prvTimerTask+0xb4>
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
 8002ff6:	69a2      	ldr	r2, [r4, #24]
 8002ff8:	9906      	ldr	r1, [sp, #24]
 8002ffa:	f8cd a000 	str.w	sl, [sp]
 8002ffe:	440a      	add	r2, r1
 8003000:	4653      	mov	r3, sl
 8003002:	4651      	mov	r1, sl
 8003004:	4620      	mov	r0, r4
 8003006:	f7ff fed9 	bl	8002dbc <xTimerGenericCommand>
							configASSERT( xResult );
 800300a:	2800      	cmp	r0, #0
 800300c:	d19a      	bne.n	8002f44 <prvTimerTask+0xb4>
 800300e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003012:	f383 8811 	msr	BASEPRI, r3
 8003016:	f3bf 8f6f 	isb	sy
 800301a:	f3bf 8f4f 	dsb	sy
 800301e:	e7fe      	b.n	800301e <prvTimerTask+0x18e>
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 8003020:	9906      	ldr	r1, [sp, #24]
 8003022:	61a1      	str	r1, [r4, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 8003024:	b941      	cbnz	r1, 8003038 <prvTimerTask+0x1a8>
 8003026:	f04f 0350 	mov.w	r3, #80	; 0x50
 800302a:	f383 8811 	msr	BASEPRI, r3
 800302e:	f3bf 8f6f 	isb	sy
 8003032:	f3bf 8f4f 	dsb	sy
 8003036:	e7fe      	b.n	8003036 <prvTimerTask+0x1a6>
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 8003038:	465b      	mov	r3, fp
 800303a:	465a      	mov	r2, fp
 800303c:	4459      	add	r1, fp
 800303e:	4620      	mov	r0, r4
 8003040:	f7ff fe78 	bl	8002d34 <prvInsertTimerInActiveList>
 8003044:	e77e      	b.n	8002f44 <prvTimerTask+0xb4>
 8003046:	bf00      	nop
 8003048:	20003e1c 	.word	0x20003e1c
 800304c:	20003e4c 	.word	0x20003e4c
 8003050:	20003e20 	.word	0x20003e20
 8003054:	20003e50 	.word	0x20003e50
 8003058:	e000ed04 	.word	0xe000ed04

0800305c <gotoResetUI>:
//	setShow_ui(MATCH_UI);
}

void gotoResetUI(void)
{
	exitMenu();
 800305c:	f000 b854 	b.w	8003108 <exitMenu>

08003060 <gotoMatchMiniFlyUI>:
 8003060:	f000 b852 	b.w	8003108 <exitMenu>

08003064 <gotoJoystickCalibUI>:
 8003064:	f000 b850 	b.w	8003108 <exitMenu>

08003068 <mainMenuInit>:
//	}
//}

/*初始化主菜單*/
void mainMenuInit(void)
{	
 8003068:	2100      	movs	r1, #0
 800306a:	4a17      	ldr	r2, [pc, #92]	; (80030c8 <mainMenuInit+0x60>)
 800306c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800306e:	4613      	mov	r3, r2
	for(int i=0; i<MAIN_MENU_ITEMNUM; i++)
	{
		mainMenu[i].menuItemCount = MAIN_MENU_ITEMNUM;
 8003070:	270a      	movs	r7, #10
		mainMenu[i].isSelect = false;
 8003072:	4608      	mov	r0, r1
		mainMenu[i].icoSelected = finger_img;
 8003074:	4e15      	ldr	r6, [pc, #84]	; (80030cc <mainMenuInit+0x64>)
		mainMenu[i].icoUnselected = NULL;
		mainMenu[i].title = mainMenuLanguage[1][i];
 8003076:	4d16      	ldr	r5, [pc, #88]	; (80030d0 <mainMenuInit+0x68>)
 8003078:	186c      	adds	r4, r5, r1
 800307a:	6aa4      	ldr	r4, [r4, #40]	; 0x28
 800307c:	3104      	adds	r1, #4
	for(int i=0; i<MAIN_MENU_ITEMNUM; i++)
 800307e:	2928      	cmp	r1, #40	; 0x28
		mainMenu[i].menuItemCount = MAIN_MENU_ITEMNUM;
 8003080:	7057      	strb	r7, [r2, #1]
		mainMenu[i].isSelect = false;
 8003082:	7090      	strb	r0, [r2, #2]
		mainMenu[i].icoSelected = finger_img;
 8003084:	6056      	str	r6, [r2, #4]
		mainMenu[i].icoUnselected = NULL;
 8003086:	6090      	str	r0, [r2, #8]
		mainMenu[i].title = mainMenuLanguage[1][i];
 8003088:	60d4      	str	r4, [r2, #12]
		mainMenu[i].Function = NULL;
 800308a:	6110      	str	r0, [r2, #16]
		mainMenu[i].parentMenu = NULL;
 800308c:	6150      	str	r0, [r2, #20]
		mainMenu[i].childrenMenu = NULL;
 800308e:	6190      	str	r0, [r2, #24]
 8003090:	f102 021c 	add.w	r2, r2, #28
	for(int i=0; i<MAIN_MENU_ITEMNUM; i++)
 8003094:	d1f0      	bne.n	8003078 <mainMenuInit+0x10>
	}
	mainMenu[0].isSelect = true;
 8003096:	2201      	movs	r2, #1
 8003098:	709a      	strb	r2, [r3, #2]
	mainMenu[0].Function = gotoNextMenu;
 800309a:	4a0e      	ldr	r2, [pc, #56]	; (80030d4 <mainMenuInit+0x6c>)
	//mainMenu[3].childrenMenu = flipEnableMenu;
	
	mainMenu[4].Function = gotoNextMenu;
	//mainMenu[4].childrenMenu = &expModuleMenu[0];
	
	mainMenu[5].Function = gotoJoystickCalibUI;
 800309c:	490e      	ldr	r1, [pc, #56]	; (80030d8 <mainMenuInit+0x70>)
	mainMenu[0].Function = gotoNextMenu;
 800309e:	611a      	str	r2, [r3, #16]
	mainMenu[1].Function = gotoNextMenu;
 80030a0:	62da      	str	r2, [r3, #44]	; 0x2c
	mainMenu[2].Function = gotoNextMenu;
 80030a2:	649a      	str	r2, [r3, #72]	; 0x48
	mainMenu[3].Function = gotoNextMenu;
 80030a4:	665a      	str	r2, [r3, #100]	; 0x64
	mainMenu[4].Function = gotoNextMenu;
 80030a6:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	//mainMenu[5].childrenMenu = NULL;
	
	mainMenu[6].Function = gotoMatchMiniFlyUI;
	//mainMenu[6].childrenMenu = NULL;
	
	mainMenu[7].Function = gotoNextMenu;
 80030aa:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
	//mainMenu[7].childrenMenu = languageMenu;
	
	mainMenu[8].Function = gotoResetUI;
 80030ae:	4a0b      	ldr	r2, [pc, #44]	; (80030dc <mainMenuInit+0x74>)
	mainMenu[5].Function = gotoJoystickCalibUI;
 80030b0:	f8c3 109c 	str.w	r1, [r3, #156]	; 0x9c
	mainMenu[8].Function = gotoResetUI;
 80030b4:	f8c3 20f0 	str.w	r2, [r3, #240]	; 0xf0
	mainMenu[6].Function = gotoMatchMiniFlyUI;
 80030b8:	4909      	ldr	r1, [pc, #36]	; (80030e0 <mainMenuInit+0x78>)
	//mainMenu[8].childrenMenu = NULL;
	
	mainMenu[9].Function = exitMenu;
 80030ba:	4a0a      	ldr	r2, [pc, #40]	; (80030e4 <mainMenuInit+0x7c>)
	mainMenu[6].Function = gotoMatchMiniFlyUI;
 80030bc:	f8c3 10b8 	str.w	r1, [r3, #184]	; 0xb8
	mainMenu[9].Function = exitMenu;
 80030c0:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
 80030c4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80030c6:	bf00      	nop
 80030c8:	20003f10 	.word	0x20003f10
 80030cc:	080039d0 	.word	0x080039d0
 80030d0:	20000014 	.word	0x20000014
 80030d4:	08003135 	.word	0x08003135
 80030d8:	08003065 	.word	0x08003065
 80030dc:	0800305d 	.word	0x0800305d
 80030e0:	08003061 	.word	0x08003061
 80030e4:	08003109 	.word	0x08003109

080030e8 <getMenuSelectitem>:
//  從menu清單中取得被選中的Menu項目
//  返回值 : 被選中的menu項目位於清單中的索引
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
uint8_t getMenuSelectitem(MenuItem_Typedef menu[]) {
	int i;
	for (i = 0; i < menu->menuItemCount; i++) {
 80030e8:	2300      	movs	r3, #0
		if (menu[i].isSelect == true)
 80030ea:	211c      	movs	r1, #28
uint8_t getMenuSelectitem(MenuItem_Typedef menu[]) {
 80030ec:	b510      	push	{r4, lr}
	for (i = 0; i < menu->menuItemCount; i++) {
 80030ee:	7842      	ldrb	r2, [r0, #1]
 80030f0:	4293      	cmp	r3, r2
 80030f2:	db01      	blt.n	80030f8 <getMenuSelectitem+0x10>
			break;
	}
	return i;
 80030f4:	b2d8      	uxtb	r0, r3
}
 80030f6:	bd10      	pop	{r4, pc}
		if (menu[i].isSelect == true)
 80030f8:	fb01 0403 	mla	r4, r1, r3, r0
 80030fc:	78a4      	ldrb	r4, [r4, #2]
 80030fe:	2c00      	cmp	r4, #0
 8003100:	d1f8      	bne.n	80030f4 <getMenuSelectitem+0xc>
	for (i = 0; i < menu->menuItemCount; i++) {
 8003102:	3301      	adds	r3, #1
 8003104:	e7f4      	b.n	80030f0 <getMenuSelectitem+0x8>
	...

08003108 <exitMenu>:
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
//  返回主menu選單
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
void exitMenu(void) {
	CurMenu = mainMenu;
 8003108:	4a05      	ldr	r2, [pc, #20]	; (8003120 <exitMenu+0x18>)
 800310a:	4b06      	ldr	r3, [pc, #24]	; (8003124 <exitMenu+0x1c>)
 800310c:	601a      	str	r2, [r3, #0]
	MenuWindow.title = defaultTitle;
 800310e:	4b06      	ldr	r3, [pc, #24]	; (8003128 <exitMenu+0x20>)
 8003110:	681a      	ldr	r2, [r3, #0]
 8003112:	4b06      	ldr	r3, [pc, #24]	; (800312c <exitMenu+0x24>)
 8003114:	619a      	str	r2, [r3, #24]
	//setShow_ui(MAIN_UI);
	isChangeMenu = true;
 8003116:	2201      	movs	r2, #1
 8003118:	4b05      	ldr	r3, [pc, #20]	; (8003130 <exitMenu+0x28>)
 800311a:	701a      	strb	r2, [r3, #0]
 800311c:	4770      	bx	lr
 800311e:	bf00      	nop
 8003120:	20003f10 	.word	0x20003f10
 8003124:	2000008c 	.word	0x2000008c
 8003128:	200000cc 	.word	0x200000cc
 800312c:	200000b0 	.word	0x200000b0
 8003130:	200000d0 	.word	0x200000d0

08003134 <gotoNextMenu>:
}
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
//  前往下一個選單
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
void gotoNextMenu(void) {
	if (CurItem->childrenMenu != NULL) {
 8003134:	4b09      	ldr	r3, [pc, #36]	; (800315c <gotoNextMenu+0x28>)
 8003136:	681b      	ldr	r3, [r3, #0]
 8003138:	699a      	ldr	r2, [r3, #24]
 800313a:	b14a      	cbz	r2, 8003150 <gotoNextMenu+0x1c>
		CurMenu = CurItem->childrenMenu;
 800313c:	4908      	ldr	r1, [pc, #32]	; (8003160 <gotoNextMenu+0x2c>)
		MenuWindow.title = CurItem->title + 2;
 800313e:	68db      	ldr	r3, [r3, #12]
		CurMenu = CurItem->childrenMenu;
 8003140:	600a      	str	r2, [r1, #0]
		MenuWindow.title = CurItem->title + 2;
 8003142:	4a08      	ldr	r2, [pc, #32]	; (8003164 <gotoNextMenu+0x30>)
 8003144:	3302      	adds	r3, #2
 8003146:	6193      	str	r3, [r2, #24]
		isChangeMenu = true;
 8003148:	2201      	movs	r2, #1
 800314a:	4b07      	ldr	r3, [pc, #28]	; (8003168 <gotoNextMenu+0x34>)
 800314c:	701a      	strb	r2, [r3, #0]
 800314e:	4770      	bx	lr
	} else if (CurItem->Function != NULL && CurItem->parentMenu == NULL) {
 8003150:	691a      	ldr	r2, [r3, #16]
 8003152:	b112      	cbz	r2, 800315a <gotoNextMenu+0x26>
 8003154:	695b      	ldr	r3, [r3, #20]
 8003156:	b903      	cbnz	r3, 800315a <gotoNextMenu+0x26>
		CurItem->Function(); //執行選中子選單函數
 8003158:	4710      	bx	r2
 800315a:	4770      	bx	lr
 800315c:	20003e58 	.word	0x20003e58
 8003160:	2000008c 	.word	0x2000008c
 8003164:	200000b0 	.word	0x200000b0
 8003168:	200000d0 	.word	0x200000d0

0800316c <DisplayMenuInit>:
		exitMenu();
	}
}

/*顯示菜單*/
void DisplayMenuInit(MenuItem_Typedef* menu) {
 800316c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	uint8_t topitem;
	uint8_t showItems;

	if (isChangeMenu == false)
 8003170:	4f20      	ldr	r7, [pc, #128]	; (80031f4 <DisplayMenuInit+0x88>)
void DisplayMenuInit(MenuItem_Typedef* menu) {
 8003172:	4606      	mov	r6, r0
	if (isChangeMenu == false)
 8003174:	783b      	ldrb	r3, [r7, #0]
 8003176:	2b00      	cmp	r3, #0
 8003178:	d02f      	beq.n	80031da <DisplayMenuInit+0x6e>
		return;

	selected = getMenuSelectitem(menu);
 800317a:	f7ff ffb5 	bl	80030e8 <getMenuSelectitem>
 800317e:	4b1e      	ldr	r3, [pc, #120]	; (80031f8 <DisplayMenuInit+0x8c>)
	cur_sequence = selected;
	if (selected < menu->cursorPosition)
		menu->cursorPosition = 0;
	topitem = selected - menu->cursorPosition;
	if (menu->menuItemCount <= MenuWindow.itemsperpage)
 8003180:	4d1e      	ldr	r5, [pc, #120]	; (80031fc <DisplayMenuInit+0x90>)
	selected = getMenuSelectitem(menu);
 8003182:	6018      	str	r0, [r3, #0]
	cur_sequence = selected;
 8003184:	4b1e      	ldr	r3, [pc, #120]	; (8003200 <DisplayMenuInit+0x94>)
	if (menu->menuItemCount <= MenuWindow.itemsperpage)
 8003186:	7872      	ldrb	r2, [r6, #1]
	cur_sequence = selected;
 8003188:	6018      	str	r0, [r3, #0]
	if (selected < menu->cursorPosition)
 800318a:	f996 3000 	ldrsb.w	r3, [r6]
	showItems = MenuWindow.itemsperpage;
	if (menu->menuItemCount < MenuWindow.itemsperpage)
		showItems = menu->menuItemCount;
	for (int i = 0; i < showItems; i++) {
		MenuItem_Typedef* Item = &menu[topitem + i];
		GUI_MenuItemDraw(MEMU_POSX_1, MEMU_POSY_1 + i * 15, Item);
 800318e:	f04f 091c 	mov.w	r9, #28
	if (selected < menu->cursorPosition)
 8003192:	4298      	cmp	r0, r3
		menu->cursorPosition = 0;
 8003194:	bfbc      	itt	lt
 8003196:	2300      	movlt	r3, #0
 8003198:	7033      	strblt	r3, [r6, #0]
	if (menu->menuItemCount <= MenuWindow.itemsperpage)
 800319a:	692b      	ldr	r3, [r5, #16]
	topitem = selected - menu->cursorPosition;
 800319c:	f996 4000 	ldrsb.w	r4, [r6]
	if (menu->menuItemCount <= MenuWindow.itemsperpage)
 80031a0:	429a      	cmp	r2, r3
		topitem = 0;
 80031a2:	bf92      	itee	ls
 80031a4:	2400      	movls	r4, #0
	topitem = selected - menu->cursorPosition;
 80031a6:	1b00      	subhi	r0, r0, r4
 80031a8:	b2c4      	uxtbhi	r4, r0
	GUI_WindowsDraw(&MenuWindow);
 80031aa:	4814      	ldr	r0, [pc, #80]	; (80031fc <DisplayMenuInit+0x90>)
	MenuWindow.topitem = topitem;
 80031ac:	616c      	str	r4, [r5, #20]
	GUI_WindowsDraw(&MenuWindow);
 80031ae:	f000 fb33 	bl	8003818 <GUI_WindowsDraw>
	MenuScrollbar.topitem = topitem;
 80031b2:	4814      	ldr	r0, [pc, #80]	; (8003204 <DisplayMenuInit+0x98>)
 80031b4:	6184      	str	r4, [r0, #24]
	MenuScrollbar.totalitems = menu->menuItemCount;
 80031b6:	7873      	ldrb	r3, [r6, #1]
 80031b8:	6103      	str	r3, [r0, #16]
	GUI_ScrollbarDraw(&MenuScrollbar);
 80031ba:	f000 fa59 	bl	8003670 <GUI_ScrollbarDraw>
	showItems = MenuWindow.itemsperpage;
 80031be:	692b      	ldr	r3, [r5, #16]
	for (int i = 0; i < showItems; i++) {
 80031c0:	2500      	movs	r5, #0
	if (menu->menuItemCount < MenuWindow.itemsperpage)
 80031c2:	f896 8001 	ldrb.w	r8, [r6, #1]
 80031c6:	4543      	cmp	r3, r8
	showItems = MenuWindow.itemsperpage;
 80031c8:	bf98      	it	ls
 80031ca:	fa5f f883 	uxtbls.w	r8, r3
	for (int i = 0; i < showItems; i++) {
 80031ce:	4545      	cmp	r5, r8
 80031d0:	db05      	blt.n	80031de <DisplayMenuInit+0x72>
	}

//	CurItem = menu + cur_sequence;
//	CurItem->isSelect = true;

	GUI_Refresh(); //刷新屏幕
 80031d2:	f000 fa12 	bl	80035fa <GUI_Refresh>
	isChangeMenu = false;
 80031d6:	2300      	movs	r3, #0
 80031d8:	703b      	strb	r3, [r7, #0]
 80031da:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		GUI_MenuItemDraw(MEMU_POSX_1, MEMU_POSY_1 + i * 15, Item);
 80031de:	1962      	adds	r2, r4, r5
 80031e0:	ebc5 1105 	rsb	r1, r5, r5, lsl #4
 80031e4:	fb09 6202 	mla	r2, r9, r2, r6
 80031e8:	3113      	adds	r1, #19
 80031ea:	2014      	movs	r0, #20
 80031ec:	f000 f9a2 	bl	8003534 <GUI_MenuItemDraw>
	for (int i = 0; i < showItems; i++) {
 80031f0:	3501      	adds	r5, #1
 80031f2:	e7ec      	b.n	80031ce <DisplayMenuInit+0x62>
 80031f4:	200000d0 	.word	0x200000d0
 80031f8:	20003e64 	.word	0x20003e64
 80031fc:	200000b0 	.word	0x200000b0
 8003200:	20003e60 	.word	0x20003e60
 8003204:	20000090 	.word	0x20000090

08003208 <Menu_SetSelected>:
}


void Menu_SetSelected(int item_index,bool selected){
	//判斷index是否越界
	CurItem = CurMenu + item_index;
 8003208:	4b04      	ldr	r3, [pc, #16]	; (800321c <Menu_SetSelected+0x14>)
 800320a:	681a      	ldr	r2, [r3, #0]
 800320c:	231c      	movs	r3, #28
 800320e:	fb03 2000 	mla	r0, r3, r0, r2
 8003212:	4b03      	ldr	r3, [pc, #12]	; (8003220 <Menu_SetSelected+0x18>)
	CurItem->isSelect = selected;
 8003214:	7081      	strb	r1, [r0, #2]
	CurItem = CurMenu + item_index;
 8003216:	6018      	str	r0, [r3, #0]
	CurItem->isSelect = selected;
 8003218:	4770      	bx	lr
 800321a:	bf00      	nop
 800321c:	2000008c 	.word	0x2000008c
 8003220:	20003e58 	.word	0x20003e58

08003224 <Menu_Task>:
}

/*菜單運行*/
void Menu_Task(void *pvParameters) {
 8003224:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}

	uint8_t showItems;
	Rotary_state rstate =state_no_changed;
	DisplayMenuInit(CurMenu);
 8003228:	4d5b      	ldr	r5, [pc, #364]	; (8003398 <Menu_Task+0x174>)
	RotaryEcncorder_SetRange(0,CurMenu->menuItemCount-1);

	while(1){
			cur_rotateNum = RotaryEcncorder_GetCount();
 800322a:	4f5c      	ldr	r7, [pc, #368]	; (800339c <Menu_Task+0x178>)
	DisplayMenuInit(CurMenu);
 800322c:	6828      	ldr	r0, [r5, #0]
 800322e:	f7ff ff9d 	bl	800316c <DisplayMenuInit>
	RotaryEcncorder_SetRange(0,CurMenu->menuItemCount-1);
 8003232:	682b      	ldr	r3, [r5, #0]
 8003234:	2000      	movs	r0, #0
 8003236:	7859      	ldrb	r1, [r3, #1]
					MenuScrollbar.topitem = cur_sequence;
					GUI_Scrollbar_SetPos(&MenuScrollbar);
					GUI_Refresh();
					break;
				case state_clock_wise:
					GUI_RectangleFill(MenuWindow.x+1,MenuScrollbar.y,MenuScrollbar.x-1,MenuWindow.height-2,0);
 8003238:	4c59      	ldr	r4, [pc, #356]	; (80033a0 <Menu_Task+0x17c>)
	RotaryEcncorder_SetRange(0,CurMenu->menuItemCount-1);
 800323a:	3901      	subs	r1, #1
 800323c:	f7fd fcb2 	bl	8000ba4 <RotaryEcncorder_SetRange>
			cur_rotateNum = RotaryEcncorder_GetCount();
 8003240:	f7fd fcc8 	bl	8000bd4 <RotaryEcncorder_GetCount>
 8003244:	6038      	str	r0, [r7, #0]
			rstate = RotaryEcncorder_GetState();
 8003246:	f7fd fce1 	bl	8000c0c <RotaryEcncorder_GetState>
			switch(rstate){
 800324a:	2801      	cmp	r0, #1
			rstate = RotaryEcncorder_GetState();
 800324c:	4606      	mov	r6, r0
			switch(rstate){
 800324e:	d054      	beq.n	80032fa <Menu_Task+0xd6>
 8003250:	2802      	cmp	r0, #2
 8003252:	d136      	bne.n	80032c2 <Menu_Task+0x9e>
					GUI_RectangleFill(MenuWindow.x+1,MenuScrollbar.y,MenuScrollbar.x-1,MenuWindow.height-2,0);
 8003254:	2600      	movs	r6, #0
 8003256:	f8df 814c 	ldr.w	r8, [pc, #332]	; 80033a4 <Menu_Task+0x180>
 800325a:	68e3      	ldr	r3, [r4, #12]
 800325c:	f8d8 2000 	ldr.w	r2, [r8]
 8003260:	6820      	ldr	r0, [r4, #0]
					Menu_SetSelected(cur_sequence,false);
 8003262:	f8df 9144 	ldr.w	r9, [pc, #324]	; 80033a8 <Menu_Task+0x184>
					GUI_RectangleFill(MenuWindow.x+1,MenuScrollbar.y,MenuScrollbar.x-1,MenuWindow.height-2,0);
 8003266:	3b02      	subs	r3, #2
 8003268:	3a01      	subs	r2, #1
 800326a:	f8d8 1004 	ldr.w	r1, [r8, #4]
 800326e:	3001      	adds	r0, #1
 8003270:	9600      	str	r6, [sp, #0]
 8003272:	f000 f8bf 	bl	80033f4 <GUI_RectangleFill>
					Menu_SetSelected(cur_sequence,false);
 8003276:	4631      	mov	r1, r6
 8003278:	f8d9 0000 	ldr.w	r0, [r9]
 800327c:	f7ff ffc4 	bl	8003208 <Menu_SetSelected>
					cur_sequence = cur_rotateNum;
 8003280:	6838      	ldr	r0, [r7, #0]
					Menu_SetSelected(cur_sequence,true);
 8003282:	2101      	movs	r1, #1
					cur_sequence = cur_rotateNum;
 8003284:	f8c9 0000 	str.w	r0, [r9]
					Menu_SetSelected(cur_sequence,true);
 8003288:	f7ff ffbe 	bl	8003208 <Menu_SetSelected>
					CurMenu->cursorPosition--;
 800328c:	682a      	ldr	r2, [r5, #0]
 800328e:	7813      	ldrb	r3, [r2, #0]
					if (CurMenu->menuItemCount <= MenuWindow.itemsperpage) {
 8003290:	f892 a001 	ldrb.w	sl, [r2, #1]
					CurMenu->cursorPosition--;
 8003294:	3b01      	subs	r3, #1
 8003296:	b25b      	sxtb	r3, r3
 8003298:	7013      	strb	r3, [r2, #0]
					if (CurMenu->menuItemCount <= MenuWindow.itemsperpage) {
 800329a:	6921      	ldr	r1, [r4, #16]
 800329c:	458a      	cmp	sl, r1
 800329e:	d814      	bhi.n	80032ca <Menu_Task+0xa6>
						if (CurMenu->cursorPosition < 0)
 80032a0:	42b3      	cmp	r3, r6
 80032a2:	da00      	bge.n	80032a6 <Menu_Task+0x82>
							CurMenu->cursorPosition = 0;
 80032a4:	7016      	strb	r6, [r2, #0]
					for (int i = 0; i < showItems; i++) {
 80032a6:	2600      	movs	r6, #0
						MenuItem_Typedef* Item = CurMenu + MenuWindow.topitem + i;
 80032a8:	f04f 0b1c 	mov.w	fp, #28
					for (int i = 0; i < showItems; i++) {
 80032ac:	4556      	cmp	r6, sl
 80032ae:	db17      	blt.n	80032e0 <Menu_Task+0xbc>
					}
					for (int i = 0; i < showItems; i++) {
						MenuItem_Typedef* Item = CurMenu + MenuWindow.topitem + i;
						GUI_MenuItemDraw(MEMU_POSX_1, MEMU_POSY_1 + i * 15, Item);
					}
					MenuScrollbar.topitem = cur_sequence;
 80032b0:	f8d9 3000 	ldr.w	r3, [r9]
					GUI_Scrollbar_SetPos(&MenuScrollbar);
 80032b4:	483b      	ldr	r0, [pc, #236]	; (80033a4 <Menu_Task+0x180>)
					MenuScrollbar.topitem = cur_sequence;
 80032b6:	f8c8 3018 	str.w	r3, [r8, #24]
					GUI_Scrollbar_SetPos(&MenuScrollbar);
 80032ba:	f000 f9a0 	bl	80035fe <GUI_Scrollbar_SetPos>
					GUI_Refresh();
 80032be:	f000 f99c 	bl	80035fa <GUI_Refresh>
				break;
			}
			vTaskDelay(100/portTICK_PERIOD_MS);
 80032c2:	2064      	movs	r0, #100	; 0x64
 80032c4:	f7ff fb88 	bl	80029d8 <vTaskDelay>
			cur_rotateNum = RotaryEcncorder_GetCount();
 80032c8:	e7ba      	b.n	8003240 <Menu_Task+0x1c>
						if (CurMenu->cursorPosition < 0) {
 80032ca:	2b00      	cmp	r3, #0
						showItems = MenuWindow.itemsperpage;
 80032cc:	fa5f fa81 	uxtb.w	sl, r1
						if (CurMenu->cursorPosition < 0) {
 80032d0:	dae9      	bge.n	80032a6 <Menu_Task+0x82>
							CurMenu->cursorPosition = 0;
 80032d2:	7016      	strb	r6, [r2, #0]
							if (MenuWindow.topitem > 0)
 80032d4:	6963      	ldr	r3, [r4, #20]
 80032d6:	2b00      	cmp	r3, #0
 80032d8:	d0e5      	beq.n	80032a6 <Menu_Task+0x82>
								MenuWindow.topitem--;
 80032da:	3b01      	subs	r3, #1
 80032dc:	6163      	str	r3, [r4, #20]
 80032de:	e7e2      	b.n	80032a6 <Menu_Task+0x82>
						MenuItem_Typedef* Item = CurMenu + MenuWindow.topitem + i;
 80032e0:	6962      	ldr	r2, [r4, #20]
 80032e2:	682b      	ldr	r3, [r5, #0]
 80032e4:	4432      	add	r2, r6
						GUI_MenuItemDraw(MEMU_POSX_1, MEMU_POSY_1 + i * 15, Item);
 80032e6:	ebc6 1106 	rsb	r1, r6, r6, lsl #4
 80032ea:	fb0b 3202 	mla	r2, fp, r2, r3
 80032ee:	3113      	adds	r1, #19
 80032f0:	2014      	movs	r0, #20
 80032f2:	f000 f91f 	bl	8003534 <GUI_MenuItemDraw>
					for (int i = 0; i < showItems; i++) {
 80032f6:	3601      	adds	r6, #1
 80032f8:	e7d8      	b.n	80032ac <Menu_Task+0x88>
					GUI_RectangleFill(MenuWindow.x+1,MenuScrollbar.y,MenuScrollbar.x-1,MenuWindow.height-2,0);
 80032fa:	f04f 0a00 	mov.w	sl, #0
 80032fe:	f8df 80a4 	ldr.w	r8, [pc, #164]	; 80033a4 <Menu_Task+0x180>
 8003302:	68e3      	ldr	r3, [r4, #12]
 8003304:	f8d8 2000 	ldr.w	r2, [r8]
 8003308:	6820      	ldr	r0, [r4, #0]
					Menu_SetSelected(cur_sequence,false);
 800330a:	f8df 909c 	ldr.w	r9, [pc, #156]	; 80033a8 <Menu_Task+0x184>
					GUI_RectangleFill(MenuWindow.x+1,MenuScrollbar.y,MenuScrollbar.x-1,MenuWindow.height-2,0);
 800330e:	3b02      	subs	r3, #2
 8003310:	3a01      	subs	r2, #1
 8003312:	f8d8 1004 	ldr.w	r1, [r8, #4]
 8003316:	3001      	adds	r0, #1
 8003318:	f8cd a000 	str.w	sl, [sp]
 800331c:	f000 f86a 	bl	80033f4 <GUI_RectangleFill>
					Menu_SetSelected(cur_sequence,false);
 8003320:	4651      	mov	r1, sl
 8003322:	f8d9 0000 	ldr.w	r0, [r9]
 8003326:	f7ff ff6f 	bl	8003208 <Menu_SetSelected>
					cur_sequence = cur_rotateNum;
 800332a:	6838      	ldr	r0, [r7, #0]
					Menu_SetSelected(cur_sequence,true);
 800332c:	4631      	mov	r1, r6
					cur_sequence = cur_rotateNum;
 800332e:	f8c9 0000 	str.w	r0, [r9]
					Menu_SetSelected(cur_sequence,true);
 8003332:	f7ff ff69 	bl	8003208 <Menu_SetSelected>
					CurMenu->cursorPosition++;
 8003336:	682a      	ldr	r2, [r5, #0]
 8003338:	7813      	ldrb	r3, [r2, #0]
					if (CurMenu->menuItemCount <= MenuWindow.itemsperpage) {
 800333a:	7856      	ldrb	r6, [r2, #1]
					CurMenu->cursorPosition++;
 800333c:	3301      	adds	r3, #1
 800333e:	b25b      	sxtb	r3, r3
 8003340:	7013      	strb	r3, [r2, #0]
					if (CurMenu->menuItemCount <= MenuWindow.itemsperpage) {
 8003342:	6921      	ldr	r1, [r4, #16]
 8003344:	4630      	mov	r0, r6
 8003346:	428e      	cmp	r6, r1
 8003348:	d817      	bhi.n	800337a <Menu_Task+0x156>
						if (CurMenu->cursorPosition >= CurMenu->menuItemCount)
 800334a:	42b3      	cmp	r3, r6
 800334c:	db01      	blt.n	8003352 <Menu_Task+0x12e>
							CurMenu->cursorPosition = CurMenu->menuItemCount - 1;
 800334e:	1e73      	subs	r3, r6, #1
 8003350:	7013      	strb	r3, [r2, #0]
					for (int i = 0; i < showItems; i++) {
 8003352:	f04f 0a00 	mov.w	sl, #0
						MenuItem_Typedef* Item = CurMenu + MenuWindow.topitem + i;
 8003356:	f04f 0b1c 	mov.w	fp, #28
					for (int i = 0; i < showItems; i++) {
 800335a:	45b2      	cmp	sl, r6
 800335c:	daa8      	bge.n	80032b0 <Menu_Task+0x8c>
						MenuItem_Typedef* Item = CurMenu + MenuWindow.topitem + i;
 800335e:	6962      	ldr	r2, [r4, #20]
 8003360:	682b      	ldr	r3, [r5, #0]
 8003362:	4452      	add	r2, sl
						GUI_MenuItemDraw(MEMU_POSX_1, MEMU_POSY_1 + i * 15, Item);
 8003364:	ebca 110a 	rsb	r1, sl, sl, lsl #4
 8003368:	fb0b 3202 	mla	r2, fp, r2, r3
 800336c:	3113      	adds	r1, #19
 800336e:	2014      	movs	r0, #20
 8003370:	f000 f8e0 	bl	8003534 <GUI_MenuItemDraw>
					for (int i = 0; i < showItems; i++) {
 8003374:	f10a 0a01 	add.w	sl, sl, #1
 8003378:	e7ef      	b.n	800335a <Menu_Task+0x136>
						if (CurMenu->cursorPosition > MenuWindow.itemsperpage - 1) {
 800337a:	f101 3eff 	add.w	lr, r1, #4294967295
 800337e:	4573      	cmp	r3, lr
						showItems = MenuWindow.itemsperpage;
 8003380:	b2ce      	uxtb	r6, r1
						if (CurMenu->cursorPosition > MenuWindow.itemsperpage - 1) {
 8003382:	d9e6      	bls.n	8003352 <Menu_Task+0x12e>
							CurMenu->cursorPosition = MenuWindow.itemsperpage - 1;
 8003384:	1e73      	subs	r3, r6, #1
 8003386:	7013      	strb	r3, [r2, #0]
							if (MenuWindow.topitem < CurMenu->menuItemCount - MenuWindow.itemsperpage)
 8003388:	6963      	ldr	r3, [r4, #20]
 800338a:	1a41      	subs	r1, r0, r1
 800338c:	428b      	cmp	r3, r1
								MenuWindow.topitem++;
 800338e:	bf3c      	itt	cc
 8003390:	3301      	addcc	r3, #1
 8003392:	6163      	strcc	r3, [r4, #20]
 8003394:	e7dd      	b.n	8003352 <Menu_Task+0x12e>
 8003396:	bf00      	nop
 8003398:	2000008c 	.word	0x2000008c
 800339c:	20003e5c 	.word	0x20003e5c
 80033a0:	200000b0 	.word	0x200000b0
 80033a4:	20000090 	.word	0x20000090
 80033a8:	20003e60 	.word	0x20003e60

080033ac <GUI_Rectangle>:
*           color	顯示顏色
* 出口參數：無
* 說明：操作失敗原因是指定地址超出有效範圍。
****************************************************************************/
void  GUI_Rectangle(uint32_t x0, uint32_t y0, uint32_t x1, uint32_t y1, TCOLOR color)
{  
 80033ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80033b0:	461c      	mov	r4, r3
 80033b2:	f89d 5018 	ldrb.w	r5, [sp, #24]
	GUI_HLine(x0, y0, x1, color);
 80033b6:	fa1f f880 	uxth.w	r8, r0
 80033ba:	b2cf      	uxtb	r7, r1
 80033bc:	b296      	uxth	r6, r2
	GUI_HLine(x0, y1, x1, color);
 80033be:	b2e4      	uxtb	r4, r4
	GUI_HLine(x0, y0, x1, color);
 80033c0:	462b      	mov	r3, r5
 80033c2:	4632      	mov	r2, r6
 80033c4:	4639      	mov	r1, r7
 80033c6:	4640      	mov	r0, r8
 80033c8:	f000 f8ed 	bl	80035a6 <GUI_HLine>
	GUI_HLine(x0, y1, x1, color);
 80033cc:	462b      	mov	r3, r5
 80033ce:	4632      	mov	r2, r6
 80033d0:	4621      	mov	r1, r4
 80033d2:	4640      	mov	r0, r8
 80033d4:	f000 f8e7 	bl	80035a6 <GUI_HLine>
	GUI_RLine(x0, y0, y1, color);
 80033d8:	462b      	mov	r3, r5
 80033da:	4622      	mov	r2, r4
 80033dc:	4639      	mov	r1, r7
 80033de:	4640      	mov	r0, r8
 80033e0:	f000 f8f6 	bl	80035d0 <GUI_RLine>
	GUI_RLine(x1, y0, y1, color);
 80033e4:	462b      	mov	r3, r5
 80033e6:	4622      	mov	r2, r4
 80033e8:	4639      	mov	r1, r7
 80033ea:	4630      	mov	r0, r6
}
 80033ec:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	GUI_RLine(x1, y0, y1, color);
 80033f0:	f000 b8ee 	b.w	80035d0 <GUI_RLine>

080033f4 <GUI_RectangleFill>:
*           color	填充顏色
* 出口參數：無
* 說明：操作失敗原因是指定地址超出有效範圍。
****************************************************************************/
void  GUI_RectangleFill(uint32_t x0, uint32_t y0, uint32_t x1, uint32_t y1, TCOLOR color)
{  
 80033f4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint32_t  i;

	/* 先找出矩形左上角與右下角的兩個點，保存在(x0,y0)，(x1,y1) */
	if(x0>x1) 						// 若x0>x1，則x0與x1交換
 80033f8:	4290      	cmp	r0, r2
{  
 80033fa:	460c      	mov	r4, r1
 80033fc:	461f      	mov	r7, r3
 80033fe:	f89d 8018 	ldrb.w	r8, [sp, #24]
	if(x0>x1) 						// 若x0>x1，則x0與x1交換
 8003402:	d82b      	bhi.n	800345c <GUI_RectangleFill+0x68>
	{  
		i = x0;
		x0 = x1;
		x1 = i;
	}
	if(y0>y1)						// 若y0>y1，則y0與y1交換
 8003404:	4299      	cmp	r1, r3
 8003406:	d809      	bhi.n	800341c <GUI_RectangleFill+0x28>
		y0 = y1;
		y1 = i;
	}

	/* 判斷是否只是直線 */
	if(y0==y1) 
 8003408:	42bc      	cmp	r4, r7
 800340a:	d109      	bne.n	8003420 <GUI_RectangleFill+0x2c>
	{  
		GUI_HLine(x0, y0, x1, color);
 800340c:	4643      	mov	r3, r8
 800340e:	b2e1      	uxtb	r1, r4
 8003410:	b292      	uxth	r2, r2
 8003412:	b280      	uxth	r0, r0
	while(y0<=y1)						
	{  
		GUI_HLine(x0, y0, x1, color);	// 當前畫水平線
		y0++;							// 下一行
	}
}
 8003414:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		GUI_HLine(x0, y0, x1, color);
 8003418:	f000 b8c5 	b.w	80035a6 <GUI_HLine>
 800341c:	463c      	mov	r4, r7
 800341e:	460f      	mov	r7, r1
	if(x0==x1) 
 8003420:	4290      	cmp	r0, r2
 8003422:	d10d      	bne.n	8003440 <GUI_RectangleFill+0x4c>
		GUI_RLine(x0, y0, y1, color);
 8003424:	4643      	mov	r3, r8
 8003426:	b2fa      	uxtb	r2, r7
 8003428:	b2e1      	uxtb	r1, r4
 800342a:	b280      	uxth	r0, r0
}
 800342c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		GUI_RLine(x0, y0, y1, color);
 8003430:	f000 b8ce 	b.w	80035d0 <GUI_RLine>
	if(y0>y1)						// 若y0>y1，則y0與y1交換
 8003434:	463b      	mov	r3, r7
 8003436:	4627      	mov	r7, r4
 8003438:	461c      	mov	r4, r3
 800343a:	4603      	mov	r3, r0
 800343c:	4610      	mov	r0, r2
 800343e:	461a      	mov	r2, r3
		GUI_HLine(x0, y0, x1, color);	// 當前畫水平線
 8003440:	b296      	uxth	r6, r2
 8003442:	b285      	uxth	r5, r0
	while(y0<=y1)						
 8003444:	42bc      	cmp	r4, r7
 8003446:	d901      	bls.n	800344c <GUI_RectangleFill+0x58>
 8003448:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		GUI_HLine(x0, y0, x1, color);	// 當前畫水平線
 800344c:	b2e1      	uxtb	r1, r4
 800344e:	4643      	mov	r3, r8
 8003450:	4632      	mov	r2, r6
 8003452:	4628      	mov	r0, r5
 8003454:	f000 f8a7 	bl	80035a6 <GUI_HLine>
		y0++;							// 下一行
 8003458:	3401      	adds	r4, #1
 800345a:	e7f3      	b.n	8003444 <GUI_RectangleFill+0x50>
	if(y0>y1)						// 若y0>y1，則y0與y1交換
 800345c:	4299      	cmp	r1, r3
 800345e:	d8e9      	bhi.n	8003434 <GUI_RectangleFill+0x40>
 8003460:	4603      	mov	r3, r0
 8003462:	4610      	mov	r0, r2
 8003464:	461a      	mov	r2, r3
 8003466:	e7cf      	b.n	8003408 <GUI_RectangleFill+0x14>

08003468 <GUI_Line>:
*           color	顯示顏色(對於黑白色LCM，為0時滅，為1時顯示)
* 出口參數：無
* 說明：操作失敗原因是指定地址超出有效範圍。
****************************************************************************/
void  GUI_Line(uint32_t x0, uint32_t y0, uint32_t x1, uint32_t y1, TCOLOR color)
{  
 8003468:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800346c:	4699      	mov	r9, r3
	int8_t    dy_sym;				// y軸增長方向，為-1時減值方向，為1時增值方向
	int32_t   dx_x2;				// dx*2值變量，用於加快運算速度
	int32_t   dy_x2;				// dy*2值變量，用於加快運算速度
	int32_t   di;					// 決策變量

	dx = x1-x0;						// 求取兩點之間的差值
 800346e:	1a13      	subs	r3, r2, r0
	dy = y1-y0;
	/* 判斷增長方向，或是否為水平線、垂直線、點 */
	if(dx>0)						// 判斷x軸方向
 8003470:	2b00      	cmp	r3, #0
{  
 8003472:	4604      	mov	r4, r0
 8003474:	460d      	mov	r5, r1
 8003476:	4692      	mov	sl, r2
 8003478:	f89d 6030 	ldrb.w	r6, [sp, #48]	; 0x30
	dy = y1-y0;
 800347c:	eba9 0201 	sub.w	r2, r9, r1
 8003480:	b280      	uxth	r0, r0
 8003482:	b2c9      	uxtb	r1, r1
	if(dx>0)						// 判斷x軸方向
 8003484:	dc08      	bgt.n	8003498 <GUI_Line+0x30>
	{  
		dx_sym = 1;					// dx>0，設置dx_sym=1
	}
	else
	{  
		if(dx<0)
 8003486:	d113      	bne.n	80034b0 <GUI_Line+0x48>
			dx_sym = -1;			// dx<0，設置dx_sym=-1
		else
		{  							// dx==0，畫垂直線，或一點
			GUI_RLine(x0, y0, y1, color);
 8003488:	4633      	mov	r3, r6
 800348a:	fa5f f289 	uxtb.w	r2, r9
				x0 += dx_sym;
			}
		}
		GUI_Point(x0, y0, color);		// 顯示最後一點
	} 
}
 800348e:	b003      	add	sp, #12
 8003490:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			GUI_RLine(x0, y0, y1, color);
 8003494:	f000 b89c 	b.w	80035d0 <GUI_RLine>
		dx_sym = 1;					// dx>0，設置dx_sym=1
 8003498:	2701      	movs	r7, #1
	if(dy>0)						// 判斷y軸方向
 800349a:	2a00      	cmp	r2, #0
 800349c:	dc0b      	bgt.n	80034b6 <GUI_Line+0x4e>
		if(dy<0)
 800349e:	d124      	bne.n	80034ea <GUI_Line+0x82>
			GUI_HLine(x0, y0, x1, color);
 80034a0:	4633      	mov	r3, r6
 80034a2:	fa1f f28a 	uxth.w	r2, sl
}
 80034a6:	b003      	add	sp, #12
 80034a8:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			GUI_HLine(x0, y0, x1, color);
 80034ac:	f000 b87b 	b.w	80035a6 <GUI_HLine>
			dx_sym = -1;			// dx<0，設置dx_sym=-1
 80034b0:	f04f 37ff 	mov.w	r7, #4294967295
 80034b4:	e7f1      	b.n	800349a <GUI_Line+0x32>
		dy_sym = 1;					// dy>0，設置dy_sym=1
 80034b6:	f04f 0801 	mov.w	r8, #1
	dx = dx_sym * dx;
 80034ba:	fb03 f107 	mul.w	r1, r3, r7
	dy = dy_sym * dy;
 80034be:	fb02 f208 	mul.w	r2, r2, r8
	if(dx>=dy)						// 對於dx>=dy，則使用x軸為基準
 80034c2:	4291      	cmp	r1, r2
	dx_x2 = dx*2;
 80034c4:	ea4f 0b41 	mov.w	fp, r1, lsl #1
	dy_x2 = dy*2;
 80034c8:	ea4f 0342 	mov.w	r3, r2, lsl #1
	if(dx>=dy)						// 對於dx>=dy，則使用x軸為基準
 80034cc:	db1d      	blt.n	800350a <GUI_Line+0xa2>
		di = dy_x2 - dx;
 80034ce:	eba3 0901 	sub.w	r9, r3, r1
				di += dy_x2 - dx_x2;
 80034d2:	eba9 0b01 	sub.w	fp, r9, r1
		while(x0!=x1)
 80034d6:	4554      	cmp	r4, sl
 80034d8:	b2e9      	uxtb	r1, r5
 80034da:	b2a0      	uxth	r0, r4
 80034dc:	d108      	bne.n	80034f0 <GUI_Line+0x88>
		GUI_Point(x0, y0, color);		// 顯示最後一點
 80034de:	4632      	mov	r2, r6
}
 80034e0:	b003      	add	sp, #12
 80034e2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		GUI_Point(x0, y0, color);		// 顯示最後一點
 80034e6:	f000 b85b 	b.w	80035a0 <GUI_Point>
			dy_sym = -1;			// dy<0，設置dy_sym=-1
 80034ea:	f04f 38ff 	mov.w	r8, #4294967295
 80034ee:	e7e4      	b.n	80034ba <GUI_Line+0x52>
			GUI_Point(x0, y0, color);
 80034f0:	4632      	mov	r2, r6
 80034f2:	9301      	str	r3, [sp, #4]
 80034f4:	f000 f854 	bl	80035a0 <GUI_Point>
			if(di<0)
 80034f8:	9b01      	ldr	r3, [sp, #4]
 80034fa:	f1b9 0f00 	cmp.w	r9, #0
 80034fe:	443c      	add	r4, r7
				di += dy_x2;		// 計算出下一步的決策值
 8003500:	bfb2      	itee	lt
 8003502:	4499      	addlt	r9, r3
				di += dy_x2 - dx_x2;
 8003504:	44d9      	addge	r9, fp
				y0 += dy_sym;
 8003506:	4445      	addge	r5, r8
 8003508:	e7e5      	b.n	80034d6 <GUI_Line+0x6e>
		di = dx_x2 - dy;
 800350a:	ebab 0a02 	sub.w	sl, fp, r2
				di += dx_x2 - dy_x2;
 800350e:	ebaa 0302 	sub.w	r3, sl, r2
		while(y0!=y1)
 8003512:	454d      	cmp	r5, r9
 8003514:	b2e9      	uxtb	r1, r5
 8003516:	b2a0      	uxth	r0, r4
 8003518:	d0e1      	beq.n	80034de <GUI_Line+0x76>
			GUI_Point(x0, y0, color);
 800351a:	4632      	mov	r2, r6
 800351c:	9301      	str	r3, [sp, #4]
 800351e:	f000 f83f 	bl	80035a0 <GUI_Point>
			if(di<0)
 8003522:	9b01      	ldr	r3, [sp, #4]
 8003524:	f1ba 0f00 	cmp.w	sl, #0
 8003528:	4445      	add	r5, r8
				di += dx_x2;
 800352a:	bfb2      	itee	lt
 800352c:	44da      	addlt	sl, fp
				di += dx_x2 - dy_x2;
 800352e:	449a      	addge	sl, r3
				x0 += dx_sym;
 8003530:	19e4      	addge	r4, r4, r7
 8003532:	e7ee      	b.n	8003512 <GUI_Line+0xaa>

08003534 <GUI_MenuItemDraw>:
* 功能：顯示條目菜單
* 入口參數：ico		圖標菜單句柄
* 出口參數：返回0表示操作失敗，返回1表示操作成功
****************************************************************************/
uint8_t  GUI_MenuItemDraw(uint32_t x, uint32_t y, MenuItem_Typedef *item)
{  
 8003534:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	if( x>GUI_LCM_XMAX || y>GUI_LCM_YMAX) return(0);
	if(y<2) return(0);
 8003536:	f1a1 0e02 	sub.w	lr, r1, #2
 800353a:	f1be 0f3e 	cmp.w	lr, #62	; 0x3e
{  
 800353e:	4615      	mov	r5, r2
	if(y<2) return(0);
 8003540:	d82a      	bhi.n	8003598 <GUI_MenuItemDraw+0x64>
	if(x<18) return(0);
 8003542:	f1a0 0412 	sub.w	r4, r0, #18
 8003546:	2cee      	cmp	r4, #238	; 0xee
 8003548:	d826      	bhi.n	8003598 <GUI_MenuItemDraw+0x64>
	if( (item->title)==NULL )  return(0);
 800354a:	68d3      	ldr	r3, [r2, #12]
 800354c:	b333      	cbz	r3, 800359c <GUI_MenuItemDraw+0x68>

	if(item->isSelect == false)
 800354e:	7893      	ldrb	r3, [r2, #2]
 8003550:	b28f      	uxth	r7, r1
 8003552:	b286      	uxth	r6, r0
 8003554:	b9a3      	cbnz	r3, 8003580 <GUI_MenuItemDraw+0x4c>
	{  
		if(item->icoUnselected != NULL)
 8003556:	6892      	ldr	r2, [r2, #8]
 8003558:	b132      	cbz	r2, 8003568 <GUI_MenuItemDraw+0x34>
			OLED_ShowPicture(x-18, y-2, (uint8_t *)item->icoUnselected ,16, 16);
 800355a:	2310      	movs	r3, #16
 800355c:	fa5f f18e 	uxtb.w	r1, lr
 8003560:	9300      	str	r3, [sp, #0]
 8003562:	b2e0      	uxtb	r0, r4
 8003564:	f7fd f9a0 	bl	80008a8 <OLED_ShowPicture>
		show_str(x, y,(uint8_t *) item->title,12,12,1);
 8003568:	2401      	movs	r4, #1
 800356a:	9401      	str	r4, [sp, #4]
	}
	else
	{  
		if(item->icoSelected != NULL)
			OLED_ShowPicture(x-18, y-2, (uint8_t *)item->icoSelected ,16, 16);
		show_str(x,y,(uint8_t *) item->title, 12,12,0);
 800356c:	230c      	movs	r3, #12
 800356e:	4630      	mov	r0, r6
 8003570:	9300      	str	r3, [sp, #0]
 8003572:	68ea      	ldr	r2, [r5, #12]
 8003574:	4639      	mov	r1, r7
 8003576:	f000 f8dd 	bl	8003734 <show_str>
	}
	return(1);
 800357a:	2001      	movs	r0, #1
}
 800357c:	b003      	add	sp, #12
 800357e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if(item->icoSelected != NULL)
 8003580:	6852      	ldr	r2, [r2, #4]
 8003582:	b132      	cbz	r2, 8003592 <GUI_MenuItemDraw+0x5e>
			OLED_ShowPicture(x-18, y-2, (uint8_t *)item->icoSelected ,16, 16);
 8003584:	2310      	movs	r3, #16
 8003586:	fa5f f18e 	uxtb.w	r1, lr
 800358a:	9300      	str	r3, [sp, #0]
 800358c:	b2e0      	uxtb	r0, r4
 800358e:	f7fd f98b 	bl	80008a8 <OLED_ShowPicture>
		show_str(x,y,(uint8_t *) item->title, 12,12,0);
 8003592:	2300      	movs	r3, #0
 8003594:	9301      	str	r3, [sp, #4]
 8003596:	e7e9      	b.n	800356c <GUI_MenuItemDraw+0x38>
	if(y<2) return(0);
 8003598:	2000      	movs	r0, #0
 800359a:	e7ef      	b.n	800357c <GUI_MenuItemDraw+0x48>
 800359c:	4618      	mov	r0, r3
 800359e:	e7ed      	b.n	800357c <GUI_MenuItemDraw+0x48>

080035a0 <GUI_Point>:
*          效範圍)
* 說明：用戶根據LCM的實際情況編寫此函數。
****************************************************************************/
void  GUI_Point(uint16_t x, uint8_t y, TCOLOR color)
{
	OLED_DrawPoint(x,y,color);
 80035a0:	b2c0      	uxtb	r0, r0
 80035a2:	f7fd b8a5 	b.w	80006f0 <OLED_DrawPoint>

080035a6 <GUI_HLine>:
*      新8個點，而不需要一個點一個點的寫到LCM中。
****************************************************************************/
void  GUI_HLine(uint16_t x0, uint8_t y0, uint16_t x1, TCOLOR color)
{
	uint8_t  temp;
	if(x0>x1)               // 對x0、x1大小進行排列，以便畫圖
 80035a6:	4290      	cmp	r0, r2
{
 80035a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80035aa:	461f      	mov	r7, r3
 80035ac:	bf88      	it	hi
 80035ae:	b2d3      	uxtbhi	r3, r2
 80035b0:	4604      	mov	r4, r0
 80035b2:	4615      	mov	r5, r2
 80035b4:	460e      	mov	r6, r1
	if(x0>x1)               // 對x0、x1大小進行排列，以便畫圖
 80035b6:	bf84      	itt	hi
 80035b8:	4605      	movhi	r5, r0
	{
		temp = x1;
		x1 = x0;
		x0 = temp;
 80035ba:	461c      	movhi	r4, r3
	OLED_DrawPoint(x,y,color);
 80035bc:	b2e0      	uxtb	r0, r4
	}
	do
	{
		GUI_Point(x0, y0, color);   // 逐點顯示，描出垂直線
		x0++;
 80035be:	3401      	adds	r4, #1
	OLED_DrawPoint(x,y,color);
 80035c0:	463a      	mov	r2, r7
 80035c2:	4631      	mov	r1, r6
		x0++;
 80035c4:	b2a4      	uxth	r4, r4
	OLED_DrawPoint(x,y,color);
 80035c6:	f7fd f893 	bl	80006f0 <OLED_DrawPoint>
	}
	while(x1>=x0);
 80035ca:	42a5      	cmp	r5, r4
 80035cc:	d2f6      	bcs.n	80035bc <GUI_HLine+0x16>
}
 80035ce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080035d0 <GUI_RLine>:
*      新8個點，而不需要一個點一個點的寫到LCM中。
****************************************************************************/
void  GUI_RLine(uint16_t x0, uint8_t y0, uint8_t y1, TCOLOR color)
{
    uint8_t  temp;
    if(y0>y1)       // 對y0、y1大小進行排列，以便畫圖
 80035d0:	4291      	cmp	r1, r2
{
 80035d2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80035d4:	461f      	mov	r7, r3
    if(y0>y1)       // 對y0、y1大小進行排列，以便畫圖
 80035d6:	bf88      	it	hi
 80035d8:	460b      	movhi	r3, r1
{
 80035da:	460c      	mov	r4, r1
 80035dc:	4615      	mov	r5, r2
    if(y0>y1)       // 對y0、y1大小進行排列，以便畫圖
 80035de:	bf84      	itt	hi
 80035e0:	4614      	movhi	r4, r2
 80035e2:	461d      	movhi	r5, r3
	OLED_DrawPoint(x,y,color);
 80035e4:	b2c6      	uxtb	r6, r0
 80035e6:	4621      	mov	r1, r4
        y0 = temp;
    }
    do
    {
        GUI_Point(x0, y0, color);   // 逐點顯示，描出垂直線
        y0++;
 80035e8:	3401      	adds	r4, #1
	OLED_DrawPoint(x,y,color);
 80035ea:	463a      	mov	r2, r7
 80035ec:	4630      	mov	r0, r6
        y0++;
 80035ee:	b2e4      	uxtb	r4, r4
	OLED_DrawPoint(x,y,color);
 80035f0:	f7fd f87e 	bl	80006f0 <OLED_DrawPoint>
    }
    while(y1>=y0);
 80035f4:	42a5      	cmp	r5, r4
 80035f6:	d2f6      	bcs.n	80035e6 <GUI_RLine+0x16>
}
 80035f8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080035fa <GUI_Refresh>:
* 功能：刷新屏幕
*           
****************************************************************************/
void  GUI_Refresh(void)
{
	OLED_RefreshGram();
 80035fa:	f7fd b8bb 	b.w	8000774 <OLED_RefreshGram>

080035fe <GUI_Scrollbar_SetPos>:
0x40,0x70,0x7C,0x7E,0x7E,0x7C,0x70,0x40,
};

//設置滾動條的位置
void GUI_Scrollbar_SetPos(Scrollbar_Typedef *scbx)
{	
 80035fe:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
	uint16_t x,y,xlen,ylen;
//	uint8_t scbplen;
//	
//	scbplen = SCROLL_BTN_HEIGHT;  //得到按鈕的高度
	
	scblen=scbx->height-2*SCROLL_BTN_HEIGHT-scbx->scbbarlen;//得到滾動條滾動空間的長度
 8003602:	68c4      	ldr	r4, [r0, #12]
 8003604:	8b82      	ldrh	r2, [r0, #28]
 8003606:	3c14      	subs	r4, #20
 8003608:	1aa4      	subs	r4, r4, r2
 800360a:	fa1f f984 	uxth.w	r9, r4
	y=scbx->y+SCROLL_BTN_HEIGHT;  //滾動條起始坐標y
	xlen=scbx->width-2-1;         //滾動條寬度 -1
	ylen=scblen+scbx->scbbarlen-1;//滾動條長度 -1
	
	//清除滾動條
	GUI_RectangleFill(x ,y,x+xlen,y+ylen, 0);
 800360e:	2400      	movs	r4, #0
{	
 8003610:	4605      	mov	r5, r0
	x=scbx->x+1;                  //滾動條起始坐標x
 8003612:	6807      	ldr	r7, [r0, #0]
	xlen=scbx->width-2-1;         //滾動條寬度 -1
 8003614:	6886      	ldr	r6, [r0, #8]
	y=scbx->y+SCROLL_BTN_HEIGHT;  //滾動條起始坐標y
 8003616:	6841      	ldr	r1, [r0, #4]
	ylen=scblen+scbx->scbbarlen-1;//滾動條長度 -1
 8003618:	1e53      	subs	r3, r2, #1
	x=scbx->x+1;                  //滾動條起始坐標x
 800361a:	3701      	adds	r7, #1
	xlen=scbx->width-2-1;         //滾動條寬度 -1
 800361c:	3e03      	subs	r6, #3
	x=scbx->x+1;                  //滾動條起始坐標x
 800361e:	b2bf      	uxth	r7, r7
	y=scbx->y+SCROLL_BTN_HEIGHT;  //滾動條起始坐標y
 8003620:	310a      	adds	r1, #10
	ylen=scblen+scbx->scbbarlen-1;//滾動條長度 -1
 8003622:	444b      	add	r3, r9
	GUI_RectangleFill(x ,y,x+xlen,y+ylen, 0);
 8003624:	b2b6      	uxth	r6, r6
	y=scbx->y+SCROLL_BTN_HEIGHT;  //滾動條起始坐標y
 8003626:	fa1f f881 	uxth.w	r8, r1
	GUI_RectangleFill(x ,y,x+xlen,y+ylen, 0);
 800362a:	443e      	add	r6, r7
 800362c:	b29b      	uxth	r3, r3
 800362e:	9400      	str	r4, [sp, #0]
 8003630:	4443      	add	r3, r8
 8003632:	4632      	mov	r2, r6
 8003634:	4641      	mov	r1, r8
 8003636:	4638      	mov	r0, r7
 8003638:	f7ff fedc 	bl	80033f4 <GUI_RectangleFill>
	if(scbx->totalitems <= scbx->itemsperpage)//總條目不夠一頁顯示的
 800363c:	6929      	ldr	r1, [r5, #16]
 800363e:	696b      	ldr	r3, [r5, #20]
	{
		scbpos=(scbx->topitem*scblen)/(scbx->totalitems-1);//計算當前滾動條偏移的位置
	}
	
	//畫出滾動條
	GUI_RectangleFill(x ,y+scbpos,x+xlen,y+scbpos+scbx->scbbarlen, 1);
 8003640:	2201      	movs	r2, #1
	if(scbx->totalitems <= scbx->itemsperpage)//總條目不夠一頁顯示的
 8003642:	4299      	cmp	r1, r3
		scbpos=(scbx->topitem*scblen)/(scbx->totalitems-1);//計算當前滾動條偏移的位置
 8003644:	bf81      	itttt	hi
 8003646:	69ab      	ldrhi	r3, [r5, #24]
 8003648:	f101 31ff 	addhi.w	r1, r1, #4294967295
 800364c:	fb03 f409 	mulhi.w	r4, r3, r9
 8003650:	fbb4 f4f1 	udivhi	r4, r4, r1
	GUI_RectangleFill(x ,y+scbpos,x+xlen,y+scbpos+scbx->scbbarlen, 1);
 8003654:	69eb      	ldr	r3, [r5, #28]
 8003656:	b2a4      	uxth	r4, r4
 8003658:	eb04 0108 	add.w	r1, r4, r8
 800365c:	9200      	str	r2, [sp, #0]
 800365e:	440b      	add	r3, r1
 8003660:	4632      	mov	r2, r6
 8003662:	4638      	mov	r0, r7
 8003664:	f7ff fec6 	bl	80033f4 <GUI_RectangleFill>
	//GUI_Refresh();	//刷新屏幕
}
 8003668:	b003      	add	sp, #12
 800366a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	...

08003670 <GUI_ScrollbarDraw>:



//創建一個滾動條
void GUI_ScrollbarDraw(Scrollbar_Typedef *scbx)
{
 8003670:	b573      	push	{r0, r1, r4, r5, r6, lr}
	uint32_t scbactlen=0;//滾動條可以滾動的空間長度
	if(scbx==NULL) return;
 8003672:	4604      	mov	r4, r0
 8003674:	2800      	cmp	r0, #0
 8003676:	d057      	beq.n	8003728 <GUI_ScrollbarDraw+0xb8>
	if(scbx->width<SCROLL_BTN_WIDTH) return;
 8003678:	6882      	ldr	r2, [r0, #8]
 800367a:	2a09      	cmp	r2, #9
 800367c:	d954      	bls.n	8003728 <GUI_ScrollbarDraw+0xb8>
	if(scbx->height<2*SCROLL_BTN_HEIGHT) return;
 800367e:	68c3      	ldr	r3, [r0, #12]
 8003680:	2b13      	cmp	r3, #19
 8003682:	d951      	bls.n	8003728 <GUI_ScrollbarDraw+0xb8>
	
	//畫外邊框
	GUI_Rectangle(scbx->x, scbx->y, scbx->x+scbx->width-1, scbx->y+scbx->height-1, 1);
 8003684:	c803      	ldmia	r0, {r0, r1}
 8003686:	2501      	movs	r5, #1
	//畫上下兩個按鈕
	OLED_ShowPicture(scbx->x+(scbx->width-8)/2, scbx->y+1, (uint8_t *)scroll_btn_up, 8, 8);
 8003688:	2608      	movs	r6, #8
	GUI_Rectangle(scbx->x, scbx->y, scbx->x+scbx->width-1, scbx->y+scbx->height-1, 1);
 800368a:	440b      	add	r3, r1
 800368c:	4402      	add	r2, r0
 800368e:	9500      	str	r5, [sp, #0]
 8003690:	3b01      	subs	r3, #1
 8003692:	3a01      	subs	r2, #1
 8003694:	f7ff fe8a 	bl	80033ac <GUI_Rectangle>
	OLED_ShowPicture(scbx->x+(scbx->width-8)/2, scbx->y+1, (uint8_t *)scroll_btn_up, 8, 8);
 8003698:	68a0      	ldr	r0, [r4, #8]
 800369a:	6861      	ldr	r1, [r4, #4]
 800369c:	f1a0 0308 	sub.w	r3, r0, #8
 80036a0:	6820      	ldr	r0, [r4, #0]
 80036a2:	4429      	add	r1, r5
 80036a4:	eb00 0053 	add.w	r0, r0, r3, lsr #1
 80036a8:	9600      	str	r6, [sp, #0]
 80036aa:	4633      	mov	r3, r6
 80036ac:	4a1f      	ldr	r2, [pc, #124]	; (800372c <GUI_ScrollbarDraw+0xbc>)
 80036ae:	b2c9      	uxtb	r1, r1
 80036b0:	b2c0      	uxtb	r0, r0
 80036b2:	f7fd f8f9 	bl	80008a8 <OLED_ShowPicture>
	OLED_ShowPicture(scbx->x+(scbx->width-8)/2, scbx->y+scbx->height-9, (uint8_t *)scroll_btn_down, 8, 8);
 80036b6:	68e3      	ldr	r3, [r4, #12]
 80036b8:	68a0      	ldr	r0, [r4, #8]
 80036ba:	6861      	ldr	r1, [r4, #4]
 80036bc:	4a1c      	ldr	r2, [pc, #112]	; (8003730 <GUI_ScrollbarDraw+0xc0>)
 80036be:	4419      	add	r1, r3
 80036c0:	f1a0 0308 	sub.w	r3, r0, #8
 80036c4:	6820      	ldr	r0, [r4, #0]
 80036c6:	3909      	subs	r1, #9
 80036c8:	eb00 0053 	add.w	r0, r0, r3, lsr #1
 80036cc:	9600      	str	r6, [sp, #0]
 80036ce:	4633      	mov	r3, r6
 80036d0:	b2c9      	uxtb	r1, r1
 80036d2:	b2c0      	uxtb	r0, r0
 80036d4:	f7fd f8e8 	bl	80008a8 <OLED_ShowPicture>
	//畫按鈕邊框
	GUI_Line(scbx->x, scbx->y+9, scbx->x+scbx->width-1, scbx->y+9,1);
 80036d8:	e894 0009 	ldmia.w	r4, {r0, r3}
 80036dc:	68a2      	ldr	r2, [r4, #8]
 80036de:	3309      	adds	r3, #9
 80036e0:	4402      	add	r2, r0
 80036e2:	4619      	mov	r1, r3
 80036e4:	9500      	str	r5, [sp, #0]
 80036e6:	3a01      	subs	r2, #1
 80036e8:	f7ff febe 	bl	8003468 <GUI_Line>
	GUI_Line(scbx->x, scbx->y+scbx->height-10, scbx->x+scbx->width-1, scbx->y+scbx->height-10,1);
 80036ec:	e894 0009 	ldmia.w	r4, {r0, r3}
 80036f0:	68e2      	ldr	r2, [r4, #12]
 80036f2:	4413      	add	r3, r2
 80036f4:	68a2      	ldr	r2, [r4, #8]
 80036f6:	3b0a      	subs	r3, #10
 80036f8:	4402      	add	r2, r0
 80036fa:	4619      	mov	r1, r3
 80036fc:	9500      	str	r5, [sp, #0]
 80036fe:	3a01      	subs	r2, #1
 8003700:	f7ff feb2 	bl	8003468 <GUI_Line>
	
	
	//可供滾動條滾動的空間範圍
	scbactlen=scbx->height -2*SCROLL_BTN_HEIGHT;
 8003704:	68e3      	ldr	r3, [r4, #12]
	
	//每頁滾動條目大於總條目數 滾動條目等於最大可滾動的控件
	if(scbx->itemsperpage >= scbx->totalitems)scbx->scbbarlen=scbactlen;
 8003706:	6921      	ldr	r1, [r4, #16]
	scbactlen=scbx->height -2*SCROLL_BTN_HEIGHT;
 8003708:	f1a3 0214 	sub.w	r2, r3, #20
	if(scbx->itemsperpage >= scbx->totalitems)scbx->scbbarlen=scbactlen;
 800370c:	6963      	ldr	r3, [r4, #20]
	//每頁滾動條目小於總條目數
	else scbx->scbbarlen=(scbactlen*scbx->itemsperpage)/scbx->totalitems;//得到滾動條的長度
	//設置滾動條的位置
	GUI_Scrollbar_SetPos(scbx);
 800370e:	4620      	mov	r0, r4
	if(scbx->itemsperpage >= scbx->totalitems)scbx->scbbarlen=scbactlen;
 8003710:	428b      	cmp	r3, r1
	else scbx->scbbarlen=(scbactlen*scbx->itemsperpage)/scbx->totalitems;//得到滾動條的長度
 8003712:	bf3b      	ittet	cc
 8003714:	4353      	mulcc	r3, r2
 8003716:	fbb3 f3f1 	udivcc	r3, r3, r1
	if(scbx->itemsperpage >= scbx->totalitems)scbx->scbbarlen=scbactlen;
 800371a:	61e2      	strcs	r2, [r4, #28]
	else scbx->scbbarlen=(scbactlen*scbx->itemsperpage)/scbx->totalitems;//得到滾動條的長度
 800371c:	61e3      	strcc	r3, [r4, #28]
}
 800371e:	b002      	add	sp, #8
 8003720:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	GUI_Scrollbar_SetPos(scbx);
 8003724:	f7ff bf6b 	b.w	80035fe <GUI_Scrollbar_SetPos>
}
 8003728:	b002      	add	sp, #8
 800372a:	bd70      	pop	{r4, r5, r6, pc}
 800372c:	080041cc 	.word	0x080041cc
 8003730:	080041c4 	.word	0x080041c4

08003734 <show_str>:
//str  :字符串
//f_w:字寬
//f_h:字高
//mode:0,非疊加方式;1,疊加方式
void show_str(uint16_t x,uint16_t y,const uint8_t*str,uint8_t f_w,uint8_t f_h,uint8_t mode)
{					
 8003734:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003738:	4680      	mov	r8, r0
	uint16_t x0 = x;
	uint16_t y0 = y;
	while (*str != 0)
 800373a:	460c      	mov	r4, r1
 800373c:	4645      	mov	r5, r8
{					
 800373e:	b085      	sub	sp, #20
 8003740:	f89d 7038 	ldrb.w	r7, [sp, #56]	; 0x38
 8003744:	4616      	mov	r6, r2
 8003746:	f89d 203c 	ldrb.w	r2, [sp, #60]	; 0x3c
			y += f_h;
			x = x0;
			str++;
		}
		else
			OLED_ShowChar(x, y, *str, f_w / 2, f_h, mode);     //有效部分寫入
 800374a:	ea4f 0a53 	mov.w	sl, r3, lsr #1
{					
 800374e:	9203      	str	r2, [sp, #12]
		if (x > (x0 + LCD_WIDTH - f_h / 2))     //換行
 8003750:	087a      	lsrs	r2, r7, #1
 8003752:	f5c2 7080 	rsb	r0, r2, #256	; 0x100
		str++;
		x += f_h / 2; //字符,為全字的一半
 8003756:	b293      	uxth	r3, r2
		if (y > (y0 + LCD_HIGH - f_h))
 8003758:	f101 0940 	add.w	r9, r1, #64	; 0x40
		if (x > (x0 + LCD_WIDTH - f_h / 2))     //換行
 800375c:	eb00 0b08 	add.w	fp, r0, r8
		x += f_h / 2; //字符,為全字的一半
 8003760:	9302      	str	r3, [sp, #8]
		if (y > (y0 + LCD_HIGH - f_h))
 8003762:	eba9 0907 	sub.w	r9, r9, r7
	while (*str != 0)
 8003766:	7832      	ldrb	r2, [r6, #0]
 8003768:	b912      	cbnz	r2, 8003770 <show_str+0x3c>

	}
}  			 		 
 800376a:	b005      	add	sp, #20
 800376c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (x > (x0 + LCD_WIDTH - f_h / 2))     //換行
 8003770:	455d      	cmp	r5, fp
			y += f_h;
 8003772:	bfc2      	ittt	gt
 8003774:	19e4      	addgt	r4, r4, r7
 8003776:	b2a4      	uxthgt	r4, r4
			x = x0;
 8003778:	4645      	movgt	r5, r8
		if (y > (y0 + LCD_HIGH - f_h))
 800377a:	454c      	cmp	r4, r9
 800377c:	dcf5      	bgt.n	800376a <show_str+0x36>
		if (*str == 13) //換行符號
 800377e:	2a0d      	cmp	r2, #13
 8003780:	d108      	bne.n	8003794 <show_str+0x60>
			x = x0;
 8003782:	4645      	mov	r5, r8
			y += f_h;
 8003784:	443c      	add	r4, r7
 8003786:	b2a4      	uxth	r4, r4
			str++;
 8003788:	3601      	adds	r6, #1
		x += f_h / 2; //字符,為全字的一半
 800378a:	9b02      	ldr	r3, [sp, #8]
		str++;
 800378c:	3601      	adds	r6, #1
		x += f_h / 2; //字符,為全字的一半
 800378e:	441d      	add	r5, r3
 8003790:	b2ad      	uxth	r5, r5
 8003792:	e7e8      	b.n	8003766 <show_str+0x32>
			OLED_ShowChar(x, y, *str, f_w / 2, f_h, mode);     //有效部分寫入
 8003794:	9b03      	ldr	r3, [sp, #12]
 8003796:	9700      	str	r7, [sp, #0]
 8003798:	9301      	str	r3, [sp, #4]
 800379a:	b2e1      	uxtb	r1, r4
 800379c:	4653      	mov	r3, sl
 800379e:	b2e8      	uxtb	r0, r5
 80037a0:	f7fd f826 	bl	80007f0 <OLED_ShowChar>
 80037a4:	e7f1      	b.n	800378a <show_str+0x56>

080037a6 <show_str_mid>:
//在指定寬度的中間顯示字符串(置中顯示)
//如果字符長度超過了len,則用Show_Str顯示
//len:指定要顯示的寬度
void show_str_mid(uint16_t x,uint16_t y,const uint8_t*str,uint8_t f_w,uint8_t f_h,uint8_t mode,uint16_t len)
{
 80037a6:	e92d 4ff1 	stmdb	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80037aa:	4606      	mov	r6, r0
	uint16_t strlenth=0;
   	strlenth=strlen((char*)str);
 80037ac:	4610      	mov	r0, r2
{
 80037ae:	4689      	mov	r9, r1
 80037b0:	4617      	mov	r7, r2
 80037b2:	469a      	mov	sl, r3
   	strlenth=strlen((char*)str);
 80037b4:	f7fc fd3c 	bl	8000230 <strlen>
{
 80037b8:	f89d 8028 	ldrb.w	r8, [sp, #40]	; 0x28
 80037bc:	f8bd 4030 	ldrh.w	r4, [sp, #48]	; 0x30
	strlenth*=f_h/2;
 80037c0:	ea4f 0558 	mov.w	r5, r8, lsr #1
 80037c4:	4368      	muls	r0, r5
 80037c6:	b280      	uxth	r0, r0
	if(strlenth>len)show_str(x,y,str,f_w,f_h,mode);
 80037c8:	42a0      	cmp	r0, r4
{
 80037ca:	f89d b02c 	ldrb.w	fp, [sp, #44]	; 0x2c
	if(strlenth>len)show_str(x,y,str,f_w,f_h,mode);
 80037ce:	d90c      	bls.n	80037ea <show_str_mid+0x44>
 80037d0:	4653      	mov	r3, sl
 80037d2:	463a      	mov	r2, r7
 80037d4:	4649      	mov	r1, r9
 80037d6:	4630      	mov	r0, r6
 80037d8:	f8cd b02c 	str.w	fp, [sp, #44]	; 0x2c
 80037dc:	f8cd 8028 	str.w	r8, [sp, #40]	; 0x28
	else
	{
		strlenth=(len-strlenth)/2;
	    show_str(strlenth+x,y,str,f_w,f_h,mode);
	}
}   
 80037e0:	b001      	add	sp, #4
 80037e2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	    show_str(strlenth+x,y,str,f_w,f_h,mode);
 80037e6:	f7ff bfa5 	b.w	8003734 <show_str>
		strlenth=(len-strlenth)/2;
 80037ea:	1a24      	subs	r4, r4, r0
 80037ec:	2002      	movs	r0, #2
 80037ee:	fb94 f0f0 	sdiv	r0, r4, r0
	    show_str(strlenth+x,y,str,f_w,f_h,mode);
 80037f2:	4430      	add	r0, r6
 80037f4:	f8cd b02c 	str.w	fp, [sp, #44]	; 0x2c
 80037f8:	f8cd 8028 	str.w	r8, [sp, #40]	; 0x28
 80037fc:	4653      	mov	r3, sl
 80037fe:	463a      	mov	r2, r7
 8003800:	4649      	mov	r1, r9
 8003802:	b280      	uxth	r0, r0
 8003804:	e7ec      	b.n	80037e0 <show_str_mid+0x3a>

08003806 <getWindowStringlen>:

#if  GUI_WINDOW_EN==1

//得到字符串的長度
uint16_t getWindowStringlen(const unsigned char *str)
{
 8003806:	b508      	push	{r3, lr}
	uint16_t strlenth=0;
	strlenth=strlen((const char*)str);
 8003808:	f7fc fd12 	bl	8000230 <strlen>
 800380c:	b280      	uxth	r0, r0
	strlenth*=6;
 800380e:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 8003812:	0040      	lsls	r0, r0, #1

	return strlenth;
 8003814:	b280      	uxth	r0, r0
}
 8003816:	bd08      	pop	{r3, pc}

08003818 <GUI_WindowsDraw>:
* 功能：顯示視窗。根據提供的視窗參數進行描繪視窗。
* 入口參數：win		窗口句柄
* 出口參數：返回0表示操作失敗，返回1表示操作成功
****************************************************************************/
uint8_t  GUI_WindowsDraw(WINDOWS *win)
{  
 8003818:	b5f0      	push	{r4, r5, r6, r7, lr}
	/* 參數過濾，若窗口起出範圍，則返回0 */
	if( ( (win->width)<20 ) || ( (win->height)<20 ) ) return(0);	// 寬度、高度檢查，限制最小窗口
 800381a:	6882      	ldr	r2, [r0, #8]
{  
 800381c:	b085      	sub	sp, #20
	if( ( (win->width)<20 ) || ( (win->height)<20 ) ) return(0);	// 寬度、高度檢查，限制最小窗口
 800381e:	2a13      	cmp	r2, #19
{  
 8003820:	4604      	mov	r4, r0
	if( ( (win->width)<20 ) || ( (win->height)<20 ) ) return(0);	// 寬度、高度檢查，限制最小窗口
 8003822:	d802      	bhi.n	800382a <GUI_WindowsDraw+0x12>
 8003824:	2000      	movs	r0, #0
	{  
		return 0;//顯示的標題超過了窗體的寬度
	}	
	show_str_mid(win->x, win->y+1, win->title,12,12,0,win->width);//顯示標題
	return(1);
}
 8003826:	b005      	add	sp, #20
 8003828:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if( ( (win->width)<20 ) || ( (win->height)<20 ) ) return(0);	// 寬度、高度檢查，限制最小窗口
 800382a:	68c3      	ldr	r3, [r0, #12]
 800382c:	2b13      	cmp	r3, #19
 800382e:	d9f9      	bls.n	8003824 <GUI_WindowsDraw+0xc>
	if( (win->x + win->width ) > GUI_LCM_XMAX ) return(0);			// 窗口寬度是否溢出
 8003830:	6800      	ldr	r0, [r0, #0]
 8003832:	4402      	add	r2, r0
 8003834:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 8003838:	d8f4      	bhi.n	8003824 <GUI_WindowsDraw+0xc>
	if( (win->y + win->height ) > GUI_LCM_YMAX ) return(0);			// 窗口高度是否溢出
 800383a:	6861      	ldr	r1, [r4, #4]
 800383c:	440b      	add	r3, r1
 800383e:	2b40      	cmp	r3, #64	; 0x40
 8003840:	d8f0      	bhi.n	8003824 <GUI_WindowsDraw+0xc>
	GUI_RectangleFill(win->x, win->y, win->x + win->width - 1, win->y + win->height - 1, 0);// 清除視窗(全螢幕清除)
 8003842:	2600      	movs	r6, #0
	GUI_Rectangle(win->x, win->y, win->x + win->width - 1, win->y + win->height - 1, 1);	// 畫窗口邊框
 8003844:	2501      	movs	r5, #1
	GUI_RectangleFill(win->x, win->y, win->x + win->width - 1, win->y + win->height - 1, 0);// 清除視窗(全螢幕清除)
 8003846:	3b01      	subs	r3, #1
 8003848:	3a01      	subs	r2, #1
 800384a:	9600      	str	r6, [sp, #0]
 800384c:	f7ff fdd2 	bl	80033f4 <GUI_RectangleFill>
	GUI_Rectangle(win->x, win->y, win->x + win->width - 1, win->y + win->height - 1, 1);	// 畫窗口邊框
 8003850:	e894 0003 	ldmia.w	r4, {r0, r1}
 8003854:	68e3      	ldr	r3, [r4, #12]
 8003856:	68a2      	ldr	r2, [r4, #8]
 8003858:	440b      	add	r3, r1
 800385a:	4402      	add	r2, r0
 800385c:	3b01      	subs	r3, #1
 800385e:	3a01      	subs	r2, #1
 8003860:	9500      	str	r5, [sp, #0]
 8003862:	f7ff fda3 	bl	80033ac <GUI_Rectangle>
	GUI_HLine(win->x, win->y + 14, win->x + win->width - 1, disp_color);					// 畫標題目欄下邊框
 8003866:	8820      	ldrh	r0, [r4, #0]
 8003868:	68a2      	ldr	r2, [r4, #8]
 800386a:	6861      	ldr	r1, [r4, #4]
 800386c:	4402      	add	r2, r0
 800386e:	4b13      	ldr	r3, [pc, #76]	; (80038bc <GUI_WindowsDraw+0xa4>)
 8003870:	3a01      	subs	r2, #1
 8003872:	310e      	adds	r1, #14
 8003874:	781b      	ldrb	r3, [r3, #0]
 8003876:	b292      	uxth	r2, r2
 8003878:	b2c9      	uxtb	r1, r1
 800387a:	f7ff fe94 	bl	80035a6 <GUI_HLine>
	GUI_RectangleFill(win->x, win->y, win->x + win->width - 1, win->y + 14-1, 1);
 800387e:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 8003882:	4402      	add	r2, r0
 8003884:	f101 030d 	add.w	r3, r1, #13
 8003888:	3a01      	subs	r2, #1
 800388a:	9500      	str	r5, [sp, #0]
 800388c:	f7ff fdb2 	bl	80033f4 <GUI_RectangleFill>
	if(getWindowStringlen(win->title)>(win->width-2))
 8003890:	69a7      	ldr	r7, [r4, #24]
 8003892:	4638      	mov	r0, r7
 8003894:	f7ff ffb7 	bl	8003806 <getWindowStringlen>
 8003898:	68a3      	ldr	r3, [r4, #8]
 800389a:	1e9a      	subs	r2, r3, #2
 800389c:	4290      	cmp	r0, r2
 800389e:	d8c1      	bhi.n	8003824 <GUI_WindowsDraw+0xc>
	show_str_mid(win->x, win->y+1, win->title,12,12,0,win->width);//顯示標題
 80038a0:	b29b      	uxth	r3, r3
 80038a2:	9302      	str	r3, [sp, #8]
 80038a4:	230c      	movs	r3, #12
 80038a6:	6861      	ldr	r1, [r4, #4]
 80038a8:	8820      	ldrh	r0, [r4, #0]
 80038aa:	4429      	add	r1, r5
 80038ac:	9601      	str	r6, [sp, #4]
 80038ae:	9300      	str	r3, [sp, #0]
 80038b0:	463a      	mov	r2, r7
 80038b2:	b289      	uxth	r1, r1
 80038b4:	f7ff ff77 	bl	80037a6 <show_str_mid>
	return(1);
 80038b8:	4628      	mov	r0, r5
 80038ba:	e7b4      	b.n	8003826 <GUI_WindowsDraw+0xe>
 80038bc:	200000d1 	.word	0x200000d1

080038c0 <Reset_Handler>:
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:

/* Copy the data segment initializers from flash to SRAM */
  movs r1, #0
 80038c0:	2100      	movs	r1, #0
  b LoopCopyDataInit
 80038c2:	e003      	b.n	80038cc <LoopCopyDataInit>

080038c4 <CopyDataInit>:

CopyDataInit:
  ldr r3, =_sidata
 80038c4:	4b0b      	ldr	r3, [pc, #44]	; (80038f4 <LoopFillZerobss+0x14>)
  ldr r3, [r3, r1]
 80038c6:	585b      	ldr	r3, [r3, r1]
  str r3, [r0, r1]
 80038c8:	5043      	str	r3, [r0, r1]
  adds r1, r1, #4
 80038ca:	3104      	adds	r1, #4

080038cc <LoopCopyDataInit>:

LoopCopyDataInit:
  ldr r0, =_sdata
 80038cc:	480a      	ldr	r0, [pc, #40]	; (80038f8 <LoopFillZerobss+0x18>)
  ldr r3, =_edata
 80038ce:	4b0b      	ldr	r3, [pc, #44]	; (80038fc <LoopFillZerobss+0x1c>)
  adds r2, r0, r1
 80038d0:	1842      	adds	r2, r0, r1
  cmp r2, r3
 80038d2:	429a      	cmp	r2, r3
  bcc CopyDataInit
 80038d4:	d3f6      	bcc.n	80038c4 <CopyDataInit>
  ldr r2, =_sbss
 80038d6:	4a0a      	ldr	r2, [pc, #40]	; (8003900 <LoopFillZerobss+0x20>)
  b LoopFillZerobss
 80038d8:	e002      	b.n	80038e0 <LoopFillZerobss>

080038da <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
  movs r3, #0
 80038da:	2300      	movs	r3, #0
  str r3, [r2], #4
 80038dc:	f842 3b04 	str.w	r3, [r2], #4

080038e0 <LoopFillZerobss>:

LoopFillZerobss:
  ldr r3, = _ebss
 80038e0:	4b08      	ldr	r3, [pc, #32]	; (8003904 <LoopFillZerobss+0x24>)
  cmp r2, r3
 80038e2:	429a      	cmp	r2, r3
  bcc FillZerobss
 80038e4:	d3f9      	bcc.n	80038da <FillZerobss>

/* Call the clock system intitialization function.*/
    bl  SystemInit
 80038e6:	f7fc feb5 	bl	8000654 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 80038ea:	f000 f80f 	bl	800390c <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 80038ee:	f7fc fd27 	bl	8000340 <main>
  bx lr
 80038f2:	4770      	bx	lr
  ldr r3, =_sidata
 80038f4:	080041dc 	.word	0x080041dc
  ldr r0, =_sdata
 80038f8:	20000000 	.word	0x20000000
  ldr r3, =_edata
 80038fc:	200000d4 	.word	0x200000d4
  ldr r2, =_sbss
 8003900:	200000d4 	.word	0x200000d4
  ldr r3, = _ebss
 8003904:	20004028 	.word	0x20004028

08003908 <ADC1_2_IRQHandler>:
 * @retval : None
*/
    .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8003908:	e7fe      	b.n	8003908 <ADC1_2_IRQHandler>
	...

0800390c <__libc_init_array>:
 800390c:	b570      	push	{r4, r5, r6, lr}
 800390e:	2500      	movs	r5, #0
 8003910:	4e0c      	ldr	r6, [pc, #48]	; (8003944 <__libc_init_array+0x38>)
 8003912:	4c0d      	ldr	r4, [pc, #52]	; (8003948 <__libc_init_array+0x3c>)
 8003914:	1ba4      	subs	r4, r4, r6
 8003916:	10a4      	asrs	r4, r4, #2
 8003918:	42a5      	cmp	r5, r4
 800391a:	d109      	bne.n	8003930 <__libc_init_array+0x24>
 800391c:	f000 f826 	bl	800396c <_init>
 8003920:	2500      	movs	r5, #0
 8003922:	4e0a      	ldr	r6, [pc, #40]	; (800394c <__libc_init_array+0x40>)
 8003924:	4c0a      	ldr	r4, [pc, #40]	; (8003950 <__libc_init_array+0x44>)
 8003926:	1ba4      	subs	r4, r4, r6
 8003928:	10a4      	asrs	r4, r4, #2
 800392a:	42a5      	cmp	r5, r4
 800392c:	d105      	bne.n	800393a <__libc_init_array+0x2e>
 800392e:	bd70      	pop	{r4, r5, r6, pc}
 8003930:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8003934:	4798      	blx	r3
 8003936:	3501      	adds	r5, #1
 8003938:	e7ee      	b.n	8003918 <__libc_init_array+0xc>
 800393a:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 800393e:	4798      	blx	r3
 8003940:	3501      	adds	r5, #1
 8003942:	e7f2      	b.n	800392a <__libc_init_array+0x1e>
 8003944:	080041d4 	.word	0x080041d4
 8003948:	080041d4 	.word	0x080041d4
 800394c:	080041d4 	.word	0x080041d4
 8003950:	080041d8 	.word	0x080041d8

08003954 <memcpy>:
 8003954:	b510      	push	{r4, lr}
 8003956:	1e43      	subs	r3, r0, #1
 8003958:	440a      	add	r2, r1
 800395a:	4291      	cmp	r1, r2
 800395c:	d100      	bne.n	8003960 <memcpy+0xc>
 800395e:	bd10      	pop	{r4, pc}
 8003960:	f811 4b01 	ldrb.w	r4, [r1], #1
 8003964:	f803 4f01 	strb.w	r4, [r3, #1]!
 8003968:	e7f7      	b.n	800395a <memcpy+0x6>
	...

0800396c <_init>:
 800396c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800396e:	bf00      	nop
 8003970:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8003972:	bc08      	pop	{r3}
 8003974:	469e      	mov	lr, r3
 8003976:	4770      	bx	lr

08003978 <_fini>:
 8003978:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800397a:	bf00      	nop
 800397c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800397e:	bc08      	pop	{r3}
 8003980:	469e      	mov	lr, r3
 8003982:	4770      	bx	lr
